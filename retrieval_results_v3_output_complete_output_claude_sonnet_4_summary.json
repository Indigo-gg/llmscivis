[
  {
    "path": "",
    "name": "",
    "prompt": "Generate an HTML page using vtk.js to visualize the rotor dataset._x000d_\n_x000d_\n- Load the dataset from: http://127.0.0.1:5000/dataset/rotor.vti_x000d_\n- Set the active scalar array to \"Pressure\"._x000d_\n- Apply a slice along the Y axis at 95% depth of the dataset (convert percentage to slice index)._x000d_\n- Use a blue → white → red color map for pressure values, spanning from the minimum to maximum scalar range._x000d_\n- Set opacity to fully opaque (no transparency variation)._x000d_\n- Add an orientation marker with XYZ axes in the bottom-right corner._x000d_\n- No interactive GUI controls are required._x000d_\n",
    "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>Rotor Dataset Cutting Rendering</title>_x000d_\n<style>_x000d_\nbody,_x000d_\nhtml {_x000d_\nmargin: 0;_x000d_\npadding: 0;_x000d_\nwidth: 100%;_x000d_\nheight: 100%;_x000d_\noverflow: hidden;_x000d_\n}_x000d_\n_x000d_\n#renderer {_x000d_\nwidth: 100%;_x000d_\nheight: 100%;_x000d_\n}_x000d_\n</style>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<div id=\"renderer\"></div>_x000d_\n<script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>_x000d_\n<script>_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkActor = vtk.Rendering.Core.vtkActor;_x000d_\nconst vtkMapper = vtk.Rendering.Core.vtkMapper;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\nconst vtkPlane = vtk.Common.DataModel.vtkPlane;_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\n_x000d_\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [1, 1, 1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\nreader.setUrl('http://127.0.0.1:5000/dataset/rotor_simplified.vti').then(() => {_x000d_\nreader.loadData().then(() => {_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\nimageData.getPointData().setActiveScalars('Pressure');_x000d_\n_x000d_\nconst vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;_x000d_\nconst vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;_x000d_\n_x000d_\nconst imageMapper = vtkImageMapper.newInstance();_x000d_\nimageMapper.setInputData(imageData);_x000d_\nconst dims = imageData.getDimensions();_x000d_\nimageMapper.setSlice(dims[1] * 0.95);_x000d_\nimageMapper.setSlicingMode(1); //(0:X, 1:Y, 2:Z)_x000d_\n_x000d_\nconst pressureArray = imageData.getPointData().getArrayByName('Pressure');_x000d_\nconst [pMin, pMax] = pressureArray.getRange();_x000d_\nconst colorTransferFunction = vtkColorTransferFunction.newInstance();_x000d_\ncolorTransferFunction.addRGBPoint(pMin, 0.0, 0.0, 0.8);_x000d_\ncolorTransferFunction.addRGBPoint((pMin + pMax) / 2, 1.0, 1.0, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(pMax, 0.8, 0.0, 0.0);_x000d_\n_x000d_\n// Add opacity transfer function_x000d_\nconst vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;_x000d_\nconst opacityFunction = vtkPiecewiseFunction.newInstance();_x000d_\nopacityFunction.addPoint(pMin, 1.0);_x000d_\nopacityFunction.addPoint(pMax, 1.0);_x000d_\n_x000d_\nconst imageSlice = vtkImageSlice.newInstance();_x000d_\nimageSlice.setMapper(imageMapper);_x000d_\nimageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);_x000d_\nimageSlice.getProperty().setPiecewiseFunction(0, opacityFunction); // Set opacity function_x000d_\nimageSlice.getProperty().setScalarOpacity(0, opacityFunction); // Set scalar opacity_x000d_\nimageSlice.getProperty().setUseLookupTableScalarRange(true);_x000d_\n_x000d_\nrenderer.addActor(imageSlice);_x000d_\n_x000d_\nconst axes = vtk.Rendering.Core.vtkAxesActor.newInstance();_x000d_\nconst widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({_x000d_\nactor: axes,_x000d_\ninteractor: renderWindow.getInteractor(),_x000d_\n});_x000d_\nwidget.setEnabled(true);_x000d_\nwidget.setViewportCorner(_x000d_\nvtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT_x000d_\n);_x000d_\nwidget.setViewportSize(0.15);_x000d_\n_x000d_\nrenderer.resetCamera();_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderWindow.render();_x000d_\n});_x000d_\n});_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
    "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotor Dataset Visualization</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            font-family: Arial, sans-serif;\n        }\n        #renderer {\n            width: 100vw;\n            height: 100vh;\n            background-color: #000;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n    <script>\n        // VTK.js module references\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n\n        // Create full screen render window\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n        \n        // Function to fetch the VTI data using XMLHttpRequest\n        async function loadVTIData(url) {\n            return new Promise((resolve, reject) => {\n                const xhr = new XMLHttpRequest();\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function() {\n                    if (xhr.status === 200) {\n                        resolve(xhr.response);\n                    } else {\n                        reject(new Error(`Failed to load data: ${xhr.status}`));\n                    }\n                };\n                xhr.onerror = () => reject(new Error('Network error'));\n                xhr.open('GET', url);\n                xhr.send();\n            });\n        }\n\n        // Main function to load and visualize the rotor dataset\n        async function visualizeRotorDataset() {\n            try {\n                // Load the dataset from the specified URL\n                const data = await loadVTIData('http://127.0.0.1:5000/dataset/rotor.vti');\n                \n                // Create VTK XML Image Data Reader to parse the VTI file\n                const reader = vtkXMLImageDataReader.newInstance();\n                reader.parseAsArrayBuffer(data);\n                \n                const imageData = reader.getOutputData();\n                \n                // REQUIREMENT: Set the active scalar array to \"Pressure\"\n                const pressureArray = imageData.getPointData().getArrayByName('Pressure');\n                if (pressureArray) {\n                    imageData.getPointData().setActiveScalars('Pressure');\n                    console.log('Set active scalar array to \"Pressure\"');\n                } else {\n                    console.error('Pressure array not found in dataset');\n                    return;\n                }\n                \n                // Get dataset dimensions and calculate slice position\n                const dimensions = imageData.getDimensions();\n                const extent = imageData.getExtent();\n                \n                // REQUIREMENT: Apply a slice along the Y axis at 95% depth\n                // Convert percentage to slice index (95% depth means 95% through the Y dimension)\n                const yRange = extent[3] - extent[2]; // Max Y - Min Y\n                const sliceIndex = extent[2] + Math.floor(yRange * 0.95);\n                console.log(`Y-axis slice at 95% depth: index ${sliceIndex} of range [${extent[2]}, ${extent[3]}]`);\n                \n                // Create image mapper and set the Y-axis slice (J-slice)\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setJSlice(sliceIndex); // J-slice corresponds to Y-axis\n                \n                // Create image slice actor\n                const imageActor = vtkImageSlice.newInstance();\n                imageActor.setMapper(imageMapper);\n                \n                // REQUIREMENT: Get pressure scalar range for color mapping\n                const scalarRange = pressureArray.getRange();\n                console.log(`Pressure scalar range: [${scalarRange[0]}, ${scalarRange[1]}]`);\n                \n                // REQUIREMENT: Create blue → white → red color map\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const minValue = scalarRange[0];\n                const maxValue = scalarRange[1];\n                const midValue = (minValue + maxValue) / 2;\n                \n                // Blue at minimum value\n                colorTransferFunction.addRGBPoint(minValue, 0.0, 0.0, 1.0);\n                // White at middle value\n                colorTransferFunction.addRGBPoint(midValue, 1.0, 1.0, 1.0);\n                // Red at maximum value\n                colorTransferFunction.addRGBPoint(maxValue, 1.0, 0.0, 0.0);\n                \n                // Apply color transfer function to the actor\n                imageActor.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                \n                // REQUIREMENT: Set opacity to fully opaque (no transparency variation)\n                imageActor.getProperty().setOpacity(1.0);\n                console.log('Set opacity to fully opaque (1.0)');\n                \n                // Add the image actor to the renderer\n                renderer.addActor(imageActor);\n                \n                // REQUIREMENT: Add orientation marker with XYZ axes in bottom-right corner\n                const axes = vtkAxesActor.newInstance();\n                axes.setShaftTypeToCylinder();\n                axes.setXAxisLabelText('X');\n                axes.setYAxisLabelText('Y');\n                axes.setZAxisLabelText('Z');\n                \n                const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                \n                // Position the orientation marker in the bottom-right corner\n                orientationWidget.setEnabled(true);\n                orientationWidget.setViewport([0.8, 0.0, 1.0, 0.2]); // Bottom-right corner\n                console.log('Added XYZ orientation marker in bottom-right corner');\n                \n                // Reset camera and render\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                \n                console.log('Rotor dataset visualization complete');\n                \n            } catch (error) {\n                console.error('Error loading or visualizing dataset:', error);\n            }\n        }\n        \n        // Initialize the visualization\n        visualizeRotorDataset();\n        \n    </script>\n</body>\n</html>\n```",
    "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
    "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the rotor dataset._x000d_\n_x000d_\n- Load the dataset from: http://127.0.0.1:5000/dataset/rotor.vti_x000d_\n- Set the active scalar array to \"Pressure\"._x000d_\n- Apply a slice along the Y axis at 95% depth of the dataset (convert percentage to slice index)._x000d_\n- Use a blue → white → red color map for pressure values, spanning from the minimum to maximum scalar range._x000d_\n- Set opacity to fully opaque (no transparency variation)._x000d_\n- Add an orientation marker with XYZ axes in the bottom-right corner._x000d_\n- No interactive GUI controls are required._x000d_\n\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):\nDescription: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageLabelOutline</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Use the vtk namespace to reference each class\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        // Use the vtk namespace to reference constants\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.5, 0.5, 0.5],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const BACKGROUND = 0;\n        const LOW_VALUE = 80;\n        const HIGH_VALUE = 160;\n\n        const FIRST_SEGMENT = 1;\n        const SECOND_SEGMENT = 5;\n\n        /**\n         * Creates a labelmap image with the same dimensions as the background volume.\n         * @param {vtkImageData} backgroundImageData - The background volume data.\n         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.\n         */\n        function createLabelmap(backgroundImageData) {\n            // Create a labelmap image the same dimensions as our background volume.\n            const labelMapData = vtkImageData.newInstance(\n                backgroundImageData.get('spacing', 'origin', 'direction')\n            );\n\n            labelMapData.computeTransforms();\n\n            const dataArray = vtkDataArray.newInstance({\n                numberOfComponents: 1,\n                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),\n            });\n            labelMapData.getPointData().setScalars(dataArray);\n\n            labelMapData.setDimensions(...backgroundImageData.getDimensions());\n            labelMapData.setSpacing(...backgroundImageData.getSpacing());\n            labelMapData.setOrigin(...backgroundImageData.getOrigin());\n            labelMapData.setDirection(...backgroundImageData.getDirection());\n            const mapper = vtkImageMapper.newInstance();\n            mapper.setInputData(labelMapData);\n\n            const actor = vtkImageSlice.newInstance();\n\n            actor.setMapper(mapper);\n\n            const labelMap = {\n                actor,\n                mapper,\n                imageData: labelMapData,\n                cfun: vtkColorTransferFunction.newInstance(),\n                ofun: vtkPiecewiseFunction.newInstance(),\n            };\n\n            // Labelmap pipeline\n            labelMap.mapper.setInputData(labelMapData);\n            labelMap.actor.setMapper(labelMap.mapper);\n\n            // Set up labelMap color and opacity mapping\n            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label \"5\" will be green\n            labelMap.ofun.addPoint(0, 0);\n            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.\n            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.\n\n            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);\n            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);\n            labelMap.actor.getProperty().setInterpolationTypeToNearest();\n\n            labelMap.actor.getProperty().setUseLabelOutline(true);\n            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4\n            // (positioned at array index 4)\n            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);\n            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);\n\n            // This is very important to make sure the labelmap is rendered\n            // correctly\n            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);\n\n            const dims = labelMap.imageData.getDimensions();\n            const values = labelMap.imageData.getPointData().getScalars().getData();\n\n            const backgroundValues = backgroundImageData\n                .getPointData()\n                .getScalars()\n                .getData();\n            const size = dims[0] * dims[1] * dims[2];\n\n            for (let i = 0; i < size; i++) {\n                if (backgroundValues[i] === LOW_VALUE) {\n                    values[i] = FIRST_SEGMENT;\n                } else if (backgroundValues[i] === HIGH_VALUE) {\n                    values[i] = SECOND_SEGMENT;\n                }\n            }\n\n            labelMap.imageData.getPointData().getScalars().setData(values);\n\n            return labelMap;\n        }\n\n        // Create a one slice vtkImageData that has four quadrants of different values\n        const imageData = vtkImageData.newInstance();\n        const dims = [10, 10, 1];\n        imageData.setSpacing(1, 1, 1);\n        imageData.setOrigin(0.1, 0.1, 0.1);\n        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);\n\n        imageData.computeTransforms();\n\n        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);\n\n        let i = 0;\n        for (let y = 0; y < dims[1]; y++) {\n            for (let x = 0; x < dims[0]; x++, i++) {\n                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {\n                    values[i] = BACKGROUND;\n                } else if (x > 4 && x < 6 && y > 4 && y < 7) {\n                    values[i] = LOW_VALUE;\n                } else {\n                    values[i] = HIGH_VALUE;\n                }\n            }\n        }\n\n        const dataArray = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values,\n        });\n        imageData.getPointData().setScalars(dataArray);\n        imageData.modified();\n\n        const data = imageData;\n        const labelMap = createLabelmap(data);\n\n        const actor = vtkImageSlice.newInstance();\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(data);\n        actor.setMapper(mapper);\n        actor.getProperty().setInterpolationTypeToNearest();\n\n        renderer.addActor(actor);\n        renderer.addActor(labelMap.actor);\n        renderer.resetCamera();\n        renderer.resetCameraClippingRange();\n        renderWindow.render();\n\n        window.fullScreen = fullScreenRenderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 2 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):\nDescription: Generates and displays a 2D random image (100x100) using `vtkImageSlice` and `vtkImageMapper`.\n\nModules: vtk.Common.Core.vtkDataArray.newInstance, vtk.Common.DataModel.vtkImageData, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;// Actor for rendering 2D image slices\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n\n        // Create render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Create image data\n        const imageData = vtkImageData.newInstance();\n        imageData.setDimensions(100, 100, 1);\n        imageData.setSpacing(1.0, 1.0, 1.0);\n        imageData.setOrigin(0.0, 0.0, 0.0);\n\n        // Set pixel values for image data\n        const scalars = new Uint8Array(100 * 100);\n        for (let i = 0; i < 100 * 100; i++) {\n            scalars[i] = Math.random() * 255;\n        }\n        imageData.getPointData().setScalars(vtk.Common.Core.vtkDataArray.newInstance({ values: scalars, numberOfComponents: 1 }));\n\n        // Create mapper and actor\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(imageData);\n\n        const actor = vtkImageSlice.newInstance();\n        actor.setMapper(mapper);\n\n        // Add actor to renderer\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\n\nExample 3 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):\nDescription: Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.\n\nModules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const imageActorI = vtkImageSlice.newInstance();\n        const imageActorJ = vtkImageSlice.newInstance();\n        const imageActorK = vtkImageSlice.newInstance();\n\n        renderer.addActor(imageActorK);\n        renderer.addActor(imageActorJ);\n        renderer.addActor(imageActorI);\n\n        const reader = vtkHttpDataSetReader.newInstance({\n            fetchGzip: true,\n        });\n        reader\n            .setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData();\n                const dataRange = data.getPointData().getScalars().getRange();\n                const extent = data.getExtent();\n\n                const imageMapperK = vtkImageMapper.newInstance();\n                imageMapperK.setInputData(data);\n                imageMapperK.setKSlice(30);\n                imageActorK.setMapper(imageMapperK);\n\n                const imageMapperJ = vtkImageMapper.newInstance();\n                imageMapperJ.setInputData(data);\n                imageMapperJ.setJSlice(30);\n                imageActorJ.setMapper(imageMapperJ);\n\n                const imageMapperI = vtkImageMapper.newInstance();\n                imageMapperI.setInputData(data);\n                imageMapperI.setISlice(30);\n                imageActorI.setMapper(imageMapperI);\n\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):\nDescription: Displays a synthetic 2D image generated by `vtkRTAnalyticSource` using `vtkImageMapper` and `vtkImageSlice`.\nModules: vtk.Common.DataModel.vtkImageData, vtk.Filters.Sources.vtkRTAnalyticSource, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n\n        // create render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        const vtkImgSource = vtk.Filters.Sources.vtkRTAnalyticSource;\n        const imgSource = vtkImgSource.newInstance();\n        imgSource.update();\n        const img = imgSource.getOutputData();\n\n        // set mapper and actor\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(img);\n\n        const actor = vtkImageSlice.newInstance();\n        actor.setMapper(mapper);\n\n        // adding actor to render\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 5 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):\nDescription: Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.\n\nModules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js Isosurface Visualization</title>\n    <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\">\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <!-- Set vtk.js favicon -->\n    <script type=\"module\" src=\"https://unpkg.com/vtk.js/favicon.js\"></script>\n\n    <!-- Load WebGL and WebGPU rendering modules -->\n    <script type=\"module\" src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Volume.js\"></script>\n\n    <!-- Force DataAccessHelper to access various data sources -->\n    <script type=\"module\"\n        src=\"https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper.js\"></script>\n    <script type=\"module\"\n        src=\"https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper.js\"></script>\n    <script type=\"module\"\n        src=\"https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js\"></script>\n\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const path = 'http://kitware.github.io/vtk-js/data'\n\n        // Reference HTML template\n        const controlPanel = `<table>\n    <tr>\n        <td>Slice I</td>\n        <td>\n            <input class='sliceI' type=\"range\" min=\"0\" max=\"2.0\" step=\"1\" value=\"1\" />\n        </td>\n    </tr>\n    <tr>\n        <td>Slice J</td>\n        <td>\n            <input class='sliceJ' type=\"range\" min=\"0\" max=\"2.0\" step=\"1\" value=\"1\" />\n        </td>\n    </tr>\n    <tr>\n        <td>Slice K</td>\n        <td>\n            <input class='sliceK' type=\"range\" min=\"0\" max=\"100\" step=\"1\" value=\"1\" />\n        </td>\n    </tr>\n    <tr>\n        <td>Color level</td>\n        <td>\n            <input class='colorLevel' type=\"range\" min=\"-3926\" max=\"3926\" step=\"1\" value=\"1\" />\n        </td>\n    </tr>\n    <tr>\n        <td>ColorWindow</td>\n        <td>\n            <input class='colorWindow' type=\"range\" min=\"0\" max=\"3926\" step=\"1\" value=\"1\" />\n        </td>\n    </tr>\n</table>\n`;\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n        fullScreenRenderWindow.addController(controlPanel);\n\n        const imageActorI = vtkImageSlice.newInstance();\n        const imageActorJ = vtkImageSlice.newInstance();\n        const imageActorK = vtkImageSlice.newInstance();\n\n        renderer.addActor(imageActorK);\n        renderer.addActor(imageActorJ);\n        renderer.addActor(imageActorI);\n\n        function updateColorLevel(e) {\n            const colorLevel = Number(\n                (e ? e.target : document.querySelector('.colorLevel')).value\n            );\n            imageActorI.getProperty().setColorLevel(colorLevel);\n            imageActorJ.getProperty().setColorLevel(colorLevel);\n            imageActorK.getProperty().setColorLevel(colorLevel);\n            renderWindow.render();\n        }\n\n        function updateColorWindow(e) {\n            const colorLevel = Number(\n                (e ? e.target : document.querySelector('.colorWindow')).value\n            );\n            imageActorI.getProperty().setColorWindow(colorLevel);\n            imageActorJ.getProperty().setColorWindow(colorLevel);\n            imageActorK.getProperty().setColorWindow(colorLevel);\n            renderWindow.render();\n        }\n\n        const reader = vtkHttpDataSetReader.newInstance({\n            fetchGzip: true,\n        });\n        reader\n            .setUrl(`${path}/data/volume/headsq.vti`, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData();\n                const dataRange = data.getPointData().getScalars().getRange();\n                const extent = data.getExtent();\n\n                const imageMapperK = vtkImageMapper.newInstance();\n                imageMapperK.setInputData(data);\n                imageMapperK.setKSlice(30);\n                imageActorK.setMapper(imageMapperK);\n\n                const imageMapperJ = vtkImageMapper.newInstance();\n                imageMapperJ.setInputData(data);\n                imageMapperJ.setJSlice(30);\n                imageActorJ.setMapper(imageMapperJ);\n\n                const imageMapperI = vtkImageMapper.newInstance();\n                imageMapperI.setInputData(data);\n                imageMapperI.setISlice(30);\n                imageActorI.setMapper(imageMapperI);\n\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n\n                ['.sliceI', '.sliceJ', '.sliceK'].forEach((selector, idx) => {\n                    const el = document.querySelector(selector);\n                    el.setAttribute('min', extent[idx * 2 + 0]);\n                    el.setAttribute('max', extent[idx * 2 + 1]);\n                    el.setAttribute('value', 30);\n                });\n\n                ['.colorLevel', '.colorWindow'].forEach((selector) => {\n                    document.querySelector(selector).setAttribute('max', dataRange[1]);\n                    document.querySelector(selector).setAttribute('value', dataRange[1]);\n                });\n                document\n                    .querySelector('.colorLevel')\n                    .setAttribute('value', (dataRange[0] + dataRange[1]) / 2);\n                updateColorLevel();\n                updateColorWindow();\n            });\n\n        document.querySelector('.sliceI').addEventListener('input', (e) => {\n            imageActorI.getMapper().setISlice(Number(e.target.value));\n            renderWindow.render();\n        });\n\n        document.querySelector('.sliceJ').addEventListener('input', (e) => {\n            imageActorJ.getMapper().setJSlice(Number(e.target.value));\n            renderWindow.render();\n        });\n\n        document.querySelector('.sliceK').addEventListener('input', (e) => {\n            imageActorK.getMapper().setKSlice(Number(e.target.value));\n            renderWindow.render();\n        });\n\n        document\n            .querySelector('.colorLevel')\n            .addEventListener('input', updateColorLevel);\n        document\n            .querySelector('.colorWindow')\n            .addEventListener('input', updateColorWindow);\n\n        window.fullScreen = fullScreenRenderWindow;\n        window.imageActorI = imageActorI;\n        window.imageActorJ = imageActorJ;\n        window.imageActorK = imageActorK;\n\n    </script>\n</body>\n\n</html>\n\n",
    "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
    "generator": "claude-sonnet-4",
    "evaluator": "qwen3-max",
    "score": null,
    "workflow": {
      "inquiryExpansion": true,
      "rag": true
    },
    "eval_id": "1765339732",
    "eval_user": "test",
    "export_time": null,
    "console_output": null,
    "eval_time": "2025-12-10 12:08:52",
    "evaluator_evaluation": {
      "score": "0.87",
      "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.85</Score>\n        <Reason>The generated code implements most of the visualization pipeline correctly: it loads the VTI data, sets 'Pressure' as active scalars, slices along Y at ~95%, applies a blue-white-red color map, and adds an orientation widget. However, it omits the opacity transfer function (uses constant opacity instead of a piecewise function), and uses setJSlice() instead of setSlicingMode(1) + setSlice(), which may behave differently depending on vtk.js version.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.8</Score>\n        <Reason>The color mapping is slightly different: ground truth uses dark blue (0,0,0.8) and dark red (0.8,0,0), while generated uses pure blue (0,0,1) and pure red (1,0,0). The background is dark gray ([0.1,0.1,0.1]) instead of white ([1,1,1]). Also, the orientation marker uses a custom viewport [0.8,0.0,1.0,0.2] rather than the standard BOTTOM_RIGHT corner with setViewportSize(0.15), potentially affecting appearance and placement.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.95</Score>\n        <Reason>The code is well-structured, readable, and includes detailed comments, error handling, and logging. It uses modern async/await and modular logic. Variable names are clear, and best practices like explicit scalar activation and range computation are followed. Minor deduction for not using vtkFullScreenRenderWindow’s built-in URL loading (which simplifies code) but this is acceptable.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.87</OverallScore>\n        <Critique>The generated code is highly maintainable and mostly functionally equivalent but differs in visual details and omits the piecewise opacity function, reducing fidelity to the ground truth.</Critique>\n    </Summary>\n</Evaluation>",
      "parsed_evaluation": {
        "dimensions": {
          "Functionality": {
            "score": 0.85,
            "reason": "The generated code implements most of the visualization pipeline correctly: it loads the VTI data, sets 'Pressure' as active scalars, slices along Y at ~95%, applies a blue-white-red color map, and adds an orientation widget. However, it omits the opacity transfer function (uses constant opacity instead of a piecewise function), and uses setJSlice() instead of setSlicingMode(1) + setSlice(), which may behave differently depending on vtk.js version."
          },
          "VisualQuality": {
            "score": 0.8,
            "reason": "The color mapping is slightly different: ground truth uses dark blue (0,0,0.8) and dark red (0.8,0,0), while generated uses pure blue (0,0,1) and pure red (1,0,0). The background is dark gray ([0.1,0.1,0.1]) instead of white ([1,1,1]). Also, the orientation marker uses a custom viewport [0.8,0.0,1.0,0.2] rather than the standard BOTTOM_RIGHT corner with setViewportSize(0.15), potentially affecting appearance and placement."
          },
          "CodeQuality": {
            "score": 0.95,
            "reason": "The code is well-structured, readable, and includes detailed comments, error handling, and logging. It uses modern async/await and modular logic. Variable names are clear, and best practices like explicit scalar activation and range computation are followed. Minor deduction for not using vtkFullScreenRenderWindow’s built-in URL loading (which simplifies code) but this is acceptable."
          }
        },
        "overall": 0.87,
        "critique": "The generated code is highly maintainable and mostly functionally equivalent but differs in visual details and omits the piecewise opacity function, reducing fidelity to the ground truth.",
        "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.85</Score>\n        <Reason>The generated code implements most of the visualization pipeline correctly: it loads the VTI data, sets 'Pressure' as active scalars, slices along Y at ~95%, applies a blue-white-red color map, and adds an orientation widget. However, it omits the opacity transfer function (uses constant opacity instead of a piecewise function), and uses setJSlice() instead of setSlicingMode(1) + setSlice(), which may behave differently depending on vtk.js version.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.8</Score>\n        <Reason>The color mapping is slightly different: ground truth uses dark blue (0,0,0.8) and dark red (0.8,0,0), while generated uses pure blue (0,0,1) and pure red (1,0,0). The background is dark gray ([0.1,0.1,0.1]) instead of white ([1,1,1]). Also, the orientation marker uses a custom viewport [0.8,0.0,1.0,0.2] rather than the standard BOTTOM_RIGHT corner with setViewportSize(0.15), potentially affecting appearance and placement.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.95</Score>\n        <Reason>The code is well-structured, readable, and includes detailed comments, error handling, and logging. It uses modern async/await and modular logic. Variable names are clear, and best practices like explicit scalar activation and range computation are followed. Minor deduction for not using vtkFullScreenRenderWindow’s built-in URL loading (which simplifies code) but this is acceptable.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.87</OverallScore>\n        <Critique>The generated code is highly maintainable and mostly functionally equivalent but differs in visual details and omits the piecewise opacity function, reducing fidelity to the ground truth.</Critique>\n    </Summary>\n</Evaluation>"
      }
    },
    "options": null,
    "analysis": [
      {
        "phase": "Data Loading",
        "step_name": "Load Rotor Dataset",
        "vtk_modules": [
          "vtkXMLImageDataReader"
        ],
        "description": "Load the rotor dataset from 'http://127.0.0.1:5000/dataset/rotor.vti' using vtkXMLImageDataReader."
      },
      {
        "phase": "Data Processing",
        "step_name": "Set Scalar and Slice",
        "vtk_modules": [
          "vtkImageSlice"
        ],
        "description": "Set the active scalar array to 'Pressure'. Compute the Y-axis slice index corresponding to 95% depth of the dataset extent and apply a slice at that index using vtkImageSlice."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Configure Color Map",
        "vtk_modules": [
          "vtkColorTransferFunction",
          "vtkImageMapper"
        ],
        "description": "Create a blue → white → red color transfer function for the 'Pressure' scalar range (min to max). Configure vtkImageMapper with this color map and set opacity to fully opaque."
      },
      {
        "phase": "UI Configuration",
        "step_name": "Add Orientation Marker",
        "vtk_modules": [
          "vtkOrientationMarkerWidget",
          "vtkAxesActor"
        ],
        "description": "Add an orientation marker with XYZ axes using vtkAxesActor and vtkOrientationMarkerWidget, positioned in the bottom-right corner."
      },
      {
        "phase": "Rendering & Interaction",
        "step_name": "Render Visualization",
        "vtk_modules": [
          "vtkRenderWindow",
          "vtkRenderer",
          "vtkRenderWindowInteractor"
        ],
        "description": "Set up the renderer, render window, and interactor to display the sliced image with the configured color map and orientation widget."
      }
    ],
    "retrieval_results": [
      {
        "id": 144015752,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageLabelOutline\\code.html",
        "description": "Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkImageMapper",
          "vtkImageSlice"
        ]
      },
      {
        "id": 1985908936,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageSlice\\code.html",
        "description": "Generates and displays a 2D random image (100x100) using `vtkImageSlice` and `vtkImageMapper`.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkImageMapper",
          "vtkImageSlice"
        ]
      },
      {
        "id": 739470138,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-MultiImageSlice\\code.html",
        "description": "Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkImageMapper",
          "vtkImageSlice"
        ]
      },
      {
        "id": 38476787,
        "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-Image2D\\code.html",
        "description": "Displays a synthetic 2D image generated by `vtkRTAnalyticSource` using `vtkImageMapper` and `vtkImageSlice`.",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkImageMapper",
          "vtkImageSlice"
        ]
      },
      {
        "id": 1338339492,
        "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-MultiSliceImageMapper\\code.html",
        "description": "Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkImageMapper",
          "vtkImageSlice"
        ]
      }
    ]
  },
  {
    "path": "",
    "name": "",
    "prompt": "Generate an HTML page using vtk.js to visualize the Deepwater dataset with isosurface rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/deepwater.vti_x000d_\n_x000d_\nCompute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar_x000d_\n_x000d_\nGenerate an isosurface at the mid-value of the scalar range_x000d_\n_x000d_\nUse a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nSet the isosurface to fully opaque with smooth shading_x000d_\n_x000d_\nAdd an XYZ orientation marker in the bottom-right corner",
    "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>Isosurface Rendering for Deepwater Dataset</title>_x000d_\n<style>_x000d_\nbody,_x000d_\nhtml {_x000d_\nmargin: 0;_x000d_\npadding: 0;_x000d_\nwidth: 100%;_x000d_\nheight: 100%;_x000d_\noverflow: hidden;_x000d_\n}_x000d_\n_x000d_\n#renderer {_x000d_\nwidth: 100%;_x000d_\nheight: 100%;_x000d_\n}_x000d_\n</style>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<div id=\"renderer\"></div>_x000d_\n<script src=\"https://unpkg.com/vtk.js\"></script>_x000d_\n<script>_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkActor = vtk.Rendering.Core.vtkActor;_x000d_\nconst vtkMapper = vtk.Rendering.Core.vtkMapper;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\nconst vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;_x000d_\n_x000d_\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [1,1,1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\nreader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {_x000d_\nreader.loadData().then(() => {_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\n_x000d_\n// Output array names in the dataset to help with debugging_x000d_\n// Fix: getArrayNames is not a function, use getArrays() to get the array list_x000d_\nconst arrays = imageData.getPointData().getArrays();_x000d_\nconst arrayNames = arrays.map(array => array.getName());_x000d_\nconsole.log('Arrays in dataset:', arrayNames);_x000d_\n_x000d_\n// Use v02 and v03 arrays to calculate velocity magnitude_x000d_\nconst v02Array = imageData.getPointData().getArrayByName('v02');_x000d_\nconst v03Array = imageData.getPointData().getArrayByName('v03');_x000d_\n_x000d_\nif (!v02Array || !v03Array) {_x000d_\nconsole.error('Cannot find v02 or v03 arrays');_x000d_\n// Try to use another available array_x000d_\nconst availableArray = imageData.getPointData().getArrayByName('prs');_x000d_\nif (availableArray) {_x000d_\n// Directly use pressure (prs) array as scalar field_x000d_\nimageData.getPointData().setActiveScalars('prs');_x000d_\n} else {_x000d_\nconsole.error('Unable to find suitable array for rendering');_x000d_\nreturn;_x000d_\n}_x000d_\n} else {_x000d_\n// Calculate velocity magnitude_x000d_\nconst numPoints = imageData.getNumberOfPoints();_x000d_\nconst magnitudeData = new Float64Array(numPoints);_x000d_\n_x000d_\nfor (let i = 0; i < numPoints; i++) {_x000d_\n// v02 and v03 are scalar arrays, directly get values_x000d_\nconst v2 = v02Array.getData()[i];_x000d_\nconst v3 = v03Array.getData()[i];_x000d_\n// Calculate velocity magnitude_x000d_\nmagnitudeData[i] = Math.sqrt(v2 * v2 + v3 * v3);_x000d_\n}_x000d_\n_x000d_\n// Create velocity magnitude array_x000d_\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;_x000d_\nconst magnitudeVtkArray = vtkDataArray.newInstance({_x000d_\nnumberOfComponents: 1,_x000d_\nvalues: magnitudeData,_x000d_\nname: 'velocityMagnitude',_x000d_\n});_x000d_\nimageData.getPointData().addArray(magnitudeVtkArray);_x000d_\nimageData.getPointData().setActiveScalars('velocityMagnitude');_x000d_\n}_x000d_\n_x000d_\n// Get range of current active scalar_x000d_\nconst activeScalars = imageData.getPointData().getScalars();_x000d_\nconst newRange = activeScalars.getRange();_x000d_\nconst [minV, maxV] = newRange;_x000d_\n_x000d_\nconsole.log('Using scalar field:', activeScalars.getName());_x000d_\nconsole.log('Data range:', newRange);_x000d_\n_x000d_\nconst marchingCube = vtkImageMarchingCubes.newInstance({_x000d_\ncontourValue: minV + 0.5 * (maxV - minV),_x000d_\ncomputeNormals: true,_x000d_\nmergePoints: true_x000d_\n});_x000d_\n_x000d_\nmarchingCube.setInputData(imageData);_x000d_\n_x000d_\nconst mapper = vtkMapper.newInstance();_x000d_\nmapper.setInputConnection(marchingCube.getOutputPort());_x000d_\n_x000d_\nconst colorTransferFunction = vtkColorTransferFunction.newInstance();_x000d_\ncolorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);_x000d_\ncolorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);_x000d_\n_x000d_\nmapper.setLookupTable(colorTransferFunction);_x000d_\nmapper.setScalarRange(minV, maxV);_x000d_\nmapper.setInterpolateScalarsBeforeMapping(true);_x000d_\n_x000d_\nconst actor = vtkActor.newInstance();_x000d_\nactor.setMapper(mapper);_x000d_\nactor.getProperty().setRepresentationToSurface();_x000d_\nactor.getProperty().setEdgeVisibility(false);_x000d_\nactor.getProperty().setOpacity(1.0);_x000d_\nactor.getProperty().setAmbient(0.3);_x000d_\nactor.getProperty().setDiffuse(0.7);_x000d_\nactor.getProperty().setSpecular(0.4);_x000d_\n_x000d_\nrenderer.addActor(actor);_x000d_\n_x000d_\nconst bounds = imageData.getBounds();_x000d_\nconst center = [_x000d_\n(bounds[0] + bounds[1]) / 2,_x000d_\n(bounds[2] + bounds[3]) / 2,_x000d_\n(bounds[4] + bounds[5]) / 2,_x000d_\n];_x000d_\n_x000d_\nconst camera = renderer.getActiveCamera();_x000d_\ncamera.setFocalPoint(...center);_x000d_\ncamera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);_x000d_\ncamera.setViewUp(0, 0, 1);_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderWindow.render();_x000d_\nrenderer.resetCamera();_x000d_\nrenderWindow.render();_x000d_\n_x000d_\nconst axes = vtk.Rendering.Core.vtkAxesActor.newInstance();_x000d_\nconst widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({_x000d_\nactor: axes,_x000d_\ninteractor: renderWindow.getInteractor(),_x000d_\n});_x000d_\nwidget.setEnabled(true);_x000d_\nwidget.setViewportCorner(_x000d_\nvtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT_x000d_\n);_x000d_\nwidget.setViewportSize(0.15);_x000d_\nwidget.setMinPixelSize(100);_x000d_\nwidget.setMaxPixelSize(300);_x000d_\n_x000d_\nconst interactor = renderWindow.getInteractor();_x000d_\ninteractor.start();_x000d_\n});_x000d_\n});_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
    "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Deepwater Dataset Isosurface Visualization</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            font-family: Arial, sans-serif;\n        }\n        #renderWindowContainer {\n            width: 100vw;\n            height: 100vh;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderWindowContainer\"></div>\n    \n    <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n    <script>\n        // VTK.js module imports\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n        const vtkAnnotatedCubeActor = vtk.Rendering.Core.vtkAnnotatedCubeActor;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n\n        // Setup full screen render window\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n            container: document.getElementById('renderWindowContainer')\n        });\n        const renderer = fullScreenRenderWindow.getRenderer();\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n        // Create data reader for VTI format - Using vtkXMLImageDataReader for .vti files\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // Load dataset from specified URL: http://127.0.0.1:5000/dataset/deepwater.vti\n        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {\n            console.log('Dataset loaded successfully');\n            \n            // Get the loaded image data\n            const imageData = reader.getOutputData();\n            const pointData = imageData.getPointData();\n            \n            // Compute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar\n            const calculator = vtkCalculator.newInstance();\n            \n            // Check if v02 and v03 arrays are available for velocity magnitude calculation\n            const v02Array = pointData.getArrayByName('v02');\n            const v03Array = pointData.getArrayByName('v03');\n            const prsArray = pointData.getArrayByName('prs');\n            \n            let scalarArrayName;\n            \n            if (v02Array && v03Array) {\n                console.log('Computing velocity magnitude from v02 and v03 arrays');\n                // Calculate velocity magnitude: sqrt(v02^2 + v03^2)\n                calculator.setFormulaSimple(\n                    FieldDataTypes.POINT,\n                    ['v02', 'v03'],\n                    'velocity_magnitude',\n                    (v02, v03) => Math.sqrt(v02*v02 + v03*v03)\n                );\n                calculator.setInputData(imageData);\n                scalarArrayName = 'velocity_magnitude';\n            } else if (prsArray) {\n                console.log('Using pressure (prs) array as scalar field');\n                // Use pressure array directly\n                calculator.setInputData(imageData);\n                scalarArrayName = 'prs';\n            } else {\n                console.error('No suitable scalar arrays found (v02, v03, or prs)');\n                return;\n            }\n\n            // Get scalar data range for isosurface generation and color mapping\n            const scalarData = calculator.getOutputData();\n            const scalars = scalarData.getPointData().getArrayByName(scalarArrayName) || \n                           scalarData.getPointData().getArrayByName('prs');\n            \n            if (!scalars) {\n                console.error('Could not find scalar array for visualization');\n                return;\n            }\n\n            const scalarRange = scalars.getRange();\n            console.log(`Scalar range: [${scalarRange[0]}, ${scalarRange[1]}]`);\n\n            // Generate an isosurface at the mid-value of the scalar range\n            const midValue = (scalarRange[0] + scalarRange[1]) / 2.0;\n            console.log(`Generating isosurface at mid-value: ${midValue}`);\n\n            const marchingCubes = vtkImageMarchingCubes.newInstance({\n                contourValue: midValue,\n                computeNormals: true, // Enable smooth shading\n                mergePoints: true\n            });\n\n            // Connect pipeline\n            marchingCubes.setInputConnection(calculator.getOutputPort());\n\n            // Create mapper and actor for isosurface rendering\n            const mapper = vtkMapper.newInstance({\n                interpolateScalarsBeforeMapping: true // Enable smooth shading\n            });\n            mapper.setInputConnection(marchingCubes.getOutputPort());\n\n            // Use a blue → white → red color map spanning the scalar range (min to max)\n            const colorTransferFunction = vtkColorTransferFunction.newInstance();\n            colorTransferFunction.addRGBPoint(scalarRange[0], 0.0, 0.0, 1.0); // Blue at minimum\n            colorTransferFunction.addRGBPoint((scalarRange[0] + scalarRange[1]) / 2.0, 1.0, 1.0, 1.0); // White at middle\n            colorTransferFunction.addRGBPoint(scalarRange[1], 1.0, 0.0, 0.0); // Red at maximum\n\n            mapper.setLookupTable(colorTransferFunction);\n            mapper.setColorByArrayName(scalarArrayName);\n            mapper.setScalarRange(scalarRange[0], scalarRange[1]);\n            mapper.setScalarModeToUsePointFieldData();\n\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n\n            // Set the isosurface to fully opaque with smooth shading\n            const property = actor.getProperty();\n            property.setOpacity(1.0); // Fully opaque\n            property.setInterpolationToPhong(); // Smooth shading\n            property.setAmbient(0.2);\n            property.setDiffuse(0.8);\n            property.setSpecular(0.2);\n            property.setSpecularPower(20);\n\n            // Add actor to renderer\n            renderer.addActor(actor);\n\n            // Add an XYZ orientation marker in the bottom-right corner\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor: vtkAnnotatedCubeActor.newInstance(),\n                interactor: renderWindow.getInteractor()\n            });\n            orientationWidget.setEnabled(true);\n            orientationWidget.setViewportCorner(\n                vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n            );\n            orientationWidget.setViewportSize(0.15); // 15% of viewport size\n            orientationWidget.setMinPixelSize(100);\n            orientationWidget.setMaxPixelSize(300);\n\n            // Setup cube faces with XYZ labels\n            const cube = orientationWidget.getActor();\n            cube.setXPlusFaceText('+X');\n            cube.setXMinusFaceText('-X');\n            cube.setYPlusFaceText('+Y');\n            cube.setYMinusFaceText('-Y');\n            cube.setZPlusFaceText('+Z');\n            cube.setZMinusFaceText('-Z');\n\n            // Reset camera and render\n            renderer.resetCamera();\n            renderWindow.render();\n\n            console.log('Deepwater dataset visualization completed successfully');\n\n        }).catch((error) => {\n            console.error('Error loading dataset:', error);\n            // Display error message to user\n            document.body.innerHTML = `\n                <div style=\"display: flex; justify-content: center; align-items: center; height: 100vh; font-size: 18px; color: red;\">\n                    Error loading dataset: ${error.message}<br>\n                    Please ensure the server is running at http://127.0.0.1:5000\n                </div>\n            `;\n        });\n    </script>\n</body>\n</html>\n```",
    "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
    "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Deepwater dataset with isosurface rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/deepwater.vti_x000d_\n_x000d_\nCompute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar_x000d_\n_x000d_\nGenerate an isosurface at the mid-value of the scalar range_x000d_\n_x000d_\nUse a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nSet the isosurface to fully opaque with smooth shading_x000d_\n_x000d_\nAdd an XYZ orientation marker in the bottom-right corner\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 5.00, Matches: vtkCalculator):\nDescription: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n\nModules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // using vtk namespace\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints = vtk.Common.Core.vtkPoints;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // setting vtkCalculator and set formula\n\n        const simpleFilter = vtkCalculator.newInstance();\n\n        simpleFilter.setFormulaSimple(\n            FieldDataTypes.POINT, // Generate an output array defined over points.\n            [], // We don't request any point-data arrays because point coordinates are made available by default.\n            'outputArray', // Name the output array \n            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125\n        ); \n\n        //using plane source to generate a poly data which can be rendered by vtkActor\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n        const sourceData = planeSource.getOutputData();\n\n        simpleFilter.setInputData(sourceData);\n        const planeActor = vtkActor.newInstance();\n        const planeMapper = vtkMapper.newInstance();\n        planeMapper.setInputData(simpleFilter.getOutputData());\n        planeMapper.setColorByArrayName('outputArray'); \n\n        planeMapper.setScalarModeToUsePointFieldData();   \n        planeActor.setMapper(planeMapper);\n        planeActor.getProperty().setEdgeVisibility(true);\n\n        renderer.addActor(planeActor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 2 (Score: 5.00, Matches: vtkCalculator):\nDescription: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageLabelOutline</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Use the vtk namespace to reference each class\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        // Use the vtk namespace to reference constants\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.5, 0.5, 0.5],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const BACKGROUND = 0;\n        const LOW_VALUE = 80;\n        const HIGH_VALUE = 160;\n\n        const FIRST_SEGMENT = 1;\n        const SECOND_SEGMENT = 5;\n\n        /**\n         * Creates a labelmap image with the same dimensions as the background volume.\n         * @param {vtkImageData} backgroundImageData - The background volume data.\n         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.\n         */\n        function createLabelmap(backgroundImageData) {\n            // Create a labelmap image the same dimensions as our background volume.\n            const labelMapData = vtkImageData.newInstance(\n                backgroundImageData.get('spacing', 'origin', 'direction')\n            );\n\n            labelMapData.computeTransforms();\n\n            const dataArray = vtkDataArray.newInstance({\n                numberOfComponents: 1,\n                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),\n            });\n            labelMapData.getPointData().setScalars(dataArray);\n\n            labelMapData.setDimensions(...backgroundImageData.getDimensions());\n            labelMapData.setSpacing(...backgroundImageData.getSpacing());\n            labelMapData.setOrigin(...backgroundImageData.getOrigin());\n            labelMapData.setDirection(...backgroundImageData.getDirection());\n            const mapper = vtkImageMapper.newInstance();\n            mapper.setInputData(labelMapData);\n\n            const actor = vtkImageSlice.newInstance();\n\n            actor.setMapper(mapper);\n\n            const labelMap = {\n                actor,\n                mapper,\n                imageData: labelMapData,\n                cfun: vtkColorTransferFunction.newInstance(),\n                ofun: vtkPiecewiseFunction.newInstance(),\n            };\n\n            // Labelmap pipeline\n            labelMap.mapper.setInputData(labelMapData);\n            labelMap.actor.setMapper(labelMap.mapper);\n\n            // Set up labelMap color and opacity mapping\n            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label \"5\" will be green\n            labelMap.ofun.addPoint(0, 0);\n            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.\n            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.\n\n            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);\n            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);\n            labelMap.actor.getProperty().setInterpolationTypeToNearest();\n\n            labelMap.actor.getProperty().setUseLabelOutline(true);\n            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4\n            // (positioned at array index 4)\n            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);\n            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);\n\n            // This is very important to make sure the labelmap is rendered\n            // correctly\n            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);\n\n            const dims = labelMap.imageData.getDimensions();\n            const values = labelMap.imageData.getPointData().getScalars().getData();\n\n            const backgroundValues = backgroundImageData\n                .getPointData()\n                .getScalars()\n                .getData();\n            const size = dims[0] * dims[1] * dims[2];\n\n            for (let i = 0; i < size; i++) {\n                if (backgroundValues[i] === LOW_VALUE) {\n                    values[i] = FIRST_SEGMENT;\n                } else if (backgroundValues[i] === HIGH_VALUE) {\n                    values[i] = SECOND_SEGMENT;\n                }\n            }\n\n            labelMap.imageData.getPointData().getScalars().setData(values);\n\n            return labelMap;\n        }\n\n        // Create a one slice vtkImageData that has four quadrants of different values\n        const imageData = vtkImageData.newInstance();\n        const dims = [10, 10, 1];\n        imageData.setSpacing(1, 1, 1);\n        imageData.setOrigin(0.1, 0.1, 0.1);\n        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);\n\n        imageData.computeTransforms();\n\n        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);\n\n        let i = 0;\n        for (let y = 0; y < dims[1]; y++) {\n            for (let x = 0; x < dims[0]; x++, i++) {\n                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {\n                    values[i] = BACKGROUND;\n                } else if (x > 4 && x < 6 && y > 4 && y < 7) {\n                    values[i] = LOW_VALUE;\n                } else {\n                    values[i] = HIGH_VALUE;\n                }\n            }\n        }\n\n        const dataArray = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values,\n        });\n        imageData.getPointData().setScalars(dataArray);\n        imageData.modified();\n\n        const data = imageData;\n        const labelMap = createLabelmap(data);\n\n        const actor = vtkImageSlice.newInstance();\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(data);\n        actor.setMapper(mapper);\n        actor.getProperty().setInterpolationTypeToNearest();\n\n        renderer.addActor(actor);\n        renderer.addActor(labelMap.actor);\n        renderer.resetCamera();\n        renderer.resetCameraClippingRange();\n        renderWindow.render();\n\n        window.fullScreen = fullScreenRenderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 3 (Score: 5.00, Matches: vtkCalculator):\nDescription: Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n\n        console.log(planeSource.getOutputData().toJSON());\n\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                // array in is null here?\n                console.log(\"arraysIn:\", arraysIn());\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars\n        // so the plane mapper will color by 'temperature':\n        simpleFilter.setInputData(planeSource.getOutputData());\n        simpleFilter.update();\n        concole.log(simpleFilter.getOutputData());\n\n        //mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        //mapper.setOrientationArray('orientation');\n        //mapper.setScaleArray('pressure');\n\n        //actor.setMapper(mapper);\n\n       // renderer.addActor(actor);\n       // renderer.resetCamera();\n        //renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        // fullScreenRenderer.addController(controlPanel);\n        // ['xResolution', 'yResolution'].forEach((propertyName) => {\n        //     document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n        //         const value = Number(e.target.value);\n        //         console.log(\"propertyName\",propertyName);\n        //         console.log(\"value\",value);\n        //         planeSource.set({ [propertyName]: value });\n        //         renderWindow.render();\n        //     });\n        // });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 5.00, Matches: vtkCalculator):\nDescription: Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkConeSource, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkGlyph3DMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtkjs- Rendering-GlyphMapper</title>\n</head>\n\n\n\n<body>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Assuming vtk object is properly imported and available in global environment, proceed with corresponding assignments\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;\n        const vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkGlyph3DMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data...\n                        name: 'pressure', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        numberOfComponents: 3, //... with this many components...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data...\n                        name: 'temperature', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        attribute: AttributeTypes.SCALARS, //... and will be marked as the default scalars.\n                        numberOfComponents: 1, //... with this many components...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [press, temp] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    press[i * 3] = (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5);\n                    press[i * 3 + 1] =\n                        ((coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) + 0.125) * 0.1;\n                    press[i * 3 + 2] =\n                        ((coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                            (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) +\n                            0.125) *\n                        0.1;\n                    temp[i] = coords[3 * i + 1] * 0.1;\n                }\n\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n\n        // console.log(\"planeSource\", planeSource.getOutputPort)\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort(), 0);\n\n        const coneSource = vtkConeSource.newInstance();\n        coneSource.setResolution(12);\n        mapper.setInputConnection(coneSource.getOutputPort(), 1);\n        mapper.setOrientationArray('pressure');\n        mapper.setScalarRange(0.0, 0.1);\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n    </script>\n\n</body>\n\n</html>\n\nExample 5 (Score: 5.00, Matches: vtkCalculator):\nDescription: Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js StickMapper</title>\n    <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\">\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Geometry\"></script>\n    <script src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Molecule\"></script>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        mapper.setOrientationArray('orientation');\n        mapper.setScaleArray('pressure');\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 6 (Score: 5.00, Matches: vtkImageMarchingCubes):\nDescription: Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.\nModules: vtk.Common.DataModel.vtkSphere, vtk.Filters.General.vtkImageMarchingCubes, vtk.Imaging.Hybrid.vtkSampleFunction, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js@32.6.0/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        const mCubes = vtkImageMarchingCubes.newInstance({ contourValue: 0.1 });\n        \n        //using the sphere function and sample function to create the source code\n        const vtkSphere = vtk.Common.DataModel.vtkSphere;\n        const vtkSampleFunction = vtk.Imaging.Hybrid.vtkSampleFunction;\n        const sphere = vtkSphere.newInstance({ center: [0.0, 0.0, 0.0], radius: 0.5 });\n        const sample = vtkSampleFunction.newInstance({\n            implicitFunction: sphere,\n            sampleDimensions: [50, 50, 50],\n            modelBounds: [-0.5, 0.5, -0.5, 0.5, -0.5, 0.5],\n        });\n\n        //connecting actor with render\n        const actor = vtkActor.newInstance();\n        renderer.addActor(actor);\n        \n        //connecting mapper with actor\n        const mapper = vtkMapper.newInstance();\n        actor.setMapper(mapper);\n\n        // Connect the pipeline proper\n        mCubes.setInputConnection(sample.getOutputPort());\n        mapper.setInputConnection(mCubes.getOutputPort());\n\n        renderer.resetCamera();\n        renderWindow.render();\n\n    </script>\n</body>\n\n</html>\n\n",
    "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
    "generator": "claude-sonnet-4",
    "evaluator": "qwen3-max",
    "score": null,
    "workflow": {
      "inquiryExpansion": true,
      "rag": true
    },
    "eval_id": "1765339784",
    "eval_user": "test",
    "export_time": null,
    "console_output": null,
    "eval_time": "2025-12-10 12:09:44",
    "evaluator_evaluation": {
      "score": "0.9",
      "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.9</Score>\n        <Reason>The generated code implements a similar pipeline using vtkCalculator to compute velocity magnitude, which is a valid and cleaner approach than manual array creation. It correctly handles fallback to 'prs' if v02/v03 are missing. However, it omits the explicit debug logging of all array names and uses a slightly different pipeline structure (vtkCalculator vs manual array). The core functionality—isosurface generation, coloring, camera setup—is preserved.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.85</Score>\n        <Reason>The color transfer function uses only 3 control points (blue-white-red) instead of 5 as in the ground truth, potentially reducing gradient smoothness. The background is dark gray ([0.1,0.1,0.1]) instead of white ([1,1,1]), altering overall appearance. Camera positioning logic is omitted (uses resetCamera() instead of custom position/focal point), which may result in a different initial view. Shading parameters differ slightly but maintain smooth appearance.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.95</Score>\n        <Reason>The generated code is well-structured, uses modern vtk.js patterns (e.g., vtkCalculator), includes error handling with user feedback, and has clear comments. Variable names are descriptive. The use of vtkAnnotatedCubeActor improves orientation widget clarity over basic axes. Minor deduction for not replicating exact camera setup, but overall highly maintainable.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.9</OverallScore>\n        <Critique>The generated code achieves equivalent scientific visualization goals with improved modularity and error handling, though with minor visual differences in color mapping, background, and camera framing.</Critique>\n    </Summary>\n</Evaluation>",
      "parsed_evaluation": {
        "dimensions": {
          "Functionality": {
            "score": 0.9,
            "reason": "The generated code implements a similar pipeline using vtkCalculator to compute velocity magnitude, which is a valid and cleaner approach than manual array creation. It correctly handles fallback to 'prs' if v02/v03 are missing. However, it omits the explicit debug logging of all array names and uses a slightly different pipeline structure (vtkCalculator vs manual array). The core functionality—isosurface generation, coloring, camera setup—is preserved."
          },
          "VisualQuality": {
            "score": 0.85,
            "reason": "The color transfer function uses only 3 control points (blue-white-red) instead of 5 as in the ground truth, potentially reducing gradient smoothness. The background is dark gray ([0.1,0.1,0.1]) instead of white ([1,1,1]), altering overall appearance. Camera positioning logic is omitted (uses resetCamera() instead of custom position/focal point), which may result in a different initial view. Shading parameters differ slightly but maintain smooth appearance."
          },
          "CodeQuality": {
            "score": 0.95,
            "reason": "The generated code is well-structured, uses modern vtk.js patterns (e.g., vtkCalculator), includes error handling with user feedback, and has clear comments. Variable names are descriptive. The use of vtkAnnotatedCubeActor improves orientation widget clarity over basic axes. Minor deduction for not replicating exact camera setup, but overall highly maintainable."
          }
        },
        "overall": 0.9,
        "critique": "The generated code achieves equivalent scientific visualization goals with improved modularity and error handling, though with minor visual differences in color mapping, background, and camera framing.",
        "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.9</Score>\n        <Reason>The generated code implements a similar pipeline using vtkCalculator to compute velocity magnitude, which is a valid and cleaner approach than manual array creation. It correctly handles fallback to 'prs' if v02/v03 are missing. However, it omits the explicit debug logging of all array names and uses a slightly different pipeline structure (vtkCalculator vs manual array). The core functionality—isosurface generation, coloring, camera setup—is preserved.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.85</Score>\n        <Reason>The color transfer function uses only 3 control points (blue-white-red) instead of 5 as in the ground truth, potentially reducing gradient smoothness. The background is dark gray ([0.1,0.1,0.1]) instead of white ([1,1,1]), altering overall appearance. Camera positioning logic is omitted (uses resetCamera() instead of custom position/focal point), which may result in a different initial view. Shading parameters differ slightly but maintain smooth appearance.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.95</Score>\n        <Reason>The generated code is well-structured, uses modern vtk.js patterns (e.g., vtkCalculator), includes error handling with user feedback, and has clear comments. Variable names are descriptive. The use of vtkAnnotatedCubeActor improves orientation widget clarity over basic axes. Minor deduction for not replicating exact camera setup, but overall highly maintainable.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.9</OverallScore>\n        <Critique>The generated code achieves equivalent scientific visualization goals with improved modularity and error handling, though with minor visual differences in color mapping, background, and camera framing.</Critique>\n    </Summary>\n</Evaluation>"
      }
    },
    "options": null,
    "analysis": [
      {
        "phase": "Data Loading",
        "step_name": "Load Deepwater Dataset",
        "vtk_modules": [
          "vtkXMLImageDataReader"
        ],
        "description": "Load the dataset from 'http://127.0.0.1:5000/dataset/deepwater.vti' using vtkXMLImageDataReader."
      },
      {
        "phase": "Data Processing",
        "step_name": "Compute Velocity Magnitude",
        "vtk_modules": [
          "vtkCalculator"
        ],
        "description": "Use vtkCalculator to compute the velocity magnitude as sqrt(v02^2 + v03^2). If arrays v02 or v03 are not present, fall back to using the 'prs' array as the scalar."
      },
      {
        "phase": "Data Processing",
        "step_name": "Generate Isosurface",
        "vtk_modules": [
          "vtkImageMarchingCubes"
        ],
        "description": "Use vtkImageMarchingCubes to generate an isosurface at the mid-value of the scalar range of the computed magnitude or 'prs' array."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Apply Color Map",
        "vtk_modules": [
          "vtkColorTransferFunction",
          "vtkMapper"
        ],
        "description": "Create a blue → white → red color transfer function spanning the full scalar range (min to max) and apply it to the isosurface mapper."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Configure Surface Appearance",
        "vtk_modules": [
          "vtkProperty"
        ],
        "description": "Set the isosurface actor's property to be fully opaque with smooth shading enabled."
      },
      {
        "phase": "UI Configuration",
        "step_name": "Add Orientation Marker",
        "vtk_modules": [
          "vtkOrientationMarkerWidget",
          "vtkAxesActor"
        ],
        "description": "Add an XYZ orientation marker (axes actor) in the bottom-right corner of the render window using vtkOrientationMarkerWidget."
      },
      {
        "phase": "Rendering & Interaction",
        "step_name": "Render Scene",
        "vtk_modules": [
          "vtkRenderWindow",
          "vtkRenderer",
          "vtkRenderWindowInteractor"
        ],
        "description": "Initialize the render window, renderer, and interactor to display the isosurface visualization with the configured color map and orientation marker."
      }
    ],
    "retrieval_results": [
      {
        "id": 1276004285,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-Calculator\\code.html",
        "description": "This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 144015752,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageLabelOutline\\code.html",
        "description": "Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 771311485,
        "title": "data\\vtkjs-examples\\prompt-sample\\IO-StickMapper\\code.html",
        "description": "Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 105009849,
        "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-GlyphMapper\\code.html",
        "description": "Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 1837944411,
        "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-StickMapper\\code.html",
        "description": "Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom poin",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 875726136,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageMarchingCubes\\code.html",
        "description": "Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkImageMarchingCubes"
        ]
      }
    ]
  },
  {
    "path": "",
    "name": "",
    "prompt": "Generate an HTML page using vtk.js to visualize the Isabel dataset with streamline rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/isabel.vti_x000d_\n_x000d_\nUse the \"Velocity\" array as the vector field for streamlines_x000d_\n_x000d_\nGenerate seed points at the center of the dataset with sufficient density to cover the domain_x000d_\n_x000d_\nCompute streamlines following the velocity field_x000d_\n_x000d_\nRender streamlines in cyan ([0, 1, 1]) with a specified line width_x000d_\n_x000d_\nRender a dataset outline in red ([1, 0, 0]) with a specified line width",
    "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>Isosurface Rendering for Isabel Dataset</title>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<!-- Renderer container -->_x000d_\n<div id=\"renderer\"></div>_x000d_\n<!-- Load VTK.js library -->_x000d_\n<script src=\"https://unpkg.com/vtk.js\"></script>_x000d_\n<script>_x000d_\n// Import required VTK.js classes_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkActor = vtk.Rendering.Core.vtkActor;_x000d_\nconst vtkMapper = vtk.Rendering.Core.vtkMapper;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\nconst vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;_x000d_\n_x000d_\n// Initialize render window, set background color to black_x000d_\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [0.1, 0.1, 0.1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\n// Create XML image data reader instance_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\n_x000d_\n// Set data file URL and load data_x000d_\nreader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\isabel.vti').then(() => {_x000d_\n// After data URL is set successfully, load data_x000d_\nreader.loadData().then(() => {_x000d_\n// Get loaded image data_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\n_x000d_\n// Get velocity vector field from data_x000d_\nconst velocityArray = imageData.getPointData().getArrayByName('Velocity');_x000d_\n// Get total number of data points_x000d_\nconst numPoints = imageData.getNumberOfPoints();_x000d_\n// Create new array to store velocity magnitude_x000d_\nconst magnitudeData = new Float64Array(numPoints);_x000d_\n_x000d_\n// Calculate velocity magnitude (norm of velocity vector) for each point_x000d_\nfor (let i = 0; i < numPoints; i++) {_x000d_\n// Get three components of velocity_x000d_\nconst vx = velocityArray.getData()[3 * i + 0]; // x component_x000d_\nconst vy = velocityArray.getData()[3 * i + 1]; // y component_x000d_\nconst vz = velocityArray.getData()[3 * i + 2]; // z component_x000d_\n// Calculate velocity magnitude (Euclidean norm)_x000d_\nmagnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);_x000d_\n}_x000d_\n_x000d_\n// Create VTK data array class_x000d_\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;_x000d_\n// Create VTK array for velocity magnitude_x000d_\nconst magnitudeVtkArray = vtkDataArray.newInstance({_x000d_\nnumberOfComponents: 1, // Scalar data, only one component_x000d_\nvalues: magnitudeData, // Data values_x000d_\nname: 'velocityMagnitude', // Array name_x000d_\n});_x000d_\nimageData.getPointData().addArray(magnitudeVtkArray);_x000d_\n_x000d_\nimageData.getPointData().setActiveScalars('velocityMagnitude');_x000d_\nimageData.setSpacing(2.5, 2.5, 1.0);_x000d_\n_x000d_\nconst newRange = magnitudeVtkArray.getRange();_x000d_\nconsole.log('Velocity magnitude range:', newRange);_x000d_\nconst [minV, maxV] = newRange;_x000d_\n_x000d_\nconst marchingCube = vtkImageMarchingCubes.newInstance({_x000d_\ncontourValue: minV + 0.5 * (maxV - minV), // Set isosurface value to middle of data range_x000d_\ncomputeNormals: true, // Compute normals for lighting effects_x000d_\nmergePoints: true // Merge duplicate points to reduce data size_x000d_\n});_x000d_\n_x000d_\nmarchingCube.setInputData(imageData);_x000d_\n_x000d_\nconst mapper = vtkMapper.newInstance();_x000d_\nmapper.setInputConnection(marchingCube.getOutputPort());_x000d_\n_x000d_\nconst actor = vtkActor.newInstance();_x000d_\nactor.setMapper(mapper);_x000d_\nrenderer.addActor(actor);_x000d_\nconst camera = renderer.getActiveCamera();_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderer.resetCamera();_x000d_\nrenderWindow.render();_x000d_\n});_x000d_\n});_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
    "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel Dataset Streamline Visualization</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            font-family: Arial, sans-serif;\n        }\n        #container {\n            width: 100vw;\n            height: 100vh;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    \n    <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n    <script>\n        // VTK.js modules\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline;\n        const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkHttpDataAccessHelper = vtk.IO.Core.DataAccessHelper.get('http');\n\n        // Initialize full screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n            container: document.getElementById('container')\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // REQUIREMENT: Load the Isabel dataset from specified URL using vtkXMLImageDataReader\n        const reader = vtkXMLImageDataReader.newInstance();\n        \n        // Download and load the Isabel dataset\n        vtkHttpDataAccessHelper.fetchBinary('http://127.0.0.1:5000/dataset/isabel.vti').then((binary) => {\n            reader.parseAsArrayBuffer(binary);\n            \n            const imageData = reader.getOutputData();\n            \n            // REQUIREMENT: Use \"Velocity\" array as the vector field for streamlines\n            const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n            if (velocityArray) {\n                imageData.getPointData().setVectors(velocityArray);\n            }\n\n            // Get dataset bounds for seed point generation\n            const bounds = imageData.getBounds();\n            const center = [\n                (bounds[0] + bounds[1]) / 2,\n                (bounds[2] + bounds[3]) / 2,\n                (bounds[4] + bounds[5]) / 2\n            ];\n            const extent = [\n                bounds[1] - bounds[0],\n                bounds[3] - bounds[2],\n                bounds[5] - bounds[4]\n            ];\n\n            // REQUIREMENT: Generate seed points at the center of the dataset with sufficient density\n            const seedPlane = vtkPlaneSource.newInstance();\n            // Position the plane at the center of the dataset\n            const seedSize = Math.min(extent[0], extent[1], extent[2]) * 0.8; // 80% of smallest dimension\n            const halfSeed = seedSize / 2;\n            \n            seedPlane.setOrigin(\n                center[0] - halfSeed,\n                center[1] - halfSeed, \n                center[2]\n            );\n            seedPlane.setPoint1(\n                center[0] + halfSeed,\n                center[1] - halfSeed,\n                center[2]\n            );\n            seedPlane.setPoint2(\n                center[0] - halfSeed,\n                center[1] + halfSeed,\n                center[2]\n            );\n            // Set sufficient density to cover the domain\n            seedPlane.setXResolution(20);\n            seedPlane.setYResolution(20);\n\n            // REQUIREMENT: Compute streamlines following the velocity field\n            const streamline = vtkImageStreamline.newInstance();\n            streamline.setInputData(imageData);\n            streamline.setInputConnection(seedPlane.getOutputPort(), 1);\n            streamline.setIntegrationStep(0.01);\n            streamline.setMaximumNumberOfSteps(1000);\n            streamline.setTerminalSpeed(1e-12);\n\n            // Create mapper and actor for streamlines\n            const streamlineMapper = vtkMapper.newInstance();\n            streamlineMapper.setInputConnection(streamline.getOutputPort());\n            \n            const streamlineActor = vtkActor.newInstance();\n            streamlineActor.setMapper(streamlineMapper);\n            \n            // REQUIREMENT: Render streamlines in cyan ([0, 1, 1]) with specified line width\n            streamlineActor.getProperty().setColor(0, 1, 1); // Cyan color\n            streamlineActor.getProperty().setLineWidth(2); // Specified line width\n\n            // REQUIREMENT: Render dataset outline in red ([1, 0, 0]) with specified line width\n            const outlineFilter = vtkOutlineFilter.newInstance();\n            outlineFilter.setInputData(imageData);\n            \n            const outlineMapper = vtkMapper.newInstance();\n            outlineMapper.setInputConnection(outlineFilter.getOutputPort());\n            \n            const outlineActor = vtkActor.newInstance();\n            outlineActor.setMapper(outlineMapper);\n            outlineActor.getProperty().setColor(1, 0, 0); // Red color\n            outlineActor.getProperty().setLineWidth(3); // Specified line width\n\n            // Add actors to renderer\n            renderer.addActor(streamlineActor);\n            renderer.addActor(outlineActor);\n\n            // Reset camera and render\n            renderer.resetCamera();\n            renderWindow.render();\n\n            console.log('Isabel dataset visualization complete');\n            console.log('- Dataset loaded from: http://127.0.0.1:5000/dataset/isabel.vti');\n            console.log('- Using Velocity array for streamlines');\n            console.log('- Seed points generated at dataset center with 20x20 resolution');\n            console.log('- Streamlines rendered in cyan');\n            console.log('- Dataset outline rendered in red');\n\n        }).catch((error) => {\n            console.error('Error loading dataset:', error);\n        });\n\n    </script>\n</body>\n</html>\n```",
    "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
    "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Isabel dataset with streamline rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/isabel.vti_x000d_\n_x000d_\nUse the \"Velocity\" array as the vector field for streamlines_x000d_\n_x000d_\nGenerate seed points at the center of the dataset with sufficient density to cover the domain_x000d_\n_x000d_\nCompute streamlines following the velocity field_x000d_\n_x000d_\nRender streamlines in cyan ([0, 1, 1]) with a specified line width_x000d_\n_x000d_\nRender a dataset outline in red ([1, 0, 0]) with a specified line width\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 10.00, Matches: vtkImageStreamline, vtkOutlineFilter):\nDescription: Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkImageData, vtk.Filters.General.vtkImageStreamline, vtk.Filters.General.vtkOutlineFilter, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.Property, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Core.vtkProperty.Representation, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance, vtk.macro\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageOutlineFilter</title>\n    <!-- <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\"> -->\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n\n    <script type=\"text/javascript\" src=\"https://unpkg.com/@babel/polyfill@7.0.0/dist/polyfill.js\"></script>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        console.log(vtk.Rendering.Core.Property);\n\n        const Representation = vtk.Rendering.Core.vtkProperty.Representation;\n        // const Representation = Constants.representation;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const macro = vtk.macro;\n\n        // Load control panel HTML\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        function addRepresentation(name, filter, props = {}) {\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputConnection(filter.getOutputPort());\n\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n            actor.getProperty().set(props);\n            renderer.addActor(actor);\n\n            window[`${name}Actor`] = actor;\n            window[`${name}Mapper`] = mapper;\n        }\n\n        // ----------------------------------------------------------------------------\n\n        const vecSource = macro.newInstance((publicAPI, model) => {\n            macro.obj(publicAPI, model); // make it an object\n            macro.algo(publicAPI, model, 0, 1); // mixin algorithm code 1 in, 1 out\n            publicAPI.requestData = (inData, outData) => {\n                // implement requestData\n                if (!outData[0]) {\n                    const id = vtkImageData.newInstance();\n                    id.setSpacing(0.1, 0.1, 0.1);\n                    id.setExtent(0, 9, 0, 9, 0, 9);\n                    const dims = [10, 10, 10];\n\n                    const newArray = new Float32Array(3 * dims[0] * dims[1] * dims[2]);\n\n                    let i = 0;\n                    for (let z = 0; z <= 9; z++) {\n                        for (let y = 0; y <= 9; y++) {\n                            for (let x = 0; x <= 9; x++) {\n                                newArray[i++] = 0.1 * x;\n                                const v = 0.1 * y;\n                                newArray[i++] = v * v;\n                                newArray[i++] = 0;\n                            }\n                        }\n                    }\n\n                    const da = vtkDataArray.newInstance({\n                        numberOfComponents: 3,\n                        values: newArray,\n                    });\n                    da.setName('vectors');\n\n                    const cpd = id.getPointData();\n                    cpd.setVectors(da);\n\n                    // Update output\n                    outData[0] = id;\n                }\n            };\n        })();\n\n        const planeSource = vtkPlaneSource.newInstance();\n        planeSource.setOrigin(0.05, 0.05, 0.05);\n        planeSource.setPoint1(0.05, 0.85, 0.05);\n        planeSource.setPoint2(0.05, 0.05, 0.85);\n\n        const sline = vtkImageStreamline.newInstance();\n        sline.setIntegrationStep(0.01);\n        sline.setInputConnection(vecSource.getOutputPort());\n        sline.setInputConnection(planeSource.getOutputPort(), 1);\n\n        const outlineFilter = vtkOutlineFilter.newInstance();\n        outlineFilter.setInputConnection(vecSource.getOutputPort());\n\n        addRepresentation('streamLine', sline, {\n            diffuseColor: [0, 1, 1],\n            lineWidth: 5,\n        });\n        addRepresentation('outline', outlineFilter, {\n            diffuseColor: [1, 0, 0],\n            lineWidth: 3,\n        });\n        addRepresentation('seed', planeSource, {\n            representation: Representation.POINTS,\n            pointSize: 10,\n        });\n\n        // -----------------------------------------------------------\n\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // ----------------------------------------------------------------------------\n        // UI control handling\n        // ----------------------------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.sline = sline;\n        window.outlineFilter = outlineFilter;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n\n    </script>\n\n</body>\n\n</html>\n\n",
    "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
    "generator": "claude-sonnet-4",
    "evaluator": "qwen3-max",
    "score": null,
    "workflow": {
      "inquiryExpansion": true,
      "rag": true
    },
    "eval_id": "1765339848",
    "eval_user": "test",
    "export_time": null,
    "console_output": null,
    "eval_time": "2025-12-10 12:10:48",
    "evaluator_evaluation": {
      "score": "0.26666666666666666",
      "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.0</Score>\n        <Reason>The generated code implements streamline visualization using vtkImageStreamline, while the ground truth implements isosurface rendering using vtkImageMarchingCubes. The core visualization techniques, data processing (magnitude calculation vs vector seeding), and pipeline components are entirely different.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.0</Score>\n        <Reason>The visual outputs are fundamentally different: the ground truth shows a single isosurface of velocity magnitude with lighting/shading, while the generated code shows cyan streamlines with a red outline. Camera setup, coloring approach, and rendered geometry differ completely.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.8</Score>\n        <Reason>The generated code is well-structured, readable, and follows vtk.js best practices with clear variable names and comments. However, it addresses a completely different visualization task than required, making the high code quality irrelevant to the intended functionality.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.26666666666666666</OverallScore>\n        <Critique>The generated code implements streamline visualization instead of the required isosurface rendering, resulting in completely different functionality and visual output despite good code structure.</Critique>\n    </Summary>\n</Evaluation>",
      "parsed_evaluation": {
        "dimensions": {
          "Functionality": {
            "score": 0.0,
            "reason": "The generated code implements streamline visualization using vtkImageStreamline, while the ground truth implements isosurface rendering using vtkImageMarchingCubes. The core visualization techniques, data processing (magnitude calculation vs vector seeding), and pipeline components are entirely different."
          },
          "VisualQuality": {
            "score": 0.0,
            "reason": "The visual outputs are fundamentally different: the ground truth shows a single isosurface of velocity magnitude with lighting/shading, while the generated code shows cyan streamlines with a red outline. Camera setup, coloring approach, and rendered geometry differ completely."
          },
          "CodeQuality": {
            "score": 0.8,
            "reason": "The generated code is well-structured, readable, and follows vtk.js best practices with clear variable names and comments. However, it addresses a completely different visualization task than required, making the high code quality irrelevant to the intended functionality."
          }
        },
        "overall": 0.26666666666666666,
        "critique": "The generated code implements streamline visualization instead of the required isosurface rendering, resulting in completely different functionality and visual output despite good code structure.",
        "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.0</Score>\n        <Reason>The generated code implements streamline visualization using vtkImageStreamline, while the ground truth implements isosurface rendering using vtkImageMarchingCubes. The core visualization techniques, data processing (magnitude calculation vs vector seeding), and pipeline components are entirely different.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.0</Score>\n        <Reason>The visual outputs are fundamentally different: the ground truth shows a single isosurface of velocity magnitude with lighting/shading, while the generated code shows cyan streamlines with a red outline. Camera setup, coloring approach, and rendered geometry differ completely.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.8</Score>\n        <Reason>The generated code is well-structured, readable, and follows vtk.js best practices with clear variable names and comments. However, it addresses a completely different visualization task than required, making the high code quality irrelevant to the intended functionality.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.26666666666666666</OverallScore>\n        <Critique>The generated code implements streamline visualization instead of the required isosurface rendering, resulting in completely different functionality and visual output despite good code structure.</Critique>\n    </Summary>\n</Evaluation>"
      }
    },
    "options": null,
    "analysis": [
      {
        "phase": "Data Loading",
        "step_name": "Load Isabel Dataset",
        "vtk_modules": [
          "vtkXMLImageDataReader"
        ],
        "description": "Load the Isabel dataset from 'http://127.0.0.1:5000/dataset/isabel.vti' using vtkXMLImageDataReader."
      },
      {
        "phase": "Data Processing",
        "step_name": "Generate Seed Points",
        "vtk_modules": [
          "vtkRTAnalyticSource",
          "vtkSampleFunction"
        ],
        "description": "Create a dense set of seed points at the center of the dataset domain to initialize streamlines. Use dataset bounds to position seeds appropriately."
      },
      {
        "phase": "Data Processing",
        "step_name": "Compute Streamlines",
        "vtk_modules": [
          "vtkImageStreamline"
        ],
        "description": "Use the 'Velocity' vector field from the loaded dataset to compute streamlines starting from the generated seed points via vtkImageStreamline."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Streamline Mapper and Actor",
        "vtk_modules": [
          "vtkMapper",
          "vtkActor"
        ],
        "description": "Create a mapper and actor for the computed streamlines. Set streamline color to cyan [0, 1, 1] and configure line width as specified."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Dataset Outline",
        "vtk_modules": [
          "vtkOutlineFilter",
          "vtkMapper",
          "vtkActor"
        ],
        "description": "Generate an outline of the dataset using vtkOutlineFilter. Create a mapper and actor for the outline, color it red [1, 0, 0], and set the line width."
      },
      {
        "phase": "Rendering & Interaction",
        "step_name": "Render Scene",
        "vtk_modules": [
          "vtkRenderWindow",
          "vtkRenderer",
          "vtkRenderWindowInteractor"
        ],
        "description": "Initialize the render window, renderer, and interactor. Add both streamline and outline actors to the renderer and start rendering."
      }
    ],
    "retrieval_results": [
      {
        "id": 1619381550,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageStreamline\\code.html",
        "description": "Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkImageStreamline",
          "vtkOutlineFilter"
        ]
      }
    ]
  },
  {
    "path": "",
    "name": "",
    "prompt": "Generate an HTML page using vtk.js to visualize the Redsea dataset with volume rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/redsea.vti_x000d_\n_x000d_\nCompute velocity magnitude from the \"velocity\" array and set it as the active scalar_x000d_\n_x000d_\nApply volume rendering using a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nApply a piecewise opacity function to control transparency across scalar values_x000d_\n_x000d_\nSet shading, ambient, diffuse, and specular properties for realistic volume appearance_x000d_\n_x000d_\nAdjust the camera to look along +Z and center on the dataset",
    "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>redsea Example</title>_x000d_\n<script src=\"https://unpkg.com/vtk.js\"></script>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<div id=\"renderer\"></div>_x000d_\n<!-- <script src=\"https://unpkg.com/vtk.js\"></script> -->_x000d_\n<script>_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkVolume = vtk.Rendering.Core.vtkVolume;_x000d_\nconst vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;_x000d_\n_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\nconst vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\n_x000d_\n//init the render window_x000d_\nconst fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [1,1,1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\n_x000d_\n// Load dataset_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\n_x000d_\n_x000d_\n// set url and load the data_x000d_\nreader.setUrl('http://127.0.0.1:5000/dataset/redsea.vti').then(() => {_x000d_\nreader.loadData().then(() => {_x000d_\n//prepare dataset_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\n//set active scalar_x000d_\nconst velocityArray = imageData.getPointData().getArrayByName('velocity');_x000d_\nconst numPoints = imageData.getNumberOfPoints();_x000d_\nconst magnitudeData = new Float64Array(numPoints);_x000d_\nfor (let i = 0; i < numPoints; i++) {_x000d_\nconst vx = velocityArray.getData()[3 * i + 0];_x000d_\nconst vy = velocityArray.getData()[3 * i + 1];_x000d_\nconst vz = velocityArray.getData()[3 * i + 2];_x000d_\nmagnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);_x000d_\n}_x000d_\n_x000d_\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;_x000d_\nconst magnitudeVtkArray = vtkDataArray.newInstance({_x000d_\nnumberOfComponents: 1,_x000d_\nvalues: magnitudeData,_x000d_\nname: 'velocityMagnitude',_x000d_\n});_x000d_\nimageData.getPointData().addArray(magnitudeVtkArray);_x000d_\nconsole.log(imageData.toJSON())_x000d_\n_x000d_\n_x000d_\nimageData.getPointData().setActiveScalars('velocityMagnitude');_x000d_\nimageData.setSpacing(0.05, 0.05, 0.1);_x000d_\n_x000d_\nconsole.log('New bounds:', imageData.getBounds());_x000d_\nconsole.log('Dimensions:', imageData.getDimensions());_x000d_\nconsole.log('Spacing:', imageData.getSpacing());_x000d_\n_x000d_\nconst newRange = magnitudeVtkArray.getRange();_x000d_\nconsole.log('velocityMagnitude range:', newRange);_x000d_\nconst [minV, maxV] = newRange;_x000d_\n_x000d_\n_x000d_\nconsole.log(imageData.getPointData().getScalars().getName());_x000d_\n_x000d_\n_x000d_\n//create the mapper and set its property_x000d_\nconst mapper = vtkVolumeMapper.newInstance();_x000d_\n//console.log(data.toJSON())_x000d_\nmapper.setMaximumSamplesPerRay(4000); // or even higher, up to your hardware limits_x000d_\nmapper.setInputData(imageData);_x000d_\nmapper.setSampleDistance(0.1);_x000d_\n_x000d_\n//create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc._x000d_\nconst actor = vtkVolume.newInstance();_x000d_\n_x000d_\n// Move LocalAmbientOcclusion properties to actor's property_x000d_\nactor.getProperty().setLocalAmbientOcclusion(0);_x000d_\nactor.getProperty().setLAOKernelSize(10);_x000d_\nactor.getProperty().setLAOKernelRadius(5);_x000d_\n// Move ComputeNormalFromOpacity to actor's property_x000d_\nactor.getProperty().setComputeNormalFromOpacity(true);_x000d_\n_x000d_\nconst cfun = vtkColorTransferFunction.newInstance();_x000d_\ncfun.addRGBPoint(minV, 0.0, 0.0, 1.0);_x000d_\ncfun.addRGBPoint((minV + maxV) * 0.5, 1.0, 1.0, 1.0);_x000d_\ncfun.addRGBPoint(maxV, 1.0, 0.0, 0.0);_x000d_\nactor.getProperty().setRGBTransferFunction(0, cfun);_x000d_\n_x000d_\nconst ofun = vtkPiecewiseFunction.newInstance();_x000d_\n_x000d_\nofun.addPoint(minV, 0.0);_x000d_\nofun.addPoint(minV + 0.1 * (maxV - minV), 0.05);_x000d_\nofun.addPoint(minV + 0.5 * (maxV - minV), 0.2);_x000d_\nofun.addPoint(maxV, 1.0);_x000d_\n_x000d_\nactor.getProperty().setScalarOpacity(0, ofun);_x000d_\nactor.getProperty().setInterpolationTypeToLinear();_x000d_\n// this variable makes results lighter_x000d_\nactor.getProperty().setScalarOpacityUnitDistance(0, 0.1);_x000d_\nactor.getProperty().setShade(false);_x000d_\nactor.getProperty().setAmbient(0.3);_x000d_\nactor.getProperty().setDiffuse(1);_x000d_\nactor.getProperty().setSpecular(1);_x000d_\n_x000d_\n//assign mapper to actor and assign mapper to render_x000d_\nactor.setMapper(mapper);_x000d_\nrenderer.addVolume(actor);_x000d_\n_x000d_\nconst bounds = imageData.getBounds();_x000d_\nconst center = [_x000d_\n(bounds[0] + bounds[1]) / 2,_x000d_\n(bounds[2] + bounds[3]) / 2,_x000d_\n(bounds[4] + bounds[5]) / 2,_x000d_\n];_x000d_\n_x000d_\nconst camera = renderer.getActiveCamera();_x000d_\ncamera.setFocalPoint(...center);_x000d_\ncamera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z_x000d_\ncamera.setViewUp(0, 1, 0);_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderWindow.render();_x000d_\nrenderer.resetCamera();_x000d_\nrenderWindow.render();_x000d_\n});_x000d_\n});_x000d_\n_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
    "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Redsea Volume Rendering with Velocity Magnitude</title>\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n    <script>\n        // VTK.js module imports for volume rendering with velocity magnitude computation\n        const vtkVolumeActor = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        // Initialize the render window with black background\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // REQUIREMENT: Load the dataset from specified URL using vtkXMLImageDataReader\n        // Using vtkXMLImageDataReader instead of HttpDatasetReader for .vti format\n        const reader = vtkXMLImageDataReader.newInstance();\n        const dataUrl = 'http://127.0.0.1:5000/dataset/redsea.vti';\n\n        // Fetch and load the dataset\n        fetch(dataUrl)\n            .then(response => response.arrayBuffer())\n            .then(buffer => {\n                reader.parseAsArrayBuffer(buffer);\n                const data = reader.getOutputData(0);\n                \n                // REQUIREMENT: Compute velocity magnitude from \"velocity\" array\n                // Set up calculator to compute velocity magnitude: sqrt(vx^2 + vy^2 + vz^2)\n                const calculator = vtkCalculator.newInstance();\n                calculator.setInputData(data);\n                \n                // Formula to compute velocity magnitude from velocity vector components\n                calculator.setFormula({\n                    getArrays: (inputDataSets) => ({\n                        input: [\n                            { location: FieldDataTypes.POINT, name: 'velocity' }\n                        ],\n                        output: [\n                            {\n                                location: FieldDataTypes.POINT,\n                                name: 'velocityMagnitude',\n                                dataType: 'Float32Array',\n                                numberOfComponents: 1,\n                            }\n                        ],\n                    }),\n                    evaluate: (arraysIn, arraysOut) => {\n                        const [velocity] = arraysIn.map((d) => d.getData());\n                        const [magnitude] = arraysOut.map((d) => d.getData());\n                        \n                        // Compute magnitude for each point: sqrt(vx^2 + vy^2 + vz^2)\n                        for (let i = 0, sz = velocity.length / 3; i < sz; ++i) {\n                            const vx = velocity[i * 3];\n                            const vy = velocity[i * 3 + 1];\n                            const vz = velocity[i * 3 + 2];\n                            magnitude[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                        }\n                        \n                        arraysOut.forEach((x) => x.modified());\n                    },\n                });\n                \n                calculator.update();\n                const processedData = calculator.getOutputData();\n                \n                // REQUIREMENT: Set velocity magnitude as active scalar\n                processedData.getPointData().setActiveScalars('velocityMagnitude');\n                \n                // Get scalar range for color mapping\n                const scalarArray = processedData.getPointData().getScalars();\n                const scalarRange = scalarArray.getRange();\n                console.log('Velocity magnitude range:', scalarRange);\n\n                // REQUIREMENT: Apply blue → white → red color map spanning scalar range\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(scalarRange[0], 0.0, 0.0, 1.0); // Blue at minimum\n                colorTransferFunction.addRGBPoint((scalarRange[0] + scalarRange[1]) / 2, 1.0, 1.0, 1.0); // White at middle\n                colorTransferFunction.addRGBPoint(scalarRange[1], 1.0, 0.0, 0.0); // Red at maximum\n\n                // REQUIREMENT: Apply piecewise opacity function for transparency control\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(scalarRange[0], 0.0); // Transparent at minimum\n                opacityFunction.addPoint(scalarRange[0] + (scalarRange[1] - scalarRange[0]) * 0.1, 0.1); // Low opacity for low values\n                opacityFunction.addPoint(scalarRange[0] + (scalarRange[1] - scalarRange[0]) * 0.5, 0.5); // Medium opacity at middle\n                opacityFunction.addPoint(scalarRange[1], 1.0); // Opaque at maximum\n\n                // Create volume mapper and set properties\n                const mapper = vtkVolumeMapper.newInstance();\n                mapper.setInputData(processedData);\n                mapper.setSampleDistance(0.7); // Good quality sampling\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n\n                // Create volume actor and configure properties\n                const actor = vtkVolumeActor.newInstance();\n                \n                // REQUIREMENT: Set shading, ambient, diffuse, and specular properties\n                const property = actor.getProperty();\n                property.setRGBTransferFunction(0, colorTransferFunction);\n                property.setScalarOpacity(0, opacityFunction);\n                property.setInterpolationTypeToLinear();\n                \n                // Shading properties for realistic volume appearance\n                property.setShade(true); // Enable shading\n                property.setAmbient(0.2); // Ambient lighting contribution\n                property.setDiffuse(0.7); // Diffuse lighting contribution  \n                property.setSpecular(0.3); // Specular lighting contribution\n                property.setSpecularPower(20); // Specular power for shininess\n\n                // Optional: Enable gradient opacity for enhanced visualization\n                property.setUseGradientOpacity(0, true);\n                property.setGradientOpacityMinimumValue(0, 0);\n                property.setGradientOpacityMinimumOpacity(0, 0.0);\n                property.setGradientOpacityMaximumValue(0, (scalarRange[1] - scalarRange[0]) * 0.05);\n                property.setGradientOpacityMaximumOpacity(0, 1.0);\n\n                // Set up the rendering pipeline\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n\n                // REQUIREMENT: Adjust camera to look along +Z and center on dataset\n                const camera = renderer.getActiveCamera();\n                const bounds = processedData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // Position camera to look along +Z axis\n                camera.setPosition(center[0], center[1], center[2] + (bounds[5] - bounds[4]) * 2);\n                camera.setFocalPoint(center[0], center[1], center[2]);\n                camera.setViewUp(0, 1, 0); // Y-axis as up direction\n                \n                // Reset camera to fit the dataset\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n                \n                // Render the scene\n                renderWindow.render();\n                \n                console.log('Redsea dataset loaded and visualized with velocity magnitude volume rendering');\n            })\n            .catch(error => {\n                console.error('Error loading dataset:', error);\n            });\n    </script>\n</body>\n\n</html>\n```",
    "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
    "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Redsea dataset with volume rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/redsea.vti_x000d_\n_x000d_\nCompute velocity magnitude from the \"velocity\" array and set it as the active scalar_x000d_\n_x000d_\nApply volume rendering using a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nApply a piecewise opacity function to control transparency across scalar values_x000d_\n_x000d_\nSet shading, ambient, diffuse, and specular properties for realistic volume appearance_x000d_\n_x000d_\nAdjust the camera to look along +Z and center on the dataset\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 10.00, Matches: vtkVolumeActor, vtkVolumeMapper):\nDescription: Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.\n\nModules: vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Common.DataModel.vtkPlane, vtk.IO.Core.vtkHttpDataSetReader.newInstance, vtk.Rendering.Core.vtkVolume, vtk.Rendering.Core.vtkVolumeMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        //using volume actor and mapper for rendering\n        const vtkVolumeActor = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        //create clip plan\n        const clipPlane = vtkPlane.newInstance();\n        const clipPlaneNormal = [0, 0, 1]\n\n        //set the data path and the reader\n        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';\n        const reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        //load data from dataPath and render the results by actor and mapper\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n                \n                //compute the range of the data set and set clip plan accordingly\n                const extent = data.getExtent();\n                const spacing = data.getSpacing();\n                const sizeX = extent[1] * spacing[0];\n                const sizeY = extent[3] * spacing[1];\n\n                clipPlanePosition = sizeX / 2;\n\n                const clipPlaneOrigin = [\n                    clipPlanePosition * clipPlaneNormal[0],\n                    clipPlanePosition * clipPlaneNormal[1],\n                    clipPlanePosition * clipPlaneNormal[2],\n                ];\n\n                clipPlane.setNormal(clipPlaneNormal);\n                clipPlane.setOrigin(clipPlaneOrigin);\n\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                mapper.addClippingPlane(clipPlane);\n                mapper.setInputData(data);\n                mapper.setSampleDistance(1);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolumeActor.newInstance();\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.1);\n                ofun.addPoint(255.0, 1.0);\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 2.955);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n    </script>\n</body>\n\n</html>\n\nExample 2 (Score: 10.00, Matches: vtkVolumeActor, vtkVolumeMapper):\nDescription: Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.\n\nModules: vtk.Common.DataModel.vtkPiecewiseFunction, vtk.IO.Core.vtkHttpDataSetReader.newInstance, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkVolume, vtk.Rendering.Core.vtkVolumeMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        //using volume actor and mapper for rendering\n        const vtkVolumeActor = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        //set the data path and the reader\n        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';\n        const reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        //load data from dataPath and render the results by actor and mapper\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                console.log(data.toJSON())\n                mapper.setInputData(data);\n                mapper.setSampleDistance(0.7);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolumeActor.newInstance();\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.1);\n                ofun.addPoint(255.0, 1.0);\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 2.955);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n    </script>\n</body>\n\n</html>\n\nExample 3 (Score: 5.00, Matches: vtkCalculator):\nDescription: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n\nModules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // using vtk namespace\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints = vtk.Common.Core.vtkPoints;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // setting vtkCalculator and set formula\n\n        const simpleFilter = vtkCalculator.newInstance();\n\n        simpleFilter.setFormulaSimple(\n            FieldDataTypes.POINT, // Generate an output array defined over points.\n            [], // We don't request any point-data arrays because point coordinates are made available by default.\n            'outputArray', // Name the output array \n            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125\n        ); \n\n        //using plane source to generate a poly data which can be rendered by vtkActor\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n        const sourceData = planeSource.getOutputData();\n\n        simpleFilter.setInputData(sourceData);\n        const planeActor = vtkActor.newInstance();\n        const planeMapper = vtkMapper.newInstance();\n        planeMapper.setInputData(simpleFilter.getOutputData());\n        planeMapper.setColorByArrayName('outputArray'); \n\n        planeMapper.setScalarModeToUsePointFieldData();   \n        planeActor.setMapper(planeMapper);\n        planeActor.getProperty().setEdgeVisibility(true);\n\n        renderer.addActor(planeActor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 5.00, Matches: vtkCalculator):\nDescription: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageLabelOutline</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Use the vtk namespace to reference each class\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        // Use the vtk namespace to reference constants\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.5, 0.5, 0.5],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const BACKGROUND = 0;\n        const LOW_VALUE = 80;\n        const HIGH_VALUE = 160;\n\n        const FIRST_SEGMENT = 1;\n        const SECOND_SEGMENT = 5;\n\n        /**\n         * Creates a labelmap image with the same dimensions as the background volume.\n         * @param {vtkImageData} backgroundImageData - The background volume data.\n         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.\n         */\n        function createLabelmap(backgroundImageData) {\n            // Create a labelmap image the same dimensions as our background volume.\n            const labelMapData = vtkImageData.newInstance(\n                backgroundImageData.get('spacing', 'origin', 'direction')\n            );\n\n            labelMapData.computeTransforms();\n\n            const dataArray = vtkDataArray.newInstance({\n                numberOfComponents: 1,\n                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),\n            });\n            labelMapData.getPointData().setScalars(dataArray);\n\n            labelMapData.setDimensions(...backgroundImageData.getDimensions());\n            labelMapData.setSpacing(...backgroundImageData.getSpacing());\n            labelMapData.setOrigin(...backgroundImageData.getOrigin());\n            labelMapData.setDirection(...backgroundImageData.getDirection());\n            const mapper = vtkImageMapper.newInstance();\n            mapper.setInputData(labelMapData);\n\n            const actor = vtkImageSlice.newInstance();\n\n            actor.setMapper(mapper);\n\n            const labelMap = {\n                actor,\n                mapper,\n                imageData: labelMapData,\n                cfun: vtkColorTransferFunction.newInstance(),\n                ofun: vtkPiecewiseFunction.newInstance(),\n            };\n\n            // Labelmap pipeline\n            labelMap.mapper.setInputData(labelMapData);\n            labelMap.actor.setMapper(labelMap.mapper);\n\n            // Set up labelMap color and opacity mapping\n            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label \"5\" will be green\n            labelMap.ofun.addPoint(0, 0);\n            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.\n            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.\n\n            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);\n            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);\n            labelMap.actor.getProperty().setInterpolationTypeToNearest();\n\n            labelMap.actor.getProperty().setUseLabelOutline(true);\n            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4\n            // (positioned at array index 4)\n            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);\n            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);\n\n            // This is very important to make sure the labelmap is rendered\n            // correctly\n            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);\n\n            const dims = labelMap.imageData.getDimensions();\n            const values = labelMap.imageData.getPointData().getScalars().getData();\n\n            const backgroundValues = backgroundImageData\n                .getPointData()\n                .getScalars()\n                .getData();\n            const size = dims[0] * dims[1] * dims[2];\n\n            for (let i = 0; i < size; i++) {\n                if (backgroundValues[i] === LOW_VALUE) {\n                    values[i] = FIRST_SEGMENT;\n                } else if (backgroundValues[i] === HIGH_VALUE) {\n                    values[i] = SECOND_SEGMENT;\n                }\n            }\n\n            labelMap.imageData.getPointData().getScalars().setData(values);\n\n            return labelMap;\n        }\n\n        // Create a one slice vtkImageData that has four quadrants of different values\n        const imageData = vtkImageData.newInstance();\n        const dims = [10, 10, 1];\n        imageData.setSpacing(1, 1, 1);\n        imageData.setOrigin(0.1, 0.1, 0.1);\n        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);\n\n        imageData.computeTransforms();\n\n        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);\n\n        let i = 0;\n        for (let y = 0; y < dims[1]; y++) {\n            for (let x = 0; x < dims[0]; x++, i++) {\n                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {\n                    values[i] = BACKGROUND;\n                } else if (x > 4 && x < 6 && y > 4 && y < 7) {\n                    values[i] = LOW_VALUE;\n                } else {\n                    values[i] = HIGH_VALUE;\n                }\n            }\n        }\n\n        const dataArray = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values,\n        });\n        imageData.getPointData().setScalars(dataArray);\n        imageData.modified();\n\n        const data = imageData;\n        const labelMap = createLabelmap(data);\n\n        const actor = vtkImageSlice.newInstance();\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(data);\n        actor.setMapper(mapper);\n        actor.getProperty().setInterpolationTypeToNearest();\n\n        renderer.addActor(actor);\n        renderer.addActor(labelMap.actor);\n        renderer.resetCamera();\n        renderer.resetCameraClippingRange();\n        renderWindow.render();\n\n        window.fullScreen = fullScreenRenderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 5 (Score: 5.00, Matches: vtkCalculator):\nDescription: Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n\n        console.log(planeSource.getOutputData().toJSON());\n\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                // array in is null here?\n                console.log(\"arraysIn:\", arraysIn());\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars\n        // so the plane mapper will color by 'temperature':\n        simpleFilter.setInputData(planeSource.getOutputData());\n        simpleFilter.update();\n        concole.log(simpleFilter.getOutputData());\n\n        //mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        //mapper.setOrientationArray('orientation');\n        //mapper.setScaleArray('pressure');\n\n        //actor.setMapper(mapper);\n\n       // renderer.addActor(actor);\n       // renderer.resetCamera();\n        //renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        // fullScreenRenderer.addController(controlPanel);\n        // ['xResolution', 'yResolution'].forEach((propertyName) => {\n        //     document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n        //         const value = Number(e.target.value);\n        //         console.log(\"propertyName\",propertyName);\n        //         console.log(\"value\",value);\n        //         planeSource.set({ [propertyName]: value });\n        //         renderWindow.render();\n        //     });\n        // });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 6 (Score: 5.00, Matches: vtkCalculator):\nDescription: Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkConeSource, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkGlyph3DMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtkjs- Rendering-GlyphMapper</title>\n</head>\n\n\n\n<body>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Assuming vtk object is properly imported and available in global environment, proceed with corresponding assignments\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;\n        const vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkGlyph3DMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data...\n                        name: 'pressure', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        numberOfComponents: 3, //... with this many components...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data...\n                        name: 'temperature', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        attribute: AttributeTypes.SCALARS, //... and will be marked as the default scalars.\n                        numberOfComponents: 1, //... with this many components...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [press, temp] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    press[i * 3] = (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5);\n                    press[i * 3 + 1] =\n                        ((coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) + 0.125) * 0.1;\n                    press[i * 3 + 2] =\n                        ((coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                            (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) +\n                            0.125) *\n                        0.1;\n                    temp[i] = coords[3 * i + 1] * 0.1;\n                }\n\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n\n        // console.log(\"planeSource\", planeSource.getOutputPort)\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort(), 0);\n\n        const coneSource = vtkConeSource.newInstance();\n        coneSource.setResolution(12);\n        mapper.setInputConnection(coneSource.getOutputPort(), 1);\n        mapper.setOrientationArray('pressure');\n        mapper.setScalarRange(0.0, 0.1);\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n    </script>\n\n</body>\n\n</html>\n\n",
    "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
    "generator": "claude-sonnet-4",
    "evaluator": "qwen3-max",
    "score": null,
    "workflow": {
      "inquiryExpansion": true,
      "rag": true
    },
    "eval_id": "1765339887",
    "eval_user": "test",
    "export_time": null,
    "console_output": null,
    "eval_time": "2025-12-10 12:11:27",
    "evaluator_evaluation": {
      "score": "0.9",
      "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.9</Score>\n        <Reason>The generated code implements the same core pipeline: loading a VTI dataset, computing velocity magnitude, setting it as active scalars, and rendering with volume mapper and actor. It uses vtkCalculator instead of manual array creation, which is valid. However, it omits setting spacing explicitly (ground truth sets imageData.setSpacing(0.05, 0.05, 0.1)), which may affect sampling and visual scale. Also, LAO properties (LAOKernelSize, etc.) are not replicated exactly—instead, LAO is disabled via mapper.setLocalAmbientOcclusion(0), but ground truth configures LAO parameters even if disabled. Minor functional divergence.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.85</Score>\n        <Reason>Color transfer function matches (blue-white-red). Opacity function is similar but uses slightly different control points (e.g., 0.1 vs 0.05 at 10% range). Shading is enabled in generated code (setShade(true)) while ground truth disables it (setShade(false)), leading to potentially different lighting appearance. Background is black ([0,0,0]) vs white ([1,1,1]) in ground truth, affecting contrast. Camera positioning logic is equivalent, so view alignment is preserved.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.95</Score>\n        <Reason>Code is well-structured, uses clear variable names, and leverages vtk.js best practices like vtkCalculator for derived arrays. Comments explain key steps and requirements. Uses modern fetch API instead of reader.setUrl(), which is acceptable and more explicit. Minor inconsistency: imports vtkFullScreenRenderWindow.newInstance but then calls it as a function without .newInstance (though this works due to how vtk.js exports). Overall highly readable and maintainable.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.9</OverallScore>\n        <Critique>The generated code closely replicates the ground truth's functionality and visual intent with minor deviations in shading, background color, opacity curve, and missing explicit spacing, but demonstrates excellent code quality and correct use of vtk.js patterns.</Critique>\n    </Summary>\n</Evaluation>",
      "parsed_evaluation": {
        "dimensions": {
          "Functionality": {
            "score": 0.9,
            "reason": "The generated code implements the same core pipeline: loading a VTI dataset, computing velocity magnitude, setting it as active scalars, and rendering with volume mapper and actor. It uses vtkCalculator instead of manual array creation, which is valid. However, it omits setting spacing explicitly (ground truth sets imageData.setSpacing(0.05, 0.05, 0.1)), which may affect sampling and visual scale. Also, LAO properties (LAOKernelSize, etc.) are not replicated exactly—instead, LAO is disabled via mapper.setLocalAmbientOcclusion(0), but ground truth configures LAO parameters even if disabled. Minor functional divergence."
          },
          "VisualQuality": {
            "score": 0.85,
            "reason": "Color transfer function matches (blue-white-red). Opacity function is similar but uses slightly different control points (e.g., 0.1 vs 0.05 at 10% range). Shading is enabled in generated code (setShade(true)) while ground truth disables it (setShade(false)), leading to potentially different lighting appearance. Background is black ([0,0,0]) vs white ([1,1,1]) in ground truth, affecting contrast. Camera positioning logic is equivalent, so view alignment is preserved."
          },
          "CodeQuality": {
            "score": 0.95,
            "reason": "Code is well-structured, uses clear variable names, and leverages vtk.js best practices like vtkCalculator for derived arrays. Comments explain key steps and requirements. Uses modern fetch API instead of reader.setUrl(), which is acceptable and more explicit. Minor inconsistency: imports vtkFullScreenRenderWindow.newInstance but then calls it as a function without .newInstance (though this works due to how vtk.js exports). Overall highly readable and maintainable."
          }
        },
        "overall": 0.9,
        "critique": "The generated code closely replicates the ground truth's functionality and visual intent with minor deviations in shading, background color, opacity curve, and missing explicit spacing, but demonstrates excellent code quality and correct use of vtk.js patterns.",
        "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.9</Score>\n        <Reason>The generated code implements the same core pipeline: loading a VTI dataset, computing velocity magnitude, setting it as active scalars, and rendering with volume mapper and actor. It uses vtkCalculator instead of manual array creation, which is valid. However, it omits setting spacing explicitly (ground truth sets imageData.setSpacing(0.05, 0.05, 0.1)), which may affect sampling and visual scale. Also, LAO properties (LAOKernelSize, etc.) are not replicated exactly—instead, LAO is disabled via mapper.setLocalAmbientOcclusion(0), but ground truth configures LAO parameters even if disabled. Minor functional divergence.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.85</Score>\n        <Reason>Color transfer function matches (blue-white-red). Opacity function is similar but uses slightly different control points (e.g., 0.1 vs 0.05 at 10% range). Shading is enabled in generated code (setShade(true)) while ground truth disables it (setShade(false)), leading to potentially different lighting appearance. Background is black ([0,0,0]) vs white ([1,1,1]) in ground truth, affecting contrast. Camera positioning logic is equivalent, so view alignment is preserved.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.95</Score>\n        <Reason>Code is well-structured, uses clear variable names, and leverages vtk.js best practices like vtkCalculator for derived arrays. Comments explain key steps and requirements. Uses modern fetch API instead of reader.setUrl(), which is acceptable and more explicit. Minor inconsistency: imports vtkFullScreenRenderWindow.newInstance but then calls it as a function without .newInstance (though this works due to how vtk.js exports). Overall highly readable and maintainable.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.9</OverallScore>\n        <Critique>The generated code closely replicates the ground truth's functionality and visual intent with minor deviations in shading, background color, opacity curve, and missing explicit spacing, but demonstrates excellent code quality and correct use of vtk.js patterns.</Critique>\n    </Summary>\n</Evaluation>"
      }
    },
    "options": null,
    "analysis": [
      {
        "phase": "Data Loading",
        "step_name": "Load Redsea Dataset",
        "vtk_modules": [
          "vtkXMLImageDataReader"
        ],
        "description": "Load the Redsea dataset from 'http://127.0.0.1:5000/dataset/redsea.vti' using vtkXMLImageDataReader."
      },
      {
        "phase": "Data Processing",
        "step_name": "Compute Velocity Magnitude",
        "vtk_modules": [
          "vtkCalculator"
        ],
        "description": "Use vtkCalculator to compute the magnitude of the 'velocity' vector array and set the resulting scalar array as the active scalar for the dataset."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Configure Volume Rendering",
        "vtk_modules": [
          "vtkVolumeMapper",
          "vtkVolumeActor",
          "vtkColorTransferFunction",
          "vtkPiecewiseFunction"
        ],
        "description": "Set up volume rendering with vtkVolumeMapper and vtkVolumeActor. Create a blue → white → red color transfer function spanning the full scalar range of the velocity magnitude. Define a piecewise opacity function to control transparency across scalar values."
      },
      {
        "phase": "Visualization Setup",
        "step_name": "Set Volume Shading Properties",
        "vtk_modules": [
          "vtkVolumeProperty"
        ],
        "description": "Enable shading on the volume property and configure ambient, diffuse, and specular coefficients to achieve a realistic appearance."
      },
      {
        "phase": "Rendering & Interaction",
        "step_name": "Adjust Camera and Render",
        "vtk_modules": [
          "vtkRenderer",
          "vtkRenderWindow",
          "vtkRenderWindowInteractor"
        ],
        "description": "Initialize the renderer, render window, and interactor. Position the camera to look along the +Z axis and center it on the dataset bounds before rendering."
      }
    ],
    "retrieval_results": [
      {
        "id": 895986302,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-VolumeClip\\code.html",
        "description": "Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkVolumeActor",
          "vtkVolumeMapper"
        ]
      },
      {
        "id": 431419998,
        "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-VolumeMapper\\code.html",
        "description": "Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.\n",
        "relevance": 10.0,
        "matched_keywords": [
          "vtkVolumeActor",
          "vtkVolumeMapper"
        ]
      },
      {
        "id": 1276004285,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-Calculator\\code.html",
        "description": "This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 144015752,
        "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageLabelOutline\\code.html",
        "description": "Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 771311485,
        "title": "data\\vtkjs-examples\\prompt-sample\\IO-StickMapper\\code.html",
        "description": "Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      },
      {
        "id": 105009849,
        "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-GlyphMapper\\code.html",
        "description": "Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n",
        "relevance": 5.0,
        "matched_keywords": [
          "vtkCalculator"
        ]
      }
    ]
  }
]