<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VTK Color Preset Switcher</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: sans-serif; }
        #renderer { width: 100%; height: 100%; }
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 8px;
            width: 340px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .control-group { margin-bottom: 12px; border-bottom: 1px solid #eee; padding-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 12px; font-weight: bold; margin-top: 5px;}
        input[type=range] { width: 100%; margin: 5px 0; cursor: pointer; }
        select { width: 100%; padding: 5px; margin-top: 5px; border-radius: 4px; border: 1px solid #ccc; }
        button { width: 100%; padding: 8px; background: #0984e3; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-top: 5px;}
        button:hover { background: #74b9ff; }
        .val { color: #d63031; font-family: monospace; }
        .tip { font-size: 11px; color: #666; margin-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>
    <div id="controls">
        <h3>ğŸ¨ é¢œè‰²ä¸èŒƒå›´æ§åˆ¶</h3>
        
        <!-- 1. é¢„è®¾é€‰æ‹© -->
        <div class="control-group">
            <label>é¢œè‰²é¢„è®¾ (Color Preset):</label>
            <select id="select-preset">
                <option value="Jet">ğŸŒˆ Jet (ç»å…¸å½©è™¹)</option>
                <option value="Viridis">ğŸƒ Viridis (ç§‘å­¦æ¨è)</option>
                <option value="CoolWarm">â„ï¸ğŸ”¥ Cool to Warm (å†·æš–)</option>
                <option value="Gray">âš«âšª Grayscale (é»‘ç™½)</option>
            </select>
        </div>

        <!-- 2. è‡ªåŠ¨èŒƒå›´æŒ‰é’® -->
        <div class="control-group">
            <button id="btn-autoscale">âš¡ è‡ªåŠ¨åŒ¹é…æ•°æ®èŒƒå›´ (ä¿®å¤çº¯è‰²)</button>
            <div class="tip">ç‚¹æ­¤æŒ‰é’®å¯è‡ªåŠ¨å°†æ»‘å—å¯¹é½åˆ°å…¨å±€æœ€å¤§æœ€å°å€¼ã€‚</div>
        </div>

        <!-- 3. æ‰‹åŠ¨å¾®è°ƒ -->
        <label>åˆ‡ç‰‡ä½ç½® (Slice X): <span id="txt-slice" class="val">0</span></label>
        <input type="range" id="slider-slice" step="1">

        <label>é¢œè‰²æœ€å°å€¼ (Low): <span id="txt-min" class="val">0</span></label>
        <input type="range" id="slider-min" step="10">

        <label>é¢œè‰²æœ€å¤§å€¼ (High): <span id="txt-max" class="val">0</span></label>
        <input type="range" id="slider-max" step="10">
    </div>

    <div id="renderer"></div>

    <script src="https://unpkg.com/vtk.js@34.10.0/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const reader = vtkXMLImageDataReader.newInstance();
        // è¯·ç¡®ä¿æ­¤åœ°å€æœ‰æ•ˆï¼Œå¦‚æœæ— æ•ˆè¯·æ›¿æ¢ä¸ºä½ çš„æœ¬åœ°æ–‡ä»¶æˆ– mock æ•°æ®
        reader.setUrl('http://127.0.0.1:5000/dataset/rotor-37-test.vti').then(() => {
            reader.loadData().then(() => {
                const imageData = reader.getOutputData(0);
                imageData.getPointData().setActiveScalars('Pressure');
                
                const dims = imageData.getDimensions();
                const pressureArray = imageData.getPointData().getArrayByName('Pressure');
                const [globalMin, globalMax] = pressureArray.getRange();

                console.log(`Global Range: ${globalMin} - ${globalMax}`);

                // --- UI ---
                const sSlice = document.getElementById('slider-slice');
                const sMin = document.getElementById('slider-min');
                const sMax = document.getElementById('slider-max');
                const tSlice = document.getElementById('txt-slice');
                const tMin = document.getElementById('txt-min');
                const tMax = document.getElementById('txt-max');
                const selPreset = document.getElementById('select-preset');
                const btnAuto = document.getElementById('btn-autoscale');

                // åˆå§‹åŒ–æ»‘å—èŒƒå›´
                sSlice.max = dims[0] - 1; 
                sSlice.value = Math.floor(dims[0] / 2);

                // å…è®¸æ»‘å—æ‹–åŠ¨çš„æé™èŒƒå›´
                sMin.min = globalMin - 1000; sMin.max = globalMax + 1000;
                sMax.min = globalMin - 1000; sMax.max = globalMax + 1000;

                // åˆå§‹æ˜¾ç¤ºèŒƒå›´ (è®¾ä¸ºå…¨å±€èŒƒå›´ï¼Œä¿è¯ä¸€å¼€å§‹æœ‰æ¸å˜)
                sMin.value = globalMin;
                sMax.value = globalMax;

                // --- Actor & Mapper ---
                const imageMapper = vtkImageMapper.newInstance();
                imageMapper.setInputData(imageData);
                imageMapper.setSlicingMode(0); // X Axis
                imageMapper.setSlice(parseInt(sSlice.value));

                const imageSlice = vtkImageSlice.newInstance();
                imageSlice.setMapper(imageMapper);

                // --- æ ¸å¿ƒï¼šé¢„è®¾é¢œè‰²ç”Ÿæˆå™¨ ---
                // vtk.js æ²¡æœ‰å†…ç½®æ‰€æœ‰ JSON é¢„è®¾ï¼Œè¿™é‡Œæ‰‹åŠ¨å®šä¹‰å‡ ç§å¸¸ç”¨æ•°å­¦é€»è¾‘
                function applyPreset(ctf, presetName, min, max) {
                    ctf.removeAllPoints(); // æ¸…é™¤æ—§ç‚¹
                    
                    // ç¡®ä¿èŒƒå›´æ­£ç¡®
                    ctf.setMappingRange(min, max);
                    const diff = max - min;

                    if (presetName === 'Jet') {
                        // ç»å…¸å½©è™¹: è“-é’-ç»¿-é»„-çº¢
                        ctf.addRGBPoint(min, 0.0, 0.0, 1.0); 
                        ctf.addRGBPoint(min + diff * 0.25, 0.0, 1.0, 1.0);
                        ctf.addRGBPoint(min + diff * 0.50, 0.0, 1.0, 0.0);
                        ctf.addRGBPoint(min + diff * 0.75, 1.0, 1.0, 0.0);
                        ctf.addRGBPoint(max, 1.0, 0.0, 0.0);
                    } 
                    else if (presetName === 'Viridis') {
                        // ç°ä»£ç§‘å­¦å¸¸ç”¨ (è‰²ç›²å‹å¥½): æ·±ç´« -> ç»¿ -> é»„
                        ctf.addRGBPoint(min, 0.267, 0.005, 0.329);
                        ctf.addRGBPoint(min + diff * 0.25, 0.229, 0.322, 0.545);
                        ctf.addRGBPoint(min + diff * 0.50, 0.127, 0.567, 0.550);
                        ctf.addRGBPoint(min + diff * 0.75, 0.369, 0.787, 0.383);
                        ctf.addRGBPoint(max, 0.993, 0.906, 0.144);
                    }
                    else if (presetName === 'CoolWarm') {
                        // å†·æš–è‰²: è“ -> ç™½ -> çº¢ (é€‚åˆçœ‹æ­£è´Ÿåå·®)
                        ctf.addRGBPoint(min, 0.23, 0.299, 0.754);
                        ctf.addRGBPoint(min + diff * 0.50, 0.865, 0.865, 0.865); 
                        ctf.addRGBPoint(max, 0.706, 0.016, 0.150);
                    }
                    else if (presetName === 'Gray') {
                        // é»‘ç™½ç°åº¦
                        ctf.addRGBPoint(min, 0.0, 0.0, 0.0);
                        ctf.addRGBPoint(max, 1.0, 1.0, 1.0);
                    }
                }

                function updateRender() {
                    const sliceVal = parseInt(sSlice.value);
                    const minVal = parseFloat(sMin.value);
                    const maxVal = parseFloat(sMax.value);
                    const presetName = selPreset.value;

                    // UIæ–‡å­—æ›´æ–°
                    tSlice.innerText = sliceVal;
                    tMin.innerText = minVal.toFixed(0);
                    tMax.innerText = maxVal.toFixed(0);

                    // 1. è®¾ç½®åˆ‡ç‰‡
                    imageMapper.setSlice(sliceVal);

                    // 2. è®¾ç½®é¢œè‰²è¡¨ (CTF)
                    const ctf = vtkColorTransferFunction.newInstance();
                    // è°ƒç”¨æˆ‘ä»¬è‡ªå®šä¹‰çš„é¢„è®¾å‡½æ•°
                    applyPreset(ctf, presetName, minVal, maxVal);

                    // 3. è®¾ç½®é€æ˜åº¦ (OPF) - è¿‡æ»¤æ‰ 0 å€¼èƒŒæ™¯
                    const opf = vtkPiecewiseFunction.newInstance();
                    opf.addPoint(0, 0.0);
                    opf.addPoint(10, 0.0); // å‡è®¾10ä»¥ä¸‹æ˜¯å™ªéŸ³
                    opf.addPoint(10.1, 1.0);
                    opf.addPoint(globalMax * 1.5, 1.0);

                    imageSlice.getProperty().setRGBTransferFunction(0, ctf);
                    imageSlice.getProperty().setPiecewiseFunction(0, opf);
                    
                    renderWindow.render();
                }

                // --- äº‹ä»¶ç»‘å®š ---
                sSlice.addEventListener('input', updateRender);
                sMin.addEventListener('input', updateRender);
                sMax.addEventListener('input', updateRender);
                selPreset.addEventListener('change', updateRender); // åˆ‡æ¢ä¸‹æ‹‰æ¡†è§¦å‘

                // è‡ªåŠ¨èŒƒå›´æŒ‰é’®é€»è¾‘
                btnAuto.addEventListener('click', () => {
                    // å¼ºåˆ¶è®¾ä¸ºå…¨å±€èŒƒå›´
                    sMin.value = globalMin;
                    sMax.value = globalMax;
                    updateRender();
                });

                renderer.addActor(imageSlice);
                renderer.resetCamera();
                renderer.getActiveCamera().azimuth(90); // ä¾§è§†å›¾
                
                updateRender();
            });
        });
    </script>
</body>
</html>