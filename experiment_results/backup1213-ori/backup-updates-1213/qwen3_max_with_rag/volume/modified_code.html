<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <script src="https://unpkg.com/vtk.js@34.10.0/vtk.js"></script>
    <script>
        // Import required VTK.js modules
        const vtkVolume = vtk.Rendering.Core.vtkVolume;
        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;

        // Create full screen render window
        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderer = fullScreenRenderWindow.getRenderer();
        const renderWindow = fullScreenRenderWindow.getRenderWindow();

        // Set data URL
        const dataURL = 'http://127.0.0.1:5000/dataset/redsea.vti';

        // Create reader for VTI format
        const reader = vtkXMLImageDataReader.newInstance();

        // Load dataset and process
        reader.setUrl(dataURL).then(() => {
            reader.loadData().then(() => {
                const imageData = reader.getOutputData(0);
                
                const velocityArray = imageData.getPointData().getArrayByName('velocity');
                if (!velocityArray) {
                    console.error('Velocity array not found in dataset');
                    return;
                }
                const numPoints = imageData.getNumberOfPoints();
                const magnitudeData = new Float32Array(numPoints);
                const velocity = velocityArray.getData();
                for (let i = 0; i < numPoints; i++) {
                    const vx = velocity[i * 3];
                    const vy = velocity[i * 3 + 1];
                    const vz = velocity[i * 3 + 2];
                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);
                }
                const vtkDataArray = vtk.Common.Core.vtkDataArray;
                const magnitudeVtkArray = vtkDataArray.newInstance({
                    numberOfComponents: 1,
                    values: magnitudeData,
                    name: 'velocity_magnitude',
                });
                imageData.getPointData().addArray(magnitudeVtkArray);
                imageData.getPointData().setActiveScalars('velocity_magnitude');
                
                // Get scalar range for velocity magnitude
                const dataArray = imageData.getPointData().getScalars();
                const range = dataArray.getRange();

            // Create color transfer function (blue → white → red)
            const cfun = vtkColorTransferFunction.newInstance();
            cfun.addRGBPoint(range[0], 0, 0, 1);      // Blue at min
            cfun.addRGBPoint((range[0]+range[1])/2, 1, 1, 1); // White at mid
            cfun.addRGBPoint(range[1], 1, 0, 0);      // Red at max

            // Create piecewise opacity function
            const ofun = vtkPiecewiseFunction.newInstance();
            ofun.addPoint(range[0], 0.0);
            ofun.addPoint(range[1]*0.3, 0.1);
            ofun.addPoint(range[1]*0.6, 0.3);
            ofun.addPoint(range[1], 0.7);

            // Create volume mapper
            const mapper = vtkVolumeMapper.newInstance();
            mapper.setInputData(imageData);
            mapper.setSampleDistance(1.0);

            // Create volume actor
            const actor = vtkVolume.newInstance();
            actor.setMapper(mapper);
            
            // Set volume properties
            const property = actor.getProperty();
            property.setRGBTransferFunction(0, cfun);
            property.setScalarOpacity(0, ofun);
            property.setInterpolationTypeToLinear();
            property.setShade(true);
            property.setAmbient(0.3);
            property.setDiffuse(0.7);
            property.setSpecular(0.3);
            property.setSpecularPower(10.0);

            // Add volume to renderer
            renderer.addVolume(actor);

            const bounds = imageData.getBounds();
            const center = [
                (bounds[0] + bounds[1]) / 2,
                (bounds[2] + bounds[3]) / 2,
                (bounds[4] + bounds[5]) / 2
            ];
            renderer.getActiveCamera().setFocalPoint(...center);
            renderer.getActiveCamera().setPosition(center[0], center[1], center[2] + (bounds[5] - bounds[4]) * 2);
            renderer.getActiveCamera().setViewUp(0, 1, 0);
            renderer.resetCameraClippingRange();
            
            renderWindow.render();
        });
    });
    </script>
</body>
</html>