{
  "path": "",
  "name": "",
  "prompt": "Generate an HTML page using vtk.js to visualize the Deepwater dataset with isosurface rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/deepwater.vti_x000d_\n_x000d_\nCompute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar_x000d_\n_x000d_\nGenerate an isosurface at the mid-value of the scalar range_x000d_\n_x000d_\nUse a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nSet the isosurface to fully opaque with smooth shading_x000d_\n_x000d_\nAdd an XYZ orientation marker in the bottom-right corner",
  "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>Isosurface Rendering for Deepwater Dataset</title>_x000d_\n<style>_x000d_\nbody,_x000d_\nhtml {_x000d_\nmargin: 0;_x000d_\npadding: 0;_x000d_\nwidth: 100%;_x000d_\nheight: 100%;_x000d_\noverflow: hidden;_x000d_\n}_x000d_\n_x000d_\n#renderer {_x000d_\nwidth: 100%;_x000d_\nheight: 100%;_x000d_\n}_x000d_\n</style>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<div id=\"renderer\"></div>_x000d_\n<script src=\"https://unpkg.com/vtk.js\"></script>_x000d_\n<script>_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkActor = vtk.Rendering.Core.vtkActor;_x000d_\nconst vtkMapper = vtk.Rendering.Core.vtkMapper;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\nconst vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;_x000d_\n_x000d_\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [1,1,1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\nreader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {_x000d_\nreader.loadData().then(() => {_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\n_x000d_\n// Output array names in the dataset to help with debugging_x000d_\n// Fix: getArrayNames is not a function, use getArrays() to get the array list_x000d_\nconst arrays = imageData.getPointData().getArrays();_x000d_\nconst arrayNames = arrays.map(array => array.getName());_x000d_\nconsole.log('Arrays in dataset:', arrayNames);_x000d_\n_x000d_\n// Use v02 and v03 arrays to calculate velocity magnitude_x000d_\nconst v02Array = imageData.getPointData().getArrayByName('v02');_x000d_\nconst v03Array = imageData.getPointData().getArrayByName('v03');_x000d_\n_x000d_\nif (!v02Array || !v03Array) {_x000d_\nconsole.error('Cannot find v02 or v03 arrays');_x000d_\n// Try to use another available array_x000d_\nconst availableArray = imageData.getPointData().getArrayByName('prs');_x000d_\nif (availableArray) {_x000d_\n// Directly use pressure (prs) array as scalar field_x000d_\nimageData.getPointData().setActiveScalars('prs');_x000d_\n} else {_x000d_\nconsole.error('Unable to find suitable array for rendering');_x000d_\nreturn;_x000d_\n}_x000d_\n} else {_x000d_\n// Calculate velocity magnitude_x000d_\nconst numPoints = imageData.getNumberOfPoints();_x000d_\nconst magnitudeData = new Float64Array(numPoints);_x000d_\n_x000d_\nfor (let i = 0; i < numPoints; i++) {_x000d_\n// v02 and v03 are scalar arrays, directly get values_x000d_\nconst v2 = v02Array.getData()[i];_x000d_\nconst v3 = v03Array.getData()[i];_x000d_\n// Calculate velocity magnitude_x000d_\nmagnitudeData[i] = Math.sqrt(v2 * v2 + v3 * v3);_x000d_\n}_x000d_\n_x000d_\n// Create velocity magnitude array_x000d_\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;_x000d_\nconst magnitudeVtkArray = vtkDataArray.newInstance({_x000d_\nnumberOfComponents: 1,_x000d_\nvalues: magnitudeData,_x000d_\nname: 'velocityMagnitude',_x000d_\n});_x000d_\nimageData.getPointData().addArray(magnitudeVtkArray);_x000d_\nimageData.getPointData().setActiveScalars('velocityMagnitude');_x000d_\n}_x000d_\n_x000d_\n// Get range of current active scalar_x000d_\nconst activeScalars = imageData.getPointData().getScalars();_x000d_\nconst newRange = activeScalars.getRange();_x000d_\nconst [minV, maxV] = newRange;_x000d_\n_x000d_\nconsole.log('Using scalar field:', activeScalars.getName());_x000d_\nconsole.log('Data range:', newRange);_x000d_\n_x000d_\nconst marchingCube = vtkImageMarchingCubes.newInstance({_x000d_\ncontourValue: minV + 0.5 * (maxV - minV),_x000d_\ncomputeNormals: true,_x000d_\nmergePoints: true_x000d_\n});_x000d_\n_x000d_\nmarchingCube.setInputData(imageData);_x000d_\n_x000d_\nconst mapper = vtkMapper.newInstance();_x000d_\nmapper.setInputConnection(marchingCube.getOutputPort());_x000d_\n_x000d_\nconst colorTransferFunction = vtkColorTransferFunction.newInstance();_x000d_\ncolorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);_x000d_\ncolorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);_x000d_\ncolorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);_x000d_\n_x000d_\nmapper.setLookupTable(colorTransferFunction);_x000d_\nmapper.setScalarRange(minV, maxV);_x000d_\nmapper.setInterpolateScalarsBeforeMapping(true);_x000d_\n_x000d_\nconst actor = vtkActor.newInstance();_x000d_\nactor.setMapper(mapper);_x000d_\nactor.getProperty().setRepresentationToSurface();_x000d_\nactor.getProperty().setEdgeVisibility(false);_x000d_\nactor.getProperty().setOpacity(1.0);_x000d_\nactor.getProperty().setAmbient(0.3);_x000d_\nactor.getProperty().setDiffuse(0.7);_x000d_\nactor.getProperty().setSpecular(0.4);_x000d_\n_x000d_\nrenderer.addActor(actor);_x000d_\n_x000d_\nconst bounds = imageData.getBounds();_x000d_\nconst center = [_x000d_\n(bounds[0] + bounds[1]) / 2,_x000d_\n(bounds[2] + bounds[3]) / 2,_x000d_\n(bounds[4] + bounds[5]) / 2,_x000d_\n];_x000d_\n_x000d_\nconst camera = renderer.getActiveCamera();_x000d_\ncamera.setFocalPoint(...center);_x000d_\ncamera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);_x000d_\ncamera.setViewUp(0, 0, 1);_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderWindow.render();_x000d_\nrenderer.resetCamera();_x000d_\nrenderWindow.render();_x000d_\n_x000d_\nconst axes = vtk.Rendering.Core.vtkAxesActor.newInstance();_x000d_\nconst widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({_x000d_\nactor: axes,_x000d_\ninteractor: renderWindow.getInteractor(),_x000d_\n});_x000d_\nwidget.setEnabled(true);_x000d_\nwidget.setViewportCorner(_x000d_\nvtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT_x000d_\n);_x000d_\nwidget.setViewportSize(0.15);_x000d_\nwidget.setMinPixelSize(100);_x000d_\nwidget.setMaxPixelSize(300);_x000d_\n_x000d_\nconst interactor = renderWindow.getInteractor();_x000d_\ninteractor.start();_x000d_\n});_x000d_\n});_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
  "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Deepwater Isosurface - vtk.js</title>\n  <style>\n    /* Fill the entire window with the renderer (no extra UI controls as requested) */\n    html, body {\n      margin: 0;\n      padding: 0;\n      height: 100%;\n      overflow: hidden;\n      background: #101012;\n    }\n    #container {\n      position: absolute;\n      inset: 0;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <!-- Use vtk.js from CDN as required -->\n  <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n  <script>\n    // ----------------------------------------------------------------------------\n    // Import vtk.js classes from the vtk global (CDN build)\n    // ----------------------------------------------------------------------------\n    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    const vtkActor = vtk.Rendering.Core.vtkActor;\n    const vtkMapper = vtk.Rendering.Core.vtkMapper;\n    const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n    const vtkDataArray = vtk.Common.Core.vtkDataArray;\n    const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader; // Requirement: vti format -> use vtkXMLImageDataReader (not HttpDatasetReader)\n    const vtkContourFilter = vtk.Filters.General.vtkContourFilter;   // To extract isosurface and keep interpolated scalars\n    const vtkPolyDataNormals = vtk.Filters.Core.vtkPolyDataNormals;  // For smooth shading on the isosurface\n    const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;            // Orientation marker axes\n    const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n\n    // ----------------------------------------------------------------------------\n    // Standard renderer setup (no control UI as requested)\n    // ----------------------------------------------------------------------------\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n      background: [0.08, 0.08, 0.1], // Dark background for contrast\n      rootContainer: document.body,\n      containerStyle: { position: 'absolute', inset: '0' }\n    });\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // ----------------------------------------------------------------------------\n    // USER REQUIREMENT: Load the Deepwater dataset (VTI) from the given URL\n    // - Use vtkXMLImageDataReader because data is .vti (and HttpDatasetReader is not supported here)\n    // ----------------------------------------------------------------------------\n    const url = 'http://127.0.0.1:5000/dataset/deepwater.vti';\n    const reader = vtkXMLImageDataReader.newInstance();\n\n    // Helper: Compute velocity magnitude from two 1+ component arrays\n    function computeMagnitudeArray(imageData, arrA, arrB, outName = 'vel_mag') {\n      const pd = imageData.getPointData();\n      const nPts = imageData.getNumberOfPoints();\n      const aData = arrA.getData();\n      const bData = arrB.getData();\n      const aComp = arrA.getNumberOfComponents();\n      const bComp = arrB.getNumberOfComponents();\n\n      const values = new Float32Array(nPts);\n      for (let i = 0; i < nPts; i++) {\n        // Use component 0 for each source array (requirement specifies arrays v02, v03 as sources)\n        const a = aData[i * aComp];\n        const b = bData[i * bComp];\n        values[i] = Math.hypot(a, b); // sqrt(a^2 + b^2)\n      }\n\n      const magArray = vtkDataArray.newInstance({\n        name: outName,\n        numberOfComponents: 1,\n        values\n      });\n      pd.setScalars(magArray);  // Make it the active scalar array for downstream filters\n      imageData.modified();\n      return magArray;\n    }\n\n    // Build the visualization pipeline after the dataset is loaded\n    reader.setUrl(url, { loadData: true }).then(() => {\n      // ----------------------------------------------------------------------------\n      // Access the loaded vtkImageData\n      // ----------------------------------------------------------------------------\n      const imageData = reader.getOutputData();\n\n      // ----------------------------------------------------------------------------\n      // USER REQUIREMENT: Compute velocity magnitude from arrays v02 and v03;\n      // If not available, use 'prs' as the scalar.\n      // ----------------------------------------------------------------------------\n      const pd = imageData.getPointData();\n      const v02 = pd.getArrayByName('v02');\n      const v03 = pd.getArrayByName('v03');\n      let scalarArray = null;\n      let scalarName = null;\n\n      if (v02 && v03) {\n        // Requirement addressed: compute velocity magnitude from v02 and v03\n        scalarArray = computeMagnitudeArray(imageData, v02, v03, 'vel_mag');\n        scalarName = 'vel_mag';\n      } else {\n        // Fallback per requirement: use prs\n        const prs = pd.getArrayByName('prs');\n        if (prs) {\n          pd.setScalars(prs);\n          imageData.modified();\n          scalarArray = prs;\n          scalarName = prs.getName() || 'prs';\n        } else {\n          // If none available (very defensive), try to use any existing scalars\n          scalarArray = pd.getScalars();\n          scalarName = scalarArray ? (scalarArray.getName() || 'scalars') : null;\n          if (!scalarArray) {\n            console.error('No suitable scalar array found (v02/v03 or prs). Aborting.');\n            return;\n          }\n        }\n      }\n\n      // Determine scalar range for isovalue selection and color range\n      const range = scalarArray.getRange(); // [min, max]\n      const minV = range[0];\n      const maxV = range[1];\n      const midV = 0.5 * (minV + maxV);\n\n      // ----------------------------------------------------------------------------\n      // USER REQUIREMENT: Generate an isosurface at the mid-value of the scalar range\n      // - Use vtkContourFilter so interpolated scalars are present on the surface\n      // ----------------------------------------------------------------------------\n      const contour = vtkContourFilter.newInstance();\n      contour.setInputData(imageData);\n      contour.setNumberOfContours(1);\n      contour.setValue(0, midV); // isosurface at mid-value\n\n      // ----------------------------------------------------------------------------\n      // USER REQUIREMENT: Set smooth shading on the isosurface\n      // - Compute normals via vtkPolyDataNormals and set Phong interpolation\n      // ----------------------------------------------------------------------------\n      const normals = vtkPolyDataNormals.newInstance({\n        splitting: false,            // Avoid hard edges unless needed\n        computePointNormals: true,   // Smooth shading requires point normals\n        featureAngle: 60.0\n      });\n      normals.setInputConnection(contour.getOutputPort());\n\n      // ----------------------------------------------------------------------------\n      // USER REQUIREMENT: Apply a blue → white → red color map spanning the scalar range\n      // ----------------------------------------------------------------------------\n      const lut = vtkColorTransferFunction.newInstance();\n      // Map min -> blue, mid -> white, max -> red\n      lut.addRGBPoint(minV, 0.0, 0.0, 1.0);\n      lut.addRGBPoint(midV, 1.0, 1.0, 1.0);\n      lut.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n\n      // Create mapper and actor for the isosurface\n      const mapper = vtkMapper.newInstance();\n      mapper.setInputConnection(normals.getOutputPort());\n      mapper.setScalarVisibility(true);\n      mapper.setLookupTable(lut);\n      mapper.setScalarRange(minV, maxV);\n      // Ensure we color by the computed/selected scalar array on the surface\n      mapper.setScalarModeToUsePointFieldData();\n      mapper.setColorByArrayName(scalarName);\n\n      const actor = vtkActor.newInstance();\n      actor.setMapper(mapper);\n\n      // ----------------------------------------------------------------------------\n      // USER REQUIREMENT: Set the isosurface to fully opaque with smooth shading\n      // ----------------------------------------------------------------------------\n      actor.getProperty().setOpacity(1.0);            // Fully opaque\n      actor.getProperty().setInterpolationToPhong();  // Smooth shading\n\n      // Add to scene and render\n      renderer.addActor(actor);\n      renderer.resetCamera();\n\n      // ----------------------------------------------------------------------------\n      // USER REQUIREMENT: Add an XYZ orientation marker in the bottom-right corner\n      // ----------------------------------------------------------------------------\n      const axes = vtkAxesActor.newInstance();\n      const orientationMarker = vtkOrientationMarkerWidget.newInstance({\n        actor: axes,\n        interactor: renderWindow.getInteractor(),\n      });\n      orientationMarker.setEnabled(true);\n      orientationMarker.setViewportCorner(vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT);\n      orientationMarker.setViewportSize(0.15); // 15% of window size\n      orientationMarker.setMinPixelSize(100);\n      orientationMarker.setMaxPixelSize(300);\n      orientationMarker.setInteractive(false); // No UI interaction, as requested\n\n      renderWindow.render();\n\n      // Developer console helpers (optional)\n      window.vtk = vtk;\n      window.imageData = imageData;\n      window.actor = actor;\n      window.mapper = mapper;\n      window.lut = lut;\n      window.contour = contour;\n      window.normals = normals;\n      window.renderer = renderer;\n      window.renderWindow = renderWindow;\n    }).catch((err) => {\n      console.error('Failed to load VTI dataset:', err);\n    });\n\n    // ----------------------------------------------------------------------------\n    // Summary of how each user requirement is satisfied (in code comments):\n    // - Load dataset from URL using vtkXMLImageDataReader (vti format) -> reader.setUrl(...)\n    // - Compute velocity magnitude from v02 and v03 if present -> computeMagnitudeArray(...)\n    //   Otherwise, use 'prs' as scalar -> fallback logic\n    // - Generate isosurface at mid scalar value -> vtkContourFilter.setValue(0, midV)\n    // - Blue → white → red colormap across [min, max] -> vtkColorTransferFunction with 3 RGB points\n    // - Fully opaque, smooth shading -> actor.getProperty().setOpacity(1.0) and vtkPolyDataNormals + Phong interpolation\n    // - XYZ orientation marker bottom-right -> vtkOrientationMarkerWidget with axes actor, setViewportCorner(BOTTOM_RIGHT)\n    // - No UI controls are added; only the rendering window is present\n    // ----------------------------------------------------------------------------\n  </script>\n</body>\n</html>",
  "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
  "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Deepwater dataset with isosurface rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/deepwater.vti_x000d_\n_x000d_\nCompute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar_x000d_\n_x000d_\nGenerate an isosurface at the mid-value of the scalar range_x000d_\n_x000d_\nUse a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nSet the isosurface to fully opaque with smooth shading_x000d_\n_x000d_\nAdd an XYZ orientation marker in the bottom-right corner\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 5.00, Matches: vtkCalculator):\nDescription: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n\nModules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // using vtk namespace\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints = vtk.Common.Core.vtkPoints;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // setting vtkCalculator and set formula\n\n        const simpleFilter = vtkCalculator.newInstance();\n\n        simpleFilter.setFormulaSimple(\n            FieldDataTypes.POINT, // Generate an output array defined over points.\n            [], // We don't request any point-data arrays because point coordinates are made available by default.\n            'outputArray', // Name the output array \n            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125\n        ); \n\n        //using plane source to generate a poly data which can be rendered by vtkActor\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n        const sourceData = planeSource.getOutputData();\n\n        simpleFilter.setInputData(sourceData);\n        const planeActor = vtkActor.newInstance();\n        const planeMapper = vtkMapper.newInstance();\n        planeMapper.setInputData(simpleFilter.getOutputData());\n        planeMapper.setColorByArrayName('outputArray'); \n\n        planeMapper.setScalarModeToUsePointFieldData();   \n        planeActor.setMapper(planeMapper);\n        planeActor.getProperty().setEdgeVisibility(true);\n\n        renderer.addActor(planeActor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 2 (Score: 5.00, Matches: vtkCalculator):\nDescription: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageLabelOutline</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Use the vtk namespace to reference each class\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        // Use the vtk namespace to reference constants\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.5, 0.5, 0.5],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const BACKGROUND = 0;\n        const LOW_VALUE = 80;\n        const HIGH_VALUE = 160;\n\n        const FIRST_SEGMENT = 1;\n        const SECOND_SEGMENT = 5;\n\n        /**\n         * Creates a labelmap image with the same dimensions as the background volume.\n         * @param {vtkImageData} backgroundImageData - The background volume data.\n         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.\n         */\n        function createLabelmap(backgroundImageData) {\n            // Create a labelmap image the same dimensions as our background volume.\n            const labelMapData = vtkImageData.newInstance(\n                backgroundImageData.get('spacing', 'origin', 'direction')\n            );\n\n            labelMapData.computeTransforms();\n\n            const dataArray = vtkDataArray.newInstance({\n                numberOfComponents: 1,\n                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),\n            });\n            labelMapData.getPointData().setScalars(dataArray);\n\n            labelMapData.setDimensions(...backgroundImageData.getDimensions());\n            labelMapData.setSpacing(...backgroundImageData.getSpacing());\n            labelMapData.setOrigin(...backgroundImageData.getOrigin());\n            labelMapData.setDirection(...backgroundImageData.getDirection());\n            const mapper = vtkImageMapper.newInstance();\n            mapper.setInputData(labelMapData);\n\n            const actor = vtkImageSlice.newInstance();\n\n            actor.setMapper(mapper);\n\n            const labelMap = {\n                actor,\n                mapper,\n                imageData: labelMapData,\n                cfun: vtkColorTransferFunction.newInstance(),\n                ofun: vtkPiecewiseFunction.newInstance(),\n            };\n\n            // Labelmap pipeline\n            labelMap.mapper.setInputData(labelMapData);\n            labelMap.actor.setMapper(labelMap.mapper);\n\n            // Set up labelMap color and opacity mapping\n            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label \"5\" will be green\n            labelMap.ofun.addPoint(0, 0);\n            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.\n            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.\n\n            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);\n            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);\n            labelMap.actor.getProperty().setInterpolationTypeToNearest();\n\n            labelMap.actor.getProperty().setUseLabelOutline(true);\n            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4\n            // (positioned at array index 4)\n            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);\n            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);\n\n            // This is very important to make sure the labelmap is rendered\n            // correctly\n            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);\n\n            const dims = labelMap.imageData.getDimensions();\n            const values = labelMap.imageData.getPointData().getScalars().getData();\n\n            const backgroundValues = backgroundImageData\n                .getPointData()\n                .getScalars()\n                .getData();\n            const size = dims[0] * dims[1] * dims[2];\n\n            for (let i = 0; i < size; i++) {\n                if (backgroundValues[i] === LOW_VALUE) {\n                    values[i] = FIRST_SEGMENT;\n                } else if (backgroundValues[i] === HIGH_VALUE) {\n                    values[i] = SECOND_SEGMENT;\n                }\n            }\n\n            labelMap.imageData.getPointData().getScalars().setData(values);\n\n            return labelMap;\n        }\n\n        // Create a one slice vtkImageData that has four quadrants of different values\n        const imageData = vtkImageData.newInstance();\n        const dims = [10, 10, 1];\n        imageData.setSpacing(1, 1, 1);\n        imageData.setOrigin(0.1, 0.1, 0.1);\n        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);\n\n        imageData.computeTransforms();\n\n        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);\n\n        let i = 0;\n        for (let y = 0; y < dims[1]; y++) {\n            for (let x = 0; x < dims[0]; x++, i++) {\n                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {\n                    values[i] = BACKGROUND;\n                } else if (x > 4 && x < 6 && y > 4 && y < 7) {\n                    values[i] = LOW_VALUE;\n                } else {\n                    values[i] = HIGH_VALUE;\n                }\n            }\n        }\n\n        const dataArray = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values,\n        });\n        imageData.getPointData().setScalars(dataArray);\n        imageData.modified();\n\n        const data = imageData;\n        const labelMap = createLabelmap(data);\n\n        const actor = vtkImageSlice.newInstance();\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(data);\n        actor.setMapper(mapper);\n        actor.getProperty().setInterpolationTypeToNearest();\n\n        renderer.addActor(actor);\n        renderer.addActor(labelMap.actor);\n        renderer.resetCamera();\n        renderer.resetCameraClippingRange();\n        renderWindow.render();\n\n        window.fullScreen = fullScreenRenderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 3 (Score: 5.00, Matches: vtkCalculator):\nDescription: Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n\n        console.log(planeSource.getOutputData().toJSON());\n\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                // array in is null here?\n                console.log(\"arraysIn:\", arraysIn());\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars\n        // so the plane mapper will color by 'temperature':\n        simpleFilter.setInputData(planeSource.getOutputData());\n        simpleFilter.update();\n        concole.log(simpleFilter.getOutputData());\n\n        //mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        //mapper.setOrientationArray('orientation');\n        //mapper.setScaleArray('pressure');\n\n        //actor.setMapper(mapper);\n\n       // renderer.addActor(actor);\n       // renderer.resetCamera();\n        //renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        // fullScreenRenderer.addController(controlPanel);\n        // ['xResolution', 'yResolution'].forEach((propertyName) => {\n        //     document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n        //         const value = Number(e.target.value);\n        //         console.log(\"propertyName\",propertyName);\n        //         console.log(\"value\",value);\n        //         planeSource.set({ [propertyName]: value });\n        //         renderWindow.render();\n        //     });\n        // });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 5.00, Matches: vtkCalculator):\nDescription: Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkConeSource, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkGlyph3DMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtkjs- Rendering-GlyphMapper</title>\n</head>\n\n\n\n<body>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Assuming vtk object is properly imported and available in global environment, proceed with corresponding assignments\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;\n        const vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkGlyph3DMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data...\n                        name: 'pressure', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        numberOfComponents: 3, //... with this many components...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data...\n                        name: 'temperature', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        attribute: AttributeTypes.SCALARS, //... and will be marked as the default scalars.\n                        numberOfComponents: 1, //... with this many components...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [press, temp] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    press[i * 3] = (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5);\n                    press[i * 3 + 1] =\n                        ((coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) + 0.125) * 0.1;\n                    press[i * 3 + 2] =\n                        ((coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                            (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) +\n                            0.125) *\n                        0.1;\n                    temp[i] = coords[3 * i + 1] * 0.1;\n                }\n\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n\n        // console.log(\"planeSource\", planeSource.getOutputPort)\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort(), 0);\n\n        const coneSource = vtkConeSource.newInstance();\n        coneSource.setResolution(12);\n        mapper.setInputConnection(coneSource.getOutputPort(), 1);\n        mapper.setOrientationArray('pressure');\n        mapper.setScalarRange(0.0, 0.1);\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n    </script>\n\n</body>\n\n</html>\n\nExample 5 (Score: 5.00, Matches: vtkCalculator):\nDescription: Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js StickMapper</title>\n    <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\">\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Geometry\"></script>\n    <script src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Molecule\"></script>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        mapper.setOrientationArray('orientation');\n        mapper.setScaleArray('pressure');\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 6 (Score: 5.00, Matches: vtkImageMarchingCubes):\nDescription: Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.\nModules: vtk.Common.DataModel.vtkSphere, vtk.Filters.General.vtkImageMarchingCubes, vtk.Imaging.Hybrid.vtkSampleFunction, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js@32.6.0/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        const mCubes = vtkImageMarchingCubes.newInstance({ contourValue: 0.1 });\n        \n        //using the sphere function and sample function to create the source code\n        const vtkSphere = vtk.Common.DataModel.vtkSphere;\n        const vtkSampleFunction = vtk.Imaging.Hybrid.vtkSampleFunction;\n        const sphere = vtkSphere.newInstance({ center: [0.0, 0.0, 0.0], radius: 0.5 });\n        const sample = vtkSampleFunction.newInstance({\n            implicitFunction: sphere,\n            sampleDimensions: [50, 50, 50],\n            modelBounds: [-0.5, 0.5, -0.5, 0.5, -0.5, 0.5],\n        });\n\n        //connecting actor with render\n        const actor = vtkActor.newInstance();\n        renderer.addActor(actor);\n        \n        //connecting mapper with actor\n        const mapper = vtkMapper.newInstance();\n        actor.setMapper(mapper);\n\n        // Connect the pipeline proper\n        mCubes.setInputConnection(sample.getOutputPort());\n        mapper.setInputConnection(mCubes.getOutputPort());\n\n        renderer.resetCamera();\n        renderWindow.render();\n\n    </script>\n</body>\n\n</html>\n\n",
  "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
  "generator": "gpt-5",
  "evaluator": "qwen3-max",
  "score": null,
  "workflow": {
    "inquiryExpansion": true,
    "rag": true
  },
  "eval_id": "1765341597",
  "eval_user": "test",
  "export_time": null,
  "console_output": null,
  "eval_time": "2025-12-10 12:39:57",
  "evaluator_evaluation": {
    "score": "0.95",
    "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.95</Score>\n        <Reason>The generated code implements nearly identical functionality: it loads the VTI dataset, computes velocity magnitude from v02/v03 (or falls back to 'prs'), generates an isosurface at the mid-range value using a contour filter, applies a blue-white-red color map, adds smooth shading via normals and Phong interpolation, and includes an orientation marker. However, it uses vtkContourFilter + vtkPolyDataNormals instead of vtkImageMarchingCubes. While both produce isosurfaces, Marching Cubes is explicitly used in the ground truth and guarantees triangle output with normals when enabled; ContourFilter is more general but may behave slightly differently on image data. This is a minor deviation in pipeline design but achieves the same visual goal.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.9</Score>\n        <Reason>The colormap matches the ground truth’s intent (blue → white → red across the full scalar range), and smooth shading is correctly implemented. However, the background color differs ([0.08, 0.08, 0.1] vs [1,1,1]), which significantly affects perceived contrast and appearance. Additionally, the ground truth uses 5 control points in the color transfer function for smoother gradients, while the generated code uses only 3 (min, mid, max), potentially resulting in less nuanced color transitions. Camera setup is also omitted—no explicit focal point or position—relying on resetCamera(), which may yield a different initial view.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>1.0</Score>\n        <Reason>The generated code is exceptionally well-structured, readable, and maintainable. It uses clear helper functions (e.g., computeMagnitudeArray), comprehensive comments explaining user requirements, defensive fallback logic, proper error handling, and follows vtk.js best practices (e.g., using setInputConnection, correct scalar visibility settings). Variable names are descriptive, and the pipeline is modular and easy to debug or extend.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.95</OverallScore>\n        <Critique>The generated code is a high-quality, maintainable implementation that closely matches the ground truth in functionality and mostly in visual output, though it diverges slightly in isosurface extraction method, background color, colormap resolution, and camera initialization.</Critique>\n    </Summary>\n</Evaluation>",
    "parsed_evaluation": {
      "dimensions": {
        "Functionality": {
          "score": 0.95,
          "reason": "The generated code implements nearly identical functionality: it loads the VTI dataset, computes velocity magnitude from v02/v03 (or falls back to 'prs'), generates an isosurface at the mid-range value using a contour filter, applies a blue-white-red color map, adds smooth shading via normals and Phong interpolation, and includes an orientation marker. However, it uses vtkContourFilter + vtkPolyDataNormals instead of vtkImageMarchingCubes. While both produce isosurfaces, Marching Cubes is explicitly used in the ground truth and guarantees triangle output with normals when enabled; ContourFilter is more general but may behave slightly differently on image data. This is a minor deviation in pipeline design but achieves the same visual goal."
        },
        "VisualQuality": {
          "score": 0.9,
          "reason": "The colormap matches the ground truth’s intent (blue → white → red across the full scalar range), and smooth shading is correctly implemented. However, the background color differs ([0.08, 0.08, 0.1] vs [1,1,1]), which significantly affects perceived contrast and appearance. Additionally, the ground truth uses 5 control points in the color transfer function for smoother gradients, while the generated code uses only 3 (min, mid, max), potentially resulting in less nuanced color transitions. Camera setup is also omitted—no explicit focal point or position—relying on resetCamera(), which may yield a different initial view."
        },
        "CodeQuality": {
          "score": 1.0,
          "reason": "The generated code is exceptionally well-structured, readable, and maintainable. It uses clear helper functions (e.g., computeMagnitudeArray), comprehensive comments explaining user requirements, defensive fallback logic, proper error handling, and follows vtk.js best practices (e.g., using setInputConnection, correct scalar visibility settings). Variable names are descriptive, and the pipeline is modular and easy to debug or extend."
        }
      },
      "overall": 0.95,
      "critique": "The generated code is a high-quality, maintainable implementation that closely matches the ground truth in functionality and mostly in visual output, though it diverges slightly in isosurface extraction method, background color, colormap resolution, and camera initialization.",
      "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.95</Score>\n        <Reason>The generated code implements nearly identical functionality: it loads the VTI dataset, computes velocity magnitude from v02/v03 (or falls back to 'prs'), generates an isosurface at the mid-range value using a contour filter, applies a blue-white-red color map, adds smooth shading via normals and Phong interpolation, and includes an orientation marker. However, it uses vtkContourFilter + vtkPolyDataNormals instead of vtkImageMarchingCubes. While both produce isosurfaces, Marching Cubes is explicitly used in the ground truth and guarantees triangle output with normals when enabled; ContourFilter is more general but may behave slightly differently on image data. This is a minor deviation in pipeline design but achieves the same visual goal.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.9</Score>\n        <Reason>The colormap matches the ground truth’s intent (blue → white → red across the full scalar range), and smooth shading is correctly implemented. However, the background color differs ([0.08, 0.08, 0.1] vs [1,1,1]), which significantly affects perceived contrast and appearance. Additionally, the ground truth uses 5 control points in the color transfer function for smoother gradients, while the generated code uses only 3 (min, mid, max), potentially resulting in less nuanced color transitions. Camera setup is also omitted—no explicit focal point or position—relying on resetCamera(), which may yield a different initial view.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>1.0</Score>\n        <Reason>The generated code is exceptionally well-structured, readable, and maintainable. It uses clear helper functions (e.g., computeMagnitudeArray), comprehensive comments explaining user requirements, defensive fallback logic, proper error handling, and follows vtk.js best practices (e.g., using setInputConnection, correct scalar visibility settings). Variable names are descriptive, and the pipeline is modular and easy to debug or extend.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.95</OverallScore>\n        <Critique>The generated code is a high-quality, maintainable implementation that closely matches the ground truth in functionality and mostly in visual output, though it diverges slightly in isosurface extraction method, background color, colormap resolution, and camera initialization.</Critique>\n    </Summary>\n</Evaluation>"
    }
  },
  "options": null,
  "analysis": [
    {
      "phase": "Data Loading",
      "step_name": "Load Deepwater Dataset",
      "vtk_modules": [
        "vtkXMLImageDataReader"
      ],
      "description": "Load the dataset from 'http://127.0.0.1:5000/dataset/deepwater.vti' using vtkXMLImageDataReader."
    },
    {
      "phase": "Data Processing",
      "step_name": "Compute Velocity Magnitude",
      "vtk_modules": [
        "vtkCalculator"
      ],
      "description": "Use vtkCalculator to compute the velocity magnitude as sqrt(v02^2 + v03^2). If arrays v02 and v03 are not present, set 'prs' as the active scalar array."
    },
    {
      "phase": "Data Processing",
      "step_name": "Generate Isosurface",
      "vtk_modules": [
        "vtkImageMarchingCubes"
      ],
      "description": "Use vtkImageMarchingCubes to generate an isosurface at the mid-value of the scalar range of the active scalar (either computed velocity magnitude or 'prs')."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Apply Color Map",
      "vtk_modules": [
        "vtkColorTransferFunction",
        "vtkMapper"
      ],
      "description": "Create a blue → white → red color transfer function spanning the full scalar range (min to max). Apply it to the isosurface mapper."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Set Surface Properties",
      "vtk_modules": [
        "vtkProperty"
      ],
      "description": "Configure the isosurface actor's property to be fully opaque with smooth shading enabled."
    },
    {
      "phase": "UI Configuration",
      "step_name": "Add Orientation Marker",
      "vtk_modules": [
        "vtkOrientationMarkerWidget",
        "vtkAxesActor"
      ],
      "description": "Add an XYZ axes orientation marker in the bottom-right corner using vtkOrientationMarkerWidget and vtkAxesActor."
    },
    {
      "phase": "Rendering & Interaction",
      "step_name": "Render Scene",
      "vtk_modules": [
        "vtkRenderWindow",
        "vtkRenderer",
        "vtkRenderWindowInteractor"
      ],
      "description": "Initialize the render window, renderer, and interactor to display the isosurface with the configured color map, opacity, shading, and orientation marker."
    }
  ],
  "retrieval_results": [
    {
      "id": 1276004285,
      "title": "data\\vtkjs-examples\\prompt-sample\\Filter-Calculator\\code.html",
      "description": "This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n",
      "relevance": 5.0,
      "matched_keywords": [
        "vtkCalculator"
      ]
    },
    {
      "id": 144015752,
      "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageLabelOutline\\code.html",
      "description": "Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n",
      "relevance": 5.0,
      "matched_keywords": [
        "vtkCalculator"
      ]
    },
    {
      "id": 771311485,
      "title": "data\\vtkjs-examples\\prompt-sample\\IO-StickMapper\\code.html",
      "description": "Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n",
      "relevance": 5.0,
      "matched_keywords": [
        "vtkCalculator"
      ]
    },
    {
      "id": 105009849,
      "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-GlyphMapper\\code.html",
      "description": "Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n",
      "relevance": 5.0,
      "matched_keywords": [
        "vtkCalculator"
      ]
    },
    {
      "id": 1837944411,
      "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-StickMapper\\code.html",
      "description": "Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom poin",
      "relevance": 5.0,
      "matched_keywords": [
        "vtkCalculator"
      ]
    },
    {
      "id": 875726136,
      "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageMarchingCubes\\code.html",
      "description": "Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.",
      "relevance": 5.0,
      "matched_keywords": [
        "vtkImageMarchingCubes"
      ]
    }
  ]
}