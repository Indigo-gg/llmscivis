<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepwater Isosurface Visualization</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #renderer {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // VTK.js modules
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;
        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkDataArray = vtk.Common.Core.vtkDataArray;

        // Create renderer and render window
        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            containerStyle: { height: '100%', width: '100%' },
            background: [1, 1, 1],
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // Load dataset from local server
        const reader = vtkXMLImageDataReader.newInstance();
        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {
            return reader.loadData();
        }).then(() => {
            const imageData = reader.getOutputData();
            const pointData = imageData.getPointData();
            const v02Array = pointData.getArray('v02');
            const v03Array = pointData.getArray('v03');
            const prsArray = pointData.getArray('prs');

            let scalarArrayName = 'prs'; // Default fallback

            // Compute velocity magnitude if v02 and v03 are available
            if (v02Array && v03Array) {
                // Directly compute velocity magnitude without using vtkCalculator
                const numPoints = imageData.getNumberOfPoints();
                const v02Data = v02Array.getData();
                const v03Data = v03Array.getData();
                const velocityMagnitudeData = new Float32Array(numPoints);
                
                for (let i = 0; i < numPoints; i++) {
                    velocityMagnitudeData[i] = Math.sqrt(
                        v02Data[i] * v02Data[i] + 
                        v03Data[i] * v03Data[i]
                    );
                }
                
                // Create a new array for velocity magnitude
                const velocityMagnitudeArray = vtk.Common.Core.vtkDataArray.newInstance({
                    name: 'velocityMagnitude',
                    numberOfComponents: 1,
                    values: velocityMagnitudeData
                });
                
                // Add the new array to the point data
                pointData.addArray(velocityMagnitudeArray);
                pointData.setActiveScalars('velocityMagnitude');
                
                scalarArrayName = 'velocityMagnitude';
                processIsosurface(imageData, scalarArrayName);
                // renderWindow.render(); // Trigger final rendering - now done inside processIsosurface
            } else if (prsArray) {
                // Use prs as scalar if velocity components aren't available
                pointData.setActiveScalars('prs');
                scalarArrayName = 'prs';
                processIsosurface(imageData, scalarArrayName);
                // renderWindow.render(); // Trigger final rendering - now done inside processIsosurface
            } else {
                console.error('Required arrays not found in dataset');
                return;
            }

            // Add orientation marker (XYZ axes)
            const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();
            const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({
                actor: axes,
                interactor: renderWindow.getInteractor(),
            });
            widget.setEnabled(true);
            widget.setViewportCorner(
                vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
            );
            widget.setViewportSize(0.15);
            widget.setMinPixelSize(100);
            widget.setMaxPixelSize(300);
        }).catch(error => {
            console.error('Error loading or processing dataset:', error);
        });

        function processIsosurface(data, arrayName) {
            // Get range of current active scalar
            const activeScalars = data.getPointData().getScalars();
            const newRange = activeScalars.getRange();
            const [minV, maxV] = newRange;

            const marchingCube = vtkImageMarchingCubes.newInstance({
                contourValue: minV + 0.5 * (maxV - minV),
                computeNormals: true,
                mergePoints: true
            });

            marchingCube.setInputData(data);

            const mapper = vtkMapper.newInstance();
            mapper.setInputConnection(marchingCube.getOutputPort());

            const colorTransferFunction = vtkColorTransferFunction.newInstance();
            colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);
            colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);
            colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);
            colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);
            colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);

            mapper.setLookupTable(colorTransferFunction);
            mapper.setScalarRange(minV, maxV);
            mapper.setInterpolateScalarsBeforeMapping(true);

            const actor = vtkActor.newInstance();
            actor.setMapper(mapper);
            actor.getProperty().setRepresentationToSurface();
            actor.getProperty().setEdgeVisibility(false);
            actor.getProperty().setOpacity(1.0);
            actor.getProperty().setAmbient(0.3);
            actor.getProperty().setDiffuse(0.7);
            actor.getProperty().setSpecular(0.4);

            renderer.addActor(actor);

            const bounds = data.getBounds();
            const center = [
                (bounds[0] + bounds[1]) / 2,
                (bounds[2] + bounds[3]) / 2,
                (bounds[4] + bounds[5]) / 2,
            ];

            const camera = renderer.getActiveCamera();
            camera.setFocalPoint(...center);
            camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);
            camera.setViewUp(0, 0, 1);
            renderer.resetCameraClippingRange();
            renderWindow.render();
            renderer.resetCamera();
            renderWindow.render();
        }
    </script>
</body>
</html>