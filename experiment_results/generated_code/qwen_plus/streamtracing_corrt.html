
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VTK.js Streamline Visualization of Isabel Dataset</title>
<style>
body {
margin: 0;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="https://unpkg.com/vtk.js@34.10.0/vtk.js"></script>
<script>
// Import required VTK.js modules
const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
// const vtkStreamTracer = vtk.Filters.HyperStreamline.vtkStreamTracer;
        const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline;
// const vtkPolyDataMapper = vtk.Rendering.OpenGL.vtkPolyDataMapper;
const vtkPolyDataMapper = vtk.Rendering.Core.vtkPolyDataMapper;
// todo 
const vtkMapper = vtk.Rendering.Core.vtkMapper;
const vtkActor = vtk.Rendering.Core.vtkActor;
const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;
const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
const vtkDataArray = vtk.Common.Core.vtkDataArray;

// Create full screen render window
const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });
const renderer = fullScreenRenderer.getRenderer();
const renderWindow = fullScreenRenderer.getRenderWindow();
const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;

// todo 
function addRepresentation(name, filter, props = {}) {
    const mapper = vtkMapper.newInstance();
    mapper.setInputConnection(filter.getOutputPort());
    const actor = vtkActor.newInstance();
    actor.setMapper(mapper);
    actor.getProperty().set(props);
    renderer.addActor(actor);
}
// todo2
// Load the dataset from the given URL
const reader = vtkXMLImageDataReader.newInstance({ fetchGzip: false });
reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {
reader.update();

// 1. Use the "Velocity" array as the vector field for streamlines
const dataset = reader.getOutputData();
const velocityArray = dataset.getPointData().getArrayByName('Velocity');
if (!velocityArray) {
console.error("Velocity array not found in dataset.");
return;
}

// 2. Generate seed points at the center of the dataset with sufficient density
const bounds = dataset.getBounds();
const center = [
(bounds[0] + bounds[1]) / 2,
(bounds[2] + bounds[3]) / 2,
(bounds[4] + bounds[5]) / 2
];

// const seedSource = vtkPlaneSource.newInstance();
// seedSource.setOrigin(center[0] - 20, center[1] - 20, center[2]);
// seedSource.setPoint1(center[0] + 20, center[1] - 20, center[2]);
// seedSource.setPoint2(center[0] - 20, center[1] + 20, center[2]);
// seedSource.setXResolution(10);
// seedSource.setYResolution(10);
// seedSource.update();

// 生成种子点
const pointSource = vtk.Filters.Sources.vtkPointSource.newInstance();
pointSource.setNumberOfPoints(1000);  // 增加种子点密度
pointSource.setCenter(
    (bounds[0] + bounds[1]) / 2,
    (bounds[2] + bounds[3]) / 2,
    (bounds[4] + bounds[5]) / 2
);
pointSource.setRadius(Math.max(
    bounds[1] - bounds[0],
    bounds[3] - bounds[2],
    bounds[5] - bounds[4],
) / 2);
// todo
// todo
// const streamTracer = vtkImageStreamline.newInstance({
//     integratorType: 5, // RUNGE_KUTTA_45
//     maximumNumberOfSteps: 2000,
//     stepLength: 0.25,
//     startStepLength: 0.01,
//     minStepLength: 0.001,
//     maxStepLength: 1.0,
//     terminalSpeed: 1e-12,
//     integrationDirection: 2, // BOTH
// });
// streamTracer.setInputData(dataset);
// streamTracer.setSourceConnection(seedSource.getOutputPort()); // 这里会报错
// streamTracer.update();
const streamline = vtkImageStreamline.newInstance();
streamline.setInputData(dataset);
streamline.setInputConnection(pointSource.getOutputPort(), 1); // 种子点数据
streamline.set({
    maximumNumberOfSteps: 1000,
    integrationStep: 0.5,
});

// // 4. Render streamlines in cyan [0, 1, 1] with specified line width
// const streamlineMapper = vtkPolyDataMapper.newInstance();
// streamlineMapper.setInputConnection(streamline.getOutputPort());

// const streamlineActor = vtkActor.newInstance();
// streamlineActor.setMapper(streamlineMapper);
// streamlineActor.getProperty().setColor(0, 1, 1); // Cyan
// streamlineActor.getProperty().setLineWidth(2);   // Line width 2

// // 5. Render dataset outline in red [1, 0, 0] with specified line width
// const outlineFilter = vtkOutlineFilter.newInstance();
// outlineFilter.setInputData(dataset);
// outlineFilter.update();

// const outlineMapper = vtkPolyDataMapper.newInstance();
// outlineMapper.setInputConnection(outlineFilter.getOutputPort());

// const outlineActor = vtkActor.newInstance();
// outlineActor.setMapper(outlineMapper);
// outlineActor.getProperty().setColor(1, 0, 0); // Red
// outlineActor.getProperty().setLineWidth(2);   // Line width 2

// 渲染流线
addRepresentation('streamLine', streamline, {
    diffuseColor: [0, 1, 1], // 使用 diffuseColor
    lineWidth: 5,            // 使用更粗的线条
});

// 渲染轮廓
const outlineFilter = vtkOutlineFilter.newInstance();
outlineFilter.setInputData(dataset); // 使用统一的变量名
addRepresentation('outline', outlineFilter, {
    diffuseColor: [1, 0, 0], // 使用 diffuseColor
    lineWidth: 3,            // 使用更粗的线条
});
// Add actors to the renderer
// renderer.addActor(streamlineActor);
// renderer.addActor(outlineActor);

// Reset camera and render
renderer.resetCamera();
renderWindow.render();
});

// Ensure the reader is accessible globally for debugging
window.reader = reader;
</script>
</body>
</html>
