
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VTK.js Streamline Visualization of Isabel Dataset</title>
<style>
body {
margin: 0;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="https://unpkg.com/vtk.js"></script>
<script>
// Import required VTK.js modules
const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
const vtkStreamTracer = vtk.Filters.HyperStreamline.vtkStreamTracer;
const vtkPolyDataMapper = vtk.Rendering.Core.vtkPolyDataMapper;
const vtkActor = vtk.Rendering.Core.vtkActor;
const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;
const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
const vtkDataArray = vtk.Common.Core.vtkDataArray;

// Create full screen render window
const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });
const renderer = fullScreenRenderer.getRenderer();
const renderWindow = fullScreenRenderer.getRenderWindow();

// Load the dataset from the given URL
const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });
reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {
reader.update();

// 1. Use the "Velocity" array as the vector field for streamlines
const dataset = reader.getOutputData();
const velocityArray = dataset.getPointData().getArrayByName('Velocity');
if (!velocityArray) {
console.error("Velocity array not found in dataset.");
return;
}

// 2. Generate seed points at the center of the dataset with sufficient density
const bounds = dataset.getBounds();
const center = [
(bounds[0] + bounds[1]) / 2,
(bounds[2] + bounds[3]) / 2,
(bounds[4] + bounds[5]) / 2
];

const seedSource = vtkPlaneSource.newInstance();
seedSource.setOrigin(center[0] - 20, center[1] - 20, center[2]);
seedSource.setPoint1(center[0] + 20, center[1] - 20, center[2]);
seedSource.setPoint2(center[0] - 20, center[1] + 20, center[2]);
seedSource.setXResolution(10);
seedSource.setYResolution(10);
seedSource.update();

// 3. Compute streamlines following the velocity field
const streamTracer = vtkStreamTracer.newInstance({
integratorType: 5, // RUNGE_KUTTA_45
maximumNumberOfSteps: 2000,
stepLength: 0.25,
startStepLength: 0.01,
minStepLength: 0.001,
maxStepLength: 1.0,
terminalSpeed: 1e-12,
integrationDirection: 2, // BOTH
});
streamTracer.setInputData(dataset);
streamTracer.setSourceConnection(seedSource.getOutputPort());
streamTracer.update();

// 4. Render streamlines in cyan [0, 1, 1] with specified line width
const streamlineMapper = vtkPolyDataMapper.newInstance();
streamlineMapper.setInputConnection(streamTracer.getOutputPort());

const streamlineActor = vtkActor.newInstance();
streamlineActor.setMapper(streamlineMapper);
streamlineActor.getProperty().setColor(0, 1, 1); // Cyan
streamlineActor.getProperty().setLineWidth(2);   // Line width 2

// 5. Render dataset outline in red [1, 0, 0] with specified line width
const outlineFilter = vtkOutlineFilter.newInstance();
outlineFilter.setInputData(dataset);
outlineFilter.update();

const outlineMapper = vtkPolyDataMapper.newInstance();
outlineMapper.setInputConnection(outlineFilter.getOutputPort());

const outlineActor = vtkActor.newInstance();
outlineActor.setMapper(outlineMapper);
outlineActor.getProperty().setColor(1, 0, 0); // Red
outlineActor.getProperty().setLineWidth(2);   // Line width 2

// Add actors to the renderer
renderer.addActor(streamlineActor);
renderer.addActor(outlineActor);

// Reset camera and render
renderer.resetCamera();
renderWindow.render();
});

// Ensure the reader is accessible globally for debugging
window.reader = reader;
</script>
</body>
</html>
