{
  "path": "",
  "name": "",
  "prompt": "Generate an HTML page using vtk.js to visualize the Isabel dataset with streamline rendering.\n\nLoad the dataset from: http://127.0.0.1:5000/dataset/isabel.vti\n\nUse the \"Velocity\" array as the vector field for streamlines\n\nGenerate seed points at the center of the dataset with sufficient density to cover the domain\n\nCompute streamlines following the velocity field\n\nRender streamlines in cyan ([0, 1, 1]) with a specified line width\n\nRender a dataset outline in red ([1, 0, 0]) with a specified line width",
  "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>Isosurface Rendering for Isabel Dataset</title>\n</head>\n\n<body>\n<!-- Renderer container -->\n<div id=\"renderer\"></div>\n<!-- Load VTK.js library -->\n<script src=\"https://unpkg.com/vtk.js\"></script>\n<script>\n// Import required VTK.js classes\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\nconst vtkActor = vtk.Rendering.Core.vtkActor;\nconst vtkMapper = vtk.Rendering.Core.vtkMapper;\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\nconst vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n// Initialize render window, set background color to black\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\nbackground: [0.1, 0.1, 0.1],\n});\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();\nconst renderer = fullScreenRenderWindow.getRenderer();\n\n// Create XML image data reader instance\nconst reader = vtkXMLImageDataReader.newInstance();\n\n// Set data file URL and load data\nreader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\isabel.vti').then(() => {\n// After data URL is set successfully, load data\nreader.loadData().then(() => {\n// Get loaded image data\nconst imageData = reader.getOutputData(0);\n\n// Get velocity vector field from data\nconst velocityArray = imageData.getPointData().getArrayByName('Velocity');\n// Get total number of data points\nconst numPoints = imageData.getNumberOfPoints();\n// Create new array to store velocity magnitude\nconst magnitudeData = new Float64Array(numPoints);\n\n// Calculate velocity magnitude (norm of velocity vector) for each point\nfor (let i = 0; i < numPoints; i++) {\n// Get three components of velocity\nconst vx = velocityArray.getData()[3 * i + 0]; // x component\nconst vy = velocityArray.getData()[3 * i + 1]; // y component\nconst vz = velocityArray.getData()[3 * i + 2]; // z component\n// Calculate velocity magnitude (Euclidean norm)\nmagnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n}\n\n// Create VTK data array class\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;\n// Create VTK array for velocity magnitude\nconst magnitudeVtkArray = vtkDataArray.newInstance({\nnumberOfComponents: 1, // Scalar data, only one component\nvalues: magnitudeData, // Data values\nname: 'velocityMagnitude', // Array name\n});\nimageData.getPointData().addArray(magnitudeVtkArray);\n\nimageData.getPointData().setActiveScalars('velocityMagnitude');\nimageData.setSpacing(2.5, 2.5, 1.0);\n\nconst newRange = magnitudeVtkArray.getRange();\nconsole.log('Velocity magnitude range:', newRange);\nconst [minV, maxV] = newRange;\n\nconst marchingCube = vtkImageMarchingCubes.newInstance({\ncontourValue: minV + 0.5 * (maxV - minV), // Set isosurface value to middle of data range\ncomputeNormals: true, // Compute normals for lighting effects\nmergePoints: true // Merge duplicate points to reduce data size\n});\n\nmarchingCube.setInputData(imageData);\n\nconst mapper = vtkMapper.newInstance();\nmapper.setInputConnection(marchingCube.getOutputPort());\n\nconst actor = vtkActor.newInstance();\nactor.setMapper(mapper);\nrenderer.addActor(actor);\nconst camera = renderer.getActiveCamera();\nrenderer.resetCameraClippingRange();\nrenderer.resetCamera();\nrenderWindow.render();\n});\n});\n</script>\n</body>\n\n</html>",
  "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>VTK.js Isabel Streamlines Visualization</title>\n  <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <script>\n    // Load required VTK.js modules\n    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    const vtkActor = vtk.Rendering.Core.vtkActor;\n    const vtkMapper = vtk.Rendering.Core.vtkMapper;\n    const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n    const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline;\n    const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;\n    const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n\n    // Create full screen render window\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n      rootContainer: document.querySelector('#container'),\n      background: [0, 0, 0]\n    });\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // Create reader for the dataset\n    const reader = vtkXMLImageDataReader.newInstance();\n    reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n      // Extract the dataset from the reader\n      const dataset = reader.getOutputData();\n\n      // Create seed points at the center of the dataset\n      const bounds = dataset.getBounds();\n      const center = [\n        (bounds[0] + bounds[1]) / 2,\n        (bounds[2] + bounds[3]) / 2,\n        (bounds[4] + bounds[5]) / 2\n      ];\n\n      // Create plane source for seeding streamlines\n      const planeSource = vtkPlaneSource.newInstance();\n      planeSource.setOrigin(\n        bounds[0] + (bounds[1] - bounds[0]) * 0.25,\n        bounds[2] + (bounds[3] - bounds[2]) * 0.25,\n        center[2]\n      );\n      planeSource.setPoint1(\n        bounds[1] - (bounds[1] - bounds[0]) * 0.25,\n        bounds[2] + (bounds[3] - bounds[2]) * 0.25,\n        center[2]\n      );\n      planeSource.setPoint2(\n        bounds[0] + (bounds[1] - bounds[0]) * 0.25,\n        bounds[3] - (bounds[3] - bounds[2]) * 0.25,\n        center[2]\n      );\n      planeSource.setXResolution(10);\n      planeSource.setYResolution(10);\n\n      // Create streamline filter\n      const streamlines = vtkImageStreamline.newInstance();\n      streamlines.setInputConnection(reader.getOutputPort());\n      streamlines.setInputConnection(planeSource.getOutputPort(), 1);\n      streamlines.setIntegrationStep(0.5);\n      streamlines.setStepLength(0.1);\n      streamlines.setMaximumNumberOfSteps(2000);\n      streamlines.setInitialIntegrationStep(0.1);\n      streamlines.setIntegratorTypeToRungeKutta45();\n      streamlines.setVectorField('Velocity'); // Use Velocity array as vector field\n\n      // Create mapper and actor for streamlines\n      const streamMapper = vtkMapper.newInstance();\n      streamMapper.setInputConnection(streamlines.getOutputPort());\n\n      const streamActor = vtkActor.newInstance();\n      streamActor.setMapper(streamMapper);\n      streamActor.getProperty().setColor(0, 1, 1); // Cyan color\n      streamActor.getProperty().setLineWidth(2);   // Line width\n\n      // Create outline filter for dataset bounds\n      const outlineFilter = vtkOutlineFilter.newInstance();\n      outlineFilter.setInputConnection(reader.getOutputPort());\n\n      // Create mapper and actor for outline\n      const outlineMapper = vtkMapper.newInstance();\n      outlineMapper.setInputConnection(outlineFilter.getOutputPort());\n\n      const outlineActor = vtkActor.newInstance();\n      outlineActor.setMapper(outlineMapper);\n      outlineActor.getProperty().setColor(1, 0, 0); // Red color\n      outlineActor.getProperty().setLineWidth(3);   // Line width\n\n      // Add actors to the renderer\n      renderer.addActor(streamActor);\n      renderer.addActor(outlineActor);\n\n      // Reset camera and render\n      renderer.resetCamera();\n      renderWindow.render();\n    });\n  </script>\n</body>\n</html>\n```",
  "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Use appropriate VTK.js modules and methods as shown in the examples\n    7. Pay special attention to data loading paths and visualization parameters\n    8. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
  "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Isabel dataset with streamline rendering.\n\nLoad the dataset from: http://127.0.0.1:5000/dataset/isabel.vti\n\nUse the \"Velocity\" array as the vector field for streamlines\n\nGenerate seed points at the center of the dataset with sufficient density to cover the domain\n\nCompute streamlines following the velocity field\n\nRender streamlines in cyan ([0, 1, 1]) with a specified line width\n\nRender a dataset outline in red ([1, 0, 0]) with a specified line width\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 20.00, Matches: vtkImageStreamline, vtkMapper, vtkPlaneSource, vtkOutlineFilter):\nDescription: Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkImageData, vtk.Filters.General.vtkImageStreamline, vtk.Filters.General.vtkOutlineFilter, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.Property, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Core.vtkProperty.Representation, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance, vtk.macro\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageOutlineFilter</title>\n    <!-- <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\"> -->\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n\n    <script type=\"text/javascript\" src=\"https://unpkg.com/@babel/polyfill@7.0.0/dist/polyfill.js\"></script>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        console.log(vtk.Rendering.Core.Property);\n\n        const Representation = vtk.Rendering.Core.vtkProperty.Representation;\n        // const Representation = Constants.representation;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const macro = vtk.macro;\n\n        // Load control panel HTML\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        function addRepresentation(name, filter, props = {}) {\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputConnection(filter.getOutputPort());\n\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n            actor.getProperty().set(props);\n            renderer.addActor(actor);\n\n            window[`${name}Actor`] = actor;\n            window[`${name}Mapper`] = mapper;\n        }\n\n        // ----------------------------------------------------------------------------\n\n        const vecSource = macro.newInstance((publicAPI, model) => {\n            macro.obj(publicAPI, model); // make it an object\n            macro.algo(publicAPI, model, 0, 1); // mixin algorithm code 1 in, 1 out\n            publicAPI.requestData = (inData, outData) => {\n                // implement requestData\n                if (!outData[0]) {\n                    const id = vtkImageData.newInstance();\n                    id.setSpacing(0.1, 0.1, 0.1);\n                    id.setExtent(0, 9, 0, 9, 0, 9);\n                    const dims = [10, 10, 10];\n\n                    const newArray = new Float32Array(3 * dims[0] * dims[1] * dims[2]);\n\n                    let i = 0;\n                    for (let z = 0; z <= 9; z++) {\n                        for (let y = 0; y <= 9; y++) {\n                            for (let x = 0; x <= 9; x++) {\n                                newArray[i++] = 0.1 * x;\n                                const v = 0.1 * y;\n                                newArray[i++] = v * v;\n                                newArray[i++] = 0;\n                            }\n                        }\n                    }\n\n                    const da = vtkDataArray.newInstance({\n                        numberOfComponents: 3,\n                        values: newArray,\n                    });\n                    da.setName('vectors');\n\n                    const cpd = id.getPointData();\n                    cpd.setVectors(da);\n\n                    // Update output\n                    outData[0] = id;\n                }\n            };\n        })();\n\n        const planeSource = vtkPlaneSource.newInstance();\n        planeSource.setOrigin(0.05, 0.05, 0.05);\n        planeSource.setPoint1(0.05, 0.85, 0.05);\n        planeSource.setPoint2(0.05, 0.05, 0.85);\n\n        const sline = vtkImageStreamline.newInstance();\n        sline.setIntegrationStep(0.01);\n        sline.setInputConnection(vecSource.getOutputPort());\n        sline.setInputConnection(planeSource.getOutputPort(), 1);\n\n        const outlineFilter = vtkOutlineFilter.newInstance();\n        outlineFilter.setInputConnection(vecSource.getOutputPort());\n\n        addRepresentation('streamLine', sline, {\n            diffuseColor: [0, 1, 1],\n            lineWidth: 5,\n        });\n        addRepresentation('outline', outlineFilter, {\n            diffuseColor: [1, 0, 0],\n            lineWidth: 3,\n        });\n        addRepresentation('seed', planeSource, {\n            representation: Representation.POINTS,\n            pointSize: 10,\n        });\n\n        // -----------------------------------------------------------\n\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // ----------------------------------------------------------------------------\n        // UI control handling\n        // ----------------------------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.sline = sline;\n        window.outlineFilter = outlineFilter;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n\n    </script>\n\n</body>\n\n</html>\n\nExample 2 (Score: 20.00, Matches: vtkCalculator, vtkMapper, vtkGlyph3DMapper, vtkPlaneSource):\nDescription: Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkConeSource, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkGlyph3DMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtkjs- Rendering-GlyphMapper</title>\n</head>\n\n\n\n<body>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Assuming vtk object is properly imported and available in global environment, proceed with corresponding assignments\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;\n        const vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkGlyph3DMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data...\n                        name: 'pressure', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        numberOfComponents: 3, //... with this many components...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data...\n                        name: 'temperature', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        attribute: AttributeTypes.SCALARS, //... and will be marked as the default scalars.\n                        numberOfComponents: 1, //... with this many components...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [press, temp] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    press[i * 3] = (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5);\n                    press[i * 3 + 1] =\n                        ((coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) + 0.125) * 0.1;\n                    press[i * 3 + 2] =\n                        ((coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                            (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) +\n                            0.125) *\n                        0.1;\n                    temp[i] = coords[3 * i + 1] * 0.1;\n                }\n\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n\n        // console.log(\"planeSource\", planeSource.getOutputPort)\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort(), 0);\n\n        const coneSource = vtkConeSource.newInstance();\n        coneSource.setResolution(12);\n        mapper.setInputConnection(coneSource.getOutputPort(), 1);\n        mapper.setOrientationArray('pressure');\n        mapper.setScalarRange(0.0, 0.1);\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n    </script>\n\n</body>\n\n</html>\n\nExample 3 (Score: 15.00, Matches: vtkCalculator, vtkMapper, vtkPlaneSource):\nDescription: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n\nModules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // using vtk namespace\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints = vtk.Common.Core.vtkPoints;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // setting vtkCalculator and set formula\n\n        const simpleFilter = vtkCalculator.newInstance();\n\n        simpleFilter.setFormulaSimple(\n            FieldDataTypes.POINT, // Generate an output array defined over points.\n            [], // We don't request any point-data arrays because point coordinates are made available by default.\n            'outputArray', // Name the output array \n            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125\n        ); \n\n        //using plane source to generate a poly data which can be rendered by vtkActor\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n        const sourceData = planeSource.getOutputData();\n\n        simpleFilter.setInputData(sourceData);\n        const planeActor = vtkActor.newInstance();\n        const planeMapper = vtkMapper.newInstance();\n        planeMapper.setInputData(simpleFilter.getOutputData());\n        planeMapper.setColorByArrayName('outputArray'); \n\n        planeMapper.setScalarModeToUsePointFieldData();   \n        planeActor.setMapper(planeMapper);\n        planeActor.getProperty().setEdgeVisibility(true);\n\n        renderer.addActor(planeActor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 15.00, Matches: vtkCalculator, vtkMapper, vtkPlaneSource):\nDescription: Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n\n        console.log(planeSource.getOutputData().toJSON());\n\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                // array in is null here?\n                console.log(\"arraysIn:\", arraysIn());\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars\n        // so the plane mapper will color by 'temperature':\n        simpleFilter.setInputData(planeSource.getOutputData());\n        simpleFilter.update();\n        concole.log(simpleFilter.getOutputData());\n\n        //mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        //mapper.setOrientationArray('orientation');\n        //mapper.setScaleArray('pressure');\n\n        //actor.setMapper(mapper);\n\n       // renderer.addActor(actor);\n       // renderer.resetCamera();\n        //renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        // fullScreenRenderer.addController(controlPanel);\n        // ['xResolution', 'yResolution'].forEach((propertyName) => {\n        //     document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n        //         const value = Number(e.target.value);\n        //         console.log(\"propertyName\",propertyName);\n        //         console.log(\"value\",value);\n        //         planeSource.set({ [propertyName]: value });\n        //         renderWindow.render();\n        //     });\n        // });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 5 (Score: 15.00, Matches: vtkCalculator, vtkMapper, vtkPlaneSource):\nDescription: Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js StickMapper</title>\n    <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\">\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Geometry\"></script>\n    <script src=\"https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Molecule\"></script>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        mapper.setOrientationArray('orientation');\n        mapper.setScaleArray('pressure');\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 6 (Score: 10.00, Matches: vtkHttpDataSetReader, vtkMapper):\nDescription: Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.\n\nModules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const imageActorI = vtkImageSlice.newInstance();\n        const imageActorJ = vtkImageSlice.newInstance();\n        const imageActorK = vtkImageSlice.newInstance();\n\n        renderer.addActor(imageActorK);\n        renderer.addActor(imageActorJ);\n        renderer.addActor(imageActorI);\n\n        const reader = vtkHttpDataSetReader.newInstance({\n            fetchGzip: true,\n        });\n        reader\n            .setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData();\n                const dataRange = data.getPointData().getScalars().getRange();\n                const extent = data.getExtent();\n\n                const imageMapperK = vtkImageMapper.newInstance();\n                imageMapperK.setInputData(data);\n                imageMapperK.setKSlice(30);\n                imageActorK.setMapper(imageMapperK);\n\n                const imageMapperJ = vtkImageMapper.newInstance();\n                imageMapperJ.setInputData(data);\n                imageMapperJ.setJSlice(30);\n                imageActorJ.setMapper(imageMapperJ);\n\n                const imageMapperI = vtkImageMapper.newInstance();\n                imageMapperI.setInputData(data);\n                imageMapperI.setISlice(30);\n                imageActorI.setMapper(imageMapperI);\n\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n    </script>\n</body>\n\n</html>\n\n",
  "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
  "generator": "deepseek-v3",
  "evaluator": "deepseek-v3",
  "score": null,
  "workflow": {
    "inquiryExpansion": true,
    "rag": true
  },
  "eval_id": "1765334147",
  "eval_user": "test",
  "export_time": null,
  "console_output": null,
  "eval_time": "2025-12-10 10:35:47",
  "evaluator_evaluation": {
    "score": "0.2",
    "evaluator_evaluation": "```xml\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.2</Score>\n        <Reason>The generated code implements a different visualization approach (streamlines with outline) compared to the ground truth's isosurface rendering. Key elements like marching cubes and velocity magnitude calculation are missing.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.1</Score>\n        <Reason>The visual output would be fundamentally different - streamlines vs isosurfaces - with different coloring approaches and no velocity magnitude calculations.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.8</Score>\n        <Reason>The code is well-structured and follows vtk.js practices, though it solves a different problem than the ground truth.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.37</OverallScore>\n        <Critique>The generated code is well-written but fundamentally different from the requested isosurface visualization task.</Critique>\n    </Summary>\n</Evaluation>\n```",
    "parsed_evaluation": null
  },
  "options": null,
  "analysis": [
    {
      "phase": "Data Loading",
      "step_name": "Load Isabel Dataset",
      "vtk_modules": [
        "vtkHttpDataSetReader"
      ],
      "description": "Load the Isabel dataset from 'http://127.0.0.1:5000/dataset/isabel.vti' using vtkHttpDataSetReader."
    },
    {
      "phase": "Data Processing",
      "step_name": "Generate Seed Points",
      "vtk_modules": [
        "vtkPlaneSource",
        "vtkPointSource"
      ],
      "description": "Create seed points at the center of the dataset with sufficient density to cover the domain using vtkPointSource and define a plane as a seed surface using vtkPlaneSource."
    },
    {
      "phase": "Data Processing",
      "step_name": "Compute Streamlines",
      "vtk_modules": [
        "vtkImageStreamline",
        "vtkCalculator"
      ],
      "description": "Use vtkImageStreamline to compute streamlines following the velocity field, ensuring the 'Velocity' array is used as the vector field. Apply vtkCalculator if necessary to extract or prepare the velocity data."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Set Streamline Properties",
      "vtk_modules": [
        "vtkGlyph3DMapper",
        "vtkMapper"
      ],
      "description": "Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkGlyph3DMapper and set appropriate line properties for visual clarity."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Render Outline",
      "vtk_modules": [
        "vtkOutlineFilter",
        "vtkMapper"
      ],
      "description": "Apply vtkOutlineFilter to the dataset to generate an outline, then render it in red ([1, 0, 0]) with a specified line width using vtkMapper."
    },
    {
      "phase": "Rendering & Interaction",
      "step_name": "Render Scene",
      "vtk_modules": [
        "vtkRenderWindow",
        "vtkRenderer",
        "vtkRenderWindowInteractor"
      ],
      "description": "Initialize the render window, renderer, and interactor to display both the streamlines and the dataset outline together in the scene."
    }
  ],
  "retrieval_results": [
    {
      "id": 1619381550,
      "title": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageStreamline\\code.html",
      "description": "Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.\n",
      "relevance": 20.0,
      "matched_keywords": [
        "vtkImageStreamline",
        "vtkMapper",
        "vtkPlaneSource",
        "vtkOutlineFilter"
      ]
    },
    {
      "id": 105009849,
      "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-GlyphMapper\\code.html",
      "description": "Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n",
      "relevance": 20.0,
      "matched_keywords": [
        "vtkCalculator",
        "vtkMapper",
        "vtkGlyph3DMapper",
        "vtkPlaneSource"
      ]
    },
    {
      "id": 1276004285,
      "title": "data\\vtkjs-examples\\prompt-sample\\Filter-Calculator\\code.html",
      "description": "This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n",
      "relevance": 15.0,
      "matched_keywords": [
        "vtkCalculator",
        "vtkMapper",
        "vtkPlaneSource"
      ]
    },
    {
      "id": 771311485,
      "title": "data\\vtkjs-examples\\prompt-sample\\IO-StickMapper\\code.html",
      "description": "Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n",
      "relevance": 15.0,
      "matched_keywords": [
        "vtkCalculator",
        "vtkMapper",
        "vtkPlaneSource"
      ]
    },
    {
      "id": 1837944411,
      "title": "data\\vtkjs-examples\\prompt-sample\\Rendering-StickMapper\\code.html",
      "description": "Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom poin",
      "relevance": 15.0,
      "matched_keywords": [
        "vtkCalculator",
        "vtkMapper",
        "vtkPlaneSource"
      ]
    },
    {
      "id": 739470138,
      "title": "data\\vtkjs-examples\\prompt-sample\\Filter-MultiImageSlice\\code.html",
      "description": "Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.\n",
      "relevance": 10.0,
      "matched_keywords": [
        "vtkHttpDataSetReader",
        "vtkMapper"
      ]
    }
  ]
}