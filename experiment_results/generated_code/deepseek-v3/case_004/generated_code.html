<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Redsea Volume Rendering</title>
    <script src="https://unpkg.com/vtk.js@34.10.0/vtk.js"></script>
</head>
<body>
    <script>
        // Import required VTK modules
        const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0]
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // Create reader for VTI data
        const reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({ fetchGzip: true });
        reader.setUrl('http://127.0.0.1:5000/dataset/redsea.vti', { loadData: true })
            .then(() => {
                const dataset = reader.getOutputData();

                // Compute velocity magnitude from velocity array
                const velocityArray = dataset.getPointData().getArray('velocity');
                const velocityMagnitude = new Float32Array(velocityArray.getNumberOfTuples());
                
                for (let i = 0; i < velocityArray.getNumberOfTuples(); i++) {
                    const v = velocityArray.getTuple(i);
                    velocityMagnitude[i] = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
                }

                // Create new array for velocity magnitude and set as active scalar
                const magnitudeArray = vtk.Common.Core.vtkDataArray.newInstance({
                    name: 'velocityMagnitude',
                    values: velocityMagnitude,
                    numberOfComponents: 1
                });
                dataset.getPointData().addArray(magnitudeArray);
                dataset.getPointData().setActiveScalars('velocityMagnitude');

                // Get scalar range for color/opacity mapping
                const scalarRange = magnitudeArray.getRange();

                // Create color transfer function (blue-white-red)
                const colorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
                colorTransferFunction.addRGBPoint(scalarRange[0], 0, 0, 1); // Blue at min
                colorTransferFunction.addRGBPoint(
                    (scalarRange[0] + scalarRange[1]) / 2, 
                    1, 1, 1); // White at middle
                colorTransferFunction.addRGBPoint(scalarRange[1], 1, 0, 0); // Red at max

                // Create piecewise opacity function
                const opacityFunction = vtk.Common.DataModel.vtkPiecewiseFunction.newInstance();
                opacityFunction.addPoint(scalarRange[0], 0.0);
                opacityFunction.addPoint((scalarRange[0] + scalarRange[1]) * 0.2, 0.05);
                opacityFunction.addPoint((scalarRange[0] + scalarRange[1]) * 0.7, 0.2);
                opacityFunction.addPoint(scalarRange[1], 0.5);

                // Create volume mapper
                const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();
                mapper.setInputData(dataset);
                mapper.setSampleDistance(0.7);

                // Create volume actor and set properties
                const actor = vtk.Rendering.Core.vtkVolume.newInstance();
                actor.setMapper(mapper);
                
                const property = actor.getProperty();
                property.setRGBTransferFunction(0, colorTransferFunction);
                property.setScalarOpacity(0, opacityFunction);
                property.setInterpolationTypeToLinear();
                property.setShade(true);
                property.setAmbient(0.3);
                property.setDiffuse(0.7);
                property.setSpecular(0.4);
                property.setSpecularPower(20);

                // Add actor to renderer
                renderer.addVolume(actor);

                // Adjust camera to look along +Z and center on dataset
                const center = dataset.getCenter();
                renderer.resetCamera();
                const camera = renderer.getActiveCamera();
                camera.setPosition(
                    center[0], 
                    center[1], 
                    center[2] + 2*Math.max(...dataset.getBounds().slice(1))
                );
                camera.setFocalPoint(center[0], center[1], center[2]);
                camera.setViewUp(0, 1, 0);

                renderWindow.render();
            });
    </script>
</body>
</html>