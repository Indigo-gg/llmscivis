<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTK.js Deepwater Isosurface Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://unpkg.com/vtk.js@34.10.0/vtk.js"></script>
    <script>
        // Load required VTK modules
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;
        
        // Create render window
        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            rootContainer: document.querySelector('#container'),
            background: [0.2, 0.2, 0.2]
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // Create reader to load dataset
        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });
        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {
            // Load the data
            return reader.loadData();
        }).then(() => {
            const originalData = reader.getOutputData();
            
            // Create calculator to compute velocity magnitude if v02 and v03 exist, otherwise use prs
            const calculator = vtkCalculator.newInstance();
            calculator.setInputData(originalData);
            
            // Check if velocity components exist
            const pointData = originalData.getPointData();
            const hasVelocity = pointData.getArrayByName('v02') && pointData.getArrayByName('v03');
            
            if (hasVelocity) {
                // Calculate velocity magnitude: sqrt(v02^2 + v03^2)
                calculator.setFormulaSimple(
                    vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes.SCALARS,
                    ['v02', 'v03'],
                    'magnitude',
                    (v02, v03) => Math.sqrt(v02 * v02 + v03 * v03)
                );
            } else {
                // Use prs array as scalar if velocity components don't exist
                calculator.setFormulaSimple(
                    vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes.SCALARS,
                    ['prs'],
                    'magnitude',
                    (prs) => prs
                );
            }
            
            // Process the data
            calculator.update();
            const data = calculator.getOutputData();
            const scalarRange = data.getPointData().getScalars().getRange();
            
            // Create color transfer function (blue -> white -> red)
            const lookupTable = vtkColorTransferFunction.newInstance();
            lookupTable.addRGBPoint(scalarRange[0], 0, 0, 1); // Blue at min
            lookupTable.addRGBPoint((scalarRange[0] + scalarRange[1]) / 2, 1, 1, 1); // White at mid
            lookupTable.addRGBPoint(scalarRange[1], 1, 0, 0); // Red at max
            
            // Create mapper for isosurface
            const mapper = vtkMapper.newInstance();
            mapper.setInputData(data);
            mapper.setLookupTable(lookupTable);
            mapper.setScalarRange(scalarRange[0], scalarRange[1]);
            
            // Create isosurface actor
            const actor = vtkActor.newInstance();
            actor.setMapper(mapper);
            
            // Set isosurface properties
            const isovalue = (scalarRange[0] + scalarRange[1]) / 2; // Mid-value isosurface
            const property = actor.getProperty();
            property.setRepresentationToSurface();
            property.setInterpolationToPhong(); // Smooth shading
            property.setOpacity(1.0); // Fully opaque
            property.setLighting(true);
            
            // Generate isosurface using contour filter from mapper
            // Note: VTK.js mapper handles isosurface generation internally when setting this property
            mapper.setScalarModeToUsePointData();
            mapper.setUseLookupTableScalarRange(true);
            
            // Add actor to renderer
            renderer.addActor(actor);
            
            // Add orientation marker
            const axes = vtk.Rendering.Core.vtkAnnotatedCubeActor.newInstance();
            axes.setDefaultStyle({
                text: '+X',
                fontStyle: 'bold',
                fontFamily: 'Arial',
                fontColor: [0, 0, 0],
                fontSizeScale: (res) => res / 2,
                faceColor: '#FF0000',
                faceRotation: 0,
                edgeThickness: 0.1,
                edgeColor: [0, 0, 0],
            });
            axes.setXPlusFaceProperty({
                text: '+X',
                faceColor: '#FF0000',
            });
            axes.setXMinusFaceProperty({
                text: '-X',
                faceColor: '#A00000',
            });
            axes.setYPlusFaceProperty({
                text: '+Y',
                faceColor: '#00FF00',
            });
            axes.setYMinusFaceProperty({
                text: '-Y',
                faceColor: '#00A000',
            });
            axes.setZPlusFaceProperty({
                text: '+Z',
                faceColor: '#0000FF',
            });
            axes.setZMinusFaceProperty({
                text: '-Z',
                faceColor: '#0000A0',
            });
            
            const orientationWidget = vtkOrientationMarkerWidget.newInstance({
                actor: axes,
                interactor: renderWindow.getInteractor(),
            });
            orientationWidget.setEnabled(true);
            orientationWidget.setViewportCorner(
                vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
            );
            orientationWidget.setViewportSize(0.15);
            
            // Add outline for context
            const outline = vtkOutlineFilter.newInstance();
            outline.setInputData(data);
            const outlineMapper = vtkMapper.newInstance();
            outlineMapper.setInputConnection(outline.getOutputPort());
            const outlineActor = vtkActor.newInstance();
            outlineActor.setMapper(outlineMapper);
            outlineActor.getProperty().setColor(1, 1, 1);
            renderer.addActor(outlineActor);
            
            // Reset camera and render
            renderer.resetCamera();
            renderWindow.render();
        });
    </script>
</body>
</html>