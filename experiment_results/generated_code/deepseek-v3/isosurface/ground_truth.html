<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Isosurface Rendering for Deepwater Dataset</title>
<style>
body,
html {
margin: 0;
padding: 0;
width: 100%;
height: 100%;
overflow: hidden;
}

#renderer {
width: 100%;
height: 100%;
}
</style>
</head>

<body>
<div id="renderer"></div>
<script src="https://unpkg.com/vtk.js"></script>
<script>
const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
const vtkActor = vtk.Rendering.Core.vtkActor;
const vtkMapper = vtk.Rendering.Core.vtkMapper;
const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;

const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
background: [1,1,1],
});
const renderWindow = fullScreenRenderWindow.getRenderWindow();
const renderer = fullScreenRenderWindow.getRenderer();

const reader = vtkXMLImageDataReader.newInstance();
reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {
reader.loadData().then(() => {
const imageData = reader.getOutputData(0);

// Output array names in the dataset to help with debugging
// Fix: getArrayNames is not a function, use getArrays() to get the array list
const arrays = imageData.getPointData().getArrays();
const arrayNames = arrays.map(array => array.getName());
console.log('Arrays in dataset:', arrayNames);

// Use v02 and v03 arrays to calculate velocity magnitude
const v02Array = imageData.getPointData().getArrayByName('v02');
const v03Array = imageData.getPointData().getArrayByName('v03');

if (!v02Array || !v03Array) {
console.error('Cannot find v02 or v03 arrays');
// Try to use another available array
const availableArray = imageData.getPointData().getArrayByName('prs');
if (availableArray) {
// Directly use pressure (prs) array as scalar field
imageData.getPointData().setActiveScalars('prs');
} else {
console.error('Unable to find suitable array for rendering');
return;
}
} else {
// Calculate velocity magnitude
const numPoints = imageData.getNumberOfPoints();
const magnitudeData = new Float64Array(numPoints);

for (let i = 0; i < numPoints; i++) {
// v02 and v03 are scalar arrays, directly get values
const v2 = v02Array.getData()[i];
const v3 = v03Array.getData()[i];
// Calculate velocity magnitude
magnitudeData[i] = Math.sqrt(v2 * v2 + v3 * v3);
}

// Create velocity magnitude array
const vtkDataArray = vtk.Common.Core.vtkDataArray;
const magnitudeVtkArray = vtkDataArray.newInstance({
numberOfComponents: 1,
values: magnitudeData,
name: 'velocityMagnitude',
});
imageData.getPointData().addArray(magnitudeVtkArray);
imageData.getPointData().setActiveScalars('velocityMagnitude');
}

// Get range of current active scalar
const activeScalars = imageData.getPointData().getScalars();
const newRange = activeScalars.getRange();
const [minV, maxV] = newRange;

console.log('Using scalar field:', activeScalars.getName());
console.log('Data range:', newRange);

const marchingCube = vtkImageMarchingCubes.newInstance({
contourValue: minV + 0.5 * (maxV - minV),
computeNormals: true,
mergePoints: true
});

marchingCube.setInputData(imageData);

const mapper = vtkMapper.newInstance();
mapper.setInputConnection(marchingCube.getOutputPort());

const colorTransferFunction = vtkColorTransferFunction.newInstance();
colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);
colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);
colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);
colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);
colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);

mapper.setLookupTable(colorTransferFunction);
mapper.setScalarRange(minV, maxV);
mapper.setInterpolateScalarsBeforeMapping(true);

const actor = vtkActor.newInstance();
actor.setMapper(mapper);
actor.getProperty().setRepresentationToSurface();
actor.getProperty().setEdgeVisibility(false);
actor.getProperty().setOpacity(1.0);
actor.getProperty().setAmbient(0.3);
actor.getProperty().setDiffuse(0.7);
actor.getProperty().setSpecular(0.4);

renderer.addActor(actor);

const bounds = imageData.getBounds();
const center = [
(bounds[0] + bounds[1]) / 2,
(bounds[2] + bounds[3]) / 2,
(bounds[4] + bounds[5]) / 2,
];

const camera = renderer.getActiveCamera();
camera.setFocalPoint(...center);
camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);
camera.setViewUp(0, 0, 1);
renderer.resetCameraClippingRange();
renderWindow.render();
renderer.resetCamera();
renderWindow.render();

const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();
const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({
actor: axes,
interactor: renderWindow.getInteractor(),
});
widget.setEnabled(true);
widget.setViewportCorner(
vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
);
widget.setViewportSize(0.15);
widget.setMinPixelSize(100);
widget.setMaxPixelSize(300);

const interactor = renderWindow.getInteractor();
interactor.start();
});
});
</script>
</body>

</html>