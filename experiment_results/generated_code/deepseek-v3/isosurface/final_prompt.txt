
Generate only the HTML code without any additional text.
User Requirements:
Generate an HTML page using vtk.js to visualize the Deepwater dataset with isosurface rendering.

Load the dataset from: http://127.0.0.1:5000/dataset/deepwater.vti

Compute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar

Generate an isosurface at the mid-value of the scalar range

Use a blue → white → red color map spanning the scalar range (min to max)

Set the isosurface to fully opaque with smooth shading

Add an XYZ orientation marker in the bottom-right corner

Relevant VTK.js Examples:

--------------------------------------------------------------------------------Example 1 (Score: 10.00, Matches: vtkHTTPDataSetReader, vtkHttpDataSetReader):
Description: Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.

Modules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const imageActorI = vtkImageSlice.newInstance();
        const imageActorJ = vtkImageSlice.newInstance();
        const imageActorK = vtkImageSlice.newInstance();

        renderer.addActor(imageActorK);
        renderer.addActor(imageActorJ);
        renderer.addActor(imageActorI);

        const reader = vtkHttpDataSetReader.newInstance({
            fetchGzip: true,
        });
        reader
            .setUrl(dataPath, { loadData: true })
            .then(() => {
                const data = reader.getOutputData();
                const dataRange = data.getPointData().getScalars().getRange();
                const extent = data.getExtent();

                const imageMapperK = vtkImageMapper.newInstance();
                imageMapperK.setInputData(data);
                imageMapperK.setKSlice(30);
                imageActorK.setMapper(imageMapperK);

                const imageMapperJ = vtkImageMapper.newInstance();
                imageMapperJ.setInputData(data);
                imageMapperJ.setJSlice(30);
                imageActorJ.setMapper(imageMapperJ);

                const imageMapperI = vtkImageMapper.newInstance();
                imageMapperI.setInputData(data);
                imageMapperI.setISlice(30);
                imageActorI.setMapper(imageMapperI);

                renderer.resetCamera();
                renderWindow.render();
            });
    </script>
</body>

</html>

Example 2 (Score: 10.00, Matches: vtkHTTPDataSetReader, vtkHttpDataSetReader):
Description: Loads and visualizes a 3D model (VTP format) from a remote URL using `vtkHttpDataSetReader` with gzip support.

Modules: vtk.IO.Core.DataAccessHelper.HttpDataAccessHelper, vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow, vtk.Rendering.OpenGL.Profiles.Geometry
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js IO-HttpDataSetReader</title>
</head>

<body>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const data_path = 'http://kitware.github.io/vtk-js/data/cow.vtp'
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        // const vtkGeometry = vtk.Rendering.OpenGL.Profiles.Geometry

        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkActor = vtk.Rendering.Core.vtkActor
        const vtkMapper = vtk.Rendering.Core.vtkMapper

        // Force the loading of HttpDataAccessHelper to support gzip decompression
        const vtkHttpDataAccessHelper = vtk.IO.Core.DataAccessHelper.HttpDataAccessHelper

        // ----------------------------------------------------------------------------
        // Standard rendering code setup
        // ----------------------------------------------------------------------------

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance();
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // ----------------------------------------------------------------------------
        // Example code
        // ----------------------------------------------------------------------------
        // Server is not sending the .gz and with the compress header
        // Need to fetch the true file name and uncompress it locally
        // ----------------------------------------------------------------------------

        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });
        reader.setUrl(data_path).then(() => {
            reader.loadData().then(() => {
                renderer.resetCamera();
                renderWindow.render();
            });
        });

        const mapper = vtkMapper.newInstance();
        mapper.setInputConnection(reader.getOutputPort());

        const actor = vtkActor.newInstance();
        actor.setMapper(mapper);

        renderer.addActor(actor);

        // -----------------------------------------------------------
        // Make some variables global so that you can inspect and
        // modify objects in your browser's developer console:
        // -----------------------------------------------------------

        // global.source = reader;
        // global.mapper = mapper;
        // global.actor = actor;
        // global.renderer = renderer;
        // global.renderWindow = renderWindow;

    </script>
</body>

</html>

Example 3 (Score: 10.00, Matches: vtkHTTPDataSetReader, vtkHttpDataSetReader):
Description: Loads 3D polydata, writes it to a string using `vtkXMLPolyDataWriter`, reads it back with `vtkXMLPolyDataReader`, and renders it, allowing download of the generated VTP file.
Modules: vtk.IO.Core.vtkHttpDataSetReader, vtk.IO.XML.vtkXMLPolyDataReader, vtk.IO.XML.vtkXMLPolyDataWriter, vtk.IO.XML.vtkXMLWriter, vtk.Rendering.Core.vtkActor.newInstance, vtk.Rendering.Core.vtkMapper.newInstance, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js XMLImagePolyDataWriter</title>
    <!-- <link rel="stylesheet" href="https://kit.fontawesome.com/419a5ebb56.css" crossorigin="anonymous"> -->
</head>

<body>
    <div id="renderer"></div>

    <script type="text/javascript" src="https://unpkg.com/@babel/polyfill@7.0.0/dist/polyfill.js"></script>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
        const actor = vtk.Rendering.Core.vtkActor.newInstance();
        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const httpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const xmlPolyDataWriter = vtk.IO.XML.vtkXMLPolyDataWriter;
        const xmlPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;
        const xmlWriter = vtk.IO.XML.vtkXMLWriter;
        // Create instances using namespace paths
        const fullScreenRenderer = fullScreenRenderWindow.newInstance();
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();
        const reader = httpDataSetReader.newInstance({ fetchGzip: true });

        const writer = xmlPolyDataWriter.newInstance();
        writer.setFormat(xmlWriter.FormatTypes.BINARY);
        writer.setInputConnection(reader.getOutputPort());

        const writerReader = xmlPolyDataReader.newInstance();

        reader.setUrl(`http://kitware.github.io/vtk-js/data/cow.vtp`, { loadData: true }).then(() => {
            const fileContents = writer.write(reader.getOutputData());

            // Try to read it back.
            const textEncoder = new TextEncoder();
            writerReader.parseAsArrayBuffer(textEncoder.encode(fileContents));
            renderer.resetCamera();
            renderWindow.render();

            const blob = new Blob([fileContents], { type: 'text/plain' });
            const a = window.document.createElement('a');
            a.href = window.URL.createObjectURL(blob, { type: 'text/plain' });
            a.download = 'cow.vtp';
            a.text = 'Download';
            a.style.position = 'absolute';
            a.style.left = '50%';
            a.style.bottom = '10px';
            document.body.appendChild(a);
            a.style.background = 'white';
            a.style.padding = '5px';
        });

        actor.setMapper(mapper);

        mapper.setInputConnection(writerReader.getOutputPort());

        renderer.addActor(actor);

        window.writer = writer;
        window.writerReader = writerReader;
        window.mapper = mapper;
        window.actor = actor;
        window.renderer = renderer;
        window.renderWindow = renderWindow;


    </script>

</body>

</html>

Example 4 (Score: 10.00, Matches: vtkHTTPDataSetReader, vtkHttpDataSetReader):
Description: Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.

Modules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js Isosurface Visualization</title>
    <link rel="stylesheet" href="https://kit.fontawesome.com/419a5ebb56.css" crossorigin="anonymous">
    <style>
        #renderer {
            width: 100%;
            height: 600px;
            background-color: #333;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <!-- Set vtk.js favicon -->
    <script type="module" src="https://unpkg.com/vtk.js/favicon.js"></script>

    <!-- Load WebGL and WebGPU rendering modules -->
    <script type="module" src="https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Volume.js"></script>

    <!-- Force DataAccessHelper to access various data sources -->
    <script type="module"
        src="https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper.js"></script>
    <script type="module"
        src="https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper.js"></script>
    <script type="module"
        src="https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js"></script>

    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const path = 'http://kitware.github.io/vtk-js/data'

        // Reference HTML template
        const controlPanel = `<table>
    <tr>
        <td>Slice I</td>
        <td>
            <input class='sliceI' type="range" min="0" max="2.0" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>Slice J</td>
        <td>
            <input class='sliceJ' type="range" min="0" max="2.0" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>Slice K</td>
        <td>
            <input class='sliceK' type="range" min="0" max="100" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>Color level</td>
        <td>
            <input class='colorLevel' type="range" min="-3926" max="3926" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>ColorWindow</td>
        <td>
            <input class='colorWindow' type="range" min="0" max="3926" step="1" value="1" />
        </td>
    </tr>
</table>
`;
        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();
        fullScreenRenderWindow.addController(controlPanel);

        const imageActorI = vtkImageSlice.newInstance();
        const imageActorJ = vtkImageSlice.newInstance();
        const imageActorK = vtkImageSlice.newInstance();

        renderer.addActor(imageActorK);
        renderer.addActor(imageActorJ);
        renderer.addActor(imageActorI);

        function updateColorLevel(e) {
            const colorLevel = Number(
                (e ? e.target : document.querySelector('.colorLevel')).value
            );
            imageActorI.getProperty().setColorLevel(colorLevel);
            imageActorJ.getProperty().setColorLevel(colorLevel);
            imageActorK.getProperty().setColorLevel(colorLevel);
            renderWindow.render();
        }

        function updateColorWindow(e) {
            const colorLevel = Number(
                (e ? e.target : document.querySelector('.colorWindow')).value
            );
            imageActorI.getProperty().setColorWindow(colorLevel);
            imageActorJ.getProperty().setColorWindow(colorLevel);
            imageActorK.getProperty().setColorWindow(colorLevel);
            renderWindow.render();
        }

        const reader = vtkHttpDataSetReader.newInstance({
            fetchGzip: true,
        });
        reader
            .setUrl(`${path}/data/volume/headsq.vti`, { loadData: true })
            .then(() => {
                const data = reader.getOutputData();
                const dataRange = data.getPointData().getScalars().getRange();
                const extent = data.getExtent();

                const imageMapperK = vtkImageMapper.newInstance();
                imageMapperK.setInputData(data);
                imageMapperK.setKSlice(30);
                imageActorK.setMapper(imageMapperK);

                const imageMapperJ = vtkImageMapper.newInstance();
                imageMapperJ.setInputData(data);
                imageMapperJ.setJSlice(30);
                imageActorJ.setMapper(imageMapperJ);

                const imageMapperI = vtkImageMapper.newInstance();
                imageMapperI.setInputData(data);
                imageMapperI.setISlice(30);
                imageActorI.setMapper(imageMapperI);

                renderer.resetCamera();
                renderer.resetCameraClippingRange();
                renderWindow.render();

                ['.sliceI', '.sliceJ', '.sliceK'].forEach((selector, idx) => {
                    const el = document.querySelector(selector);
                    el.setAttribute('min', extent[idx * 2 + 0]);
                    el.setAttribute('max', extent[idx * 2 + 1]);
                    el.setAttribute('value', 30);
                });

                ['.colorLevel', '.colorWindow'].forEach((selector) => {
                    document.querySelector(selector).setAttribute('max', dataRange[1]);
                    document.querySelector(selector).setAttribute('value', dataRange[1]);
                });
                document
                    .querySelector('.colorLevel')
                    .setAttribute('value', (dataRange[0] + dataRange[1]) / 2);
                updateColorLevel();
                updateColorWindow();
            });

        document.querySelector('.sliceI').addEventListener('input', (e) => {
            imageActorI.getMapper().setISlice(Number(e.target.value));
            renderWindow.render();
        });

        document.querySelector('.sliceJ').addEventListener('input', (e) => {
            imageActorJ.getMapper().setJSlice(Number(e.target.value));
            renderWindow.render();
        });

        document.querySelector('.sliceK').addEventListener('input', (e) => {
            imageActorK.getMapper().setKSlice(Number(e.target.value));
            renderWindow.render();
        });

        document
            .querySelector('.colorLevel')
            .addEventListener('input', updateColorLevel);
        document
            .querySelector('.colorWindow')
            .addEventListener('input', updateColorWindow);

        window.fullScreen = fullScreenRenderWindow;
        window.imageActorI = imageActorI;
        window.imageActorJ = imageActorJ;
        window.imageActorK = imageActorK;

    </script>
</body>

</html>

Example 5 (Score: 5.00, Matches: vtkCalculator):
Description: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.

Modules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // using vtk namespace
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;
        const vtkPoints = vtk.Common.Core.vtkPoints;
        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;

        // ----------------------------------------------------------------------------
        // Standard rendering code setup
        // ----------------------------------------------------------------------------

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // setting vtkCalculator and set formula

        const simpleFilter = vtkCalculator.newInstance();

        simpleFilter.setFormulaSimple(
            FieldDataTypes.POINT, // Generate an output array defined over points.
            [], // We don't request any point-data arrays because point coordinates are made available by default.
            'outputArray', // Name the output array 
            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125
        ); 

        //using plane source to generate a poly data which can be rendered by vtkActor
        const planeSource = vtkPlaneSource.newInstance({
            xResolution: 25,
            yResolution: 25,
        });

        const sourceData = planeSource.getOutputData();

        simpleFilter.setInputData(sourceData);
        const planeActor = vtkActor.newInstance();
        const planeMapper = vtkMapper.newInstance();
        planeMapper.setInputData(simpleFilter.getOutputData());
        planeMapper.setColorByArrayName('outputArray'); 

        planeMapper.setScalarModeToUsePointFieldData();   
        planeActor.setMapper(planeMapper);
        planeActor.getProperty().setEdgeVisibility(true);

        renderer.addActor(planeActor);
        renderer.resetCamera();
        renderWindow.render();
    </script>
</body>

</html>

Example 6 (Score: 5.00, Matches: vtkCalculator):
Description: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.

Modules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js ImageLabelOutline</title>
    <style>
        #renderer {
            width: 100%;
            height: 600px;
            background-color: #333;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // Use the vtk namespace to reference each class
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const vtkImageData = vtk.Common.DataModel.vtkImageData;
        const vtkDataArray = vtk.Common.Core.vtkDataArray;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;

        // Use the vtk namespace to reference constants
        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0.5, 0.5, 0.5],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const BACKGROUND = 0;
        const LOW_VALUE = 80;
        const HIGH_VALUE = 160;

        const FIRST_SEGMENT = 1;
        const SECOND_SEGMENT = 5;

        /**
         * Creates a labelmap image with the same dimensions as the background volume.
         * @param {vtkImageData} backgroundImageData - The background volume data.
         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.
         */
        function createLabelmap(backgroundImageData) {
            // Create a labelmap image the same dimensions as our background volume.
            const labelMapData = vtkImageData.newInstance(
                backgroundImageData.get('spacing', 'origin', 'direction')
            );

            labelMapData.computeTransforms();

            const dataArray = vtkDataArray.newInstance({
                numberOfComponents: 1,
                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),
            });
            labelMapData.getPointData().setScalars(dataArray);

            labelMapData.setDimensions(...backgroundImageData.getDimensions());
            labelMapData.setSpacing(...backgroundImageData.getSpacing());
            labelMapData.setOrigin(...backgroundImageData.getOrigin());
            labelMapData.setDirection(...backgroundImageData.getDirection());
            const mapper = vtkImageMapper.newInstance();
            mapper.setInputData(labelMapData);

            const actor = vtkImageSlice.newInstance();

            actor.setMapper(mapper);

            const labelMap = {
                actor,
                mapper,
                imageData: labelMapData,
                cfun: vtkColorTransferFunction.newInstance(),
                ofun: vtkPiecewiseFunction.newInstance(),
            };

            // Labelmap pipeline
            labelMap.mapper.setInputData(labelMapData);
            labelMap.actor.setMapper(labelMap.mapper);

            // Set up labelMap color and opacity mapping
            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label "1" will be red
            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label "1" will be red
            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label "5" will be green
            labelMap.ofun.addPoint(0, 0);
            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.
            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.

            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);
            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);
            labelMap.actor.getProperty().setInterpolationTypeToNearest();

            labelMap.actor.getProperty().setUseLabelOutline(true);
            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4
            // (positioned at array index 4)
            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);
            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);

            // This is very important to make sure the labelmap is rendered
            // correctly
            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);

            const dims = labelMap.imageData.getDimensions();
            const values = labelMap.imageData.getPointData().getScalars().getData();

            const backgroundValues = backgroundImageData
                .getPointData()
                .getScalars()
                .getData();
            const size = dims[0] * dims[1] * dims[2];

            for (let i = 0; i < size; i++) {
                if (backgroundValues[i] === LOW_VALUE) {
                    values[i] = FIRST_SEGMENT;
                } else if (backgroundValues[i] === HIGH_VALUE) {
                    values[i] = SECOND_SEGMENT;
                }
            }

            labelMap.imageData.getPointData().getScalars().setData(values);

            return labelMap;
        }

        // Create a one slice vtkImageData that has four quadrants of different values
        const imageData = vtkImageData.newInstance();
        const dims = [10, 10, 1];
        imageData.setSpacing(1, 1, 1);
        imageData.setOrigin(0.1, 0.1, 0.1);
        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);
        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);

        imageData.computeTransforms();

        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);

        let i = 0;
        for (let y = 0; y < dims[1]; y++) {
            for (let x = 0; x < dims[0]; x++, i++) {
                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {
                    values[i] = BACKGROUND;
                } else if (x > 4 && x < 6 && y > 4 && y < 7) {
                    values[i] = LOW_VALUE;
                } else {
                    values[i] = HIGH_VALUE;
                }
            }
        }

        const dataArray = vtkDataArray.newInstance({
            numberOfComponents: 1,
            values,
        });
        imageData.getPointData().setScalars(dataArray);
        imageData.modified();

        const data = imageData;
        const labelMap = createLabelmap(data);

        const actor = vtkImageSlice.newInstance();
        const mapper = vtkImageMapper.newInstance();
        mapper.setInputData(data);
        actor.setMapper(mapper);
        actor.getProperty().setInterpolationTypeToNearest();

        renderer.addActor(actor);
        renderer.addActor(labelMap.actor);
        renderer.resetCamera();
        renderer.resetCameraClippingRange();
        renderWindow.render();

        window.fullScreen = fullScreenRenderWindow;

    </script>
</body>

</html>

