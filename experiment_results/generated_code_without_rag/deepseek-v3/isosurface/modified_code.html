<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTK.js Deepwater Isosurface Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // Force loading of required modules
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;
        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [1, 1, 1],
        });
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();
        const reader = vtkXMLImageDataReader.newInstance();
        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {
            const dataset = reader.getOutputData();
            // Check available arrays and select scalar field
            const pointData = dataset.getPointData();
            let scalarArray;
            const calculator = vtk.Filters.General.vtkCalculator.newInstance();
            if (pointData.getArrayByName('v02') && pointData.getArrayByName('v03')) {
                // Create calculator to compute velocity magnitude from v02 and v03
                calculator.setInputData(dataset);
                calculator.setFormula({
                getArrays: (inputDataSets) => {
                    const nPts = inputDataSets[0].getNumberOfPoints();
                    return {
                    input: [
                        { location: FieldDataTypes.POINT, name: 'v02' },
                        { location: FieldDataTypes.POINT, name: 'v03' },
                    ],
                    output: [{
                        location: FieldDataTypes.POINT,
                        name: 'velocityMagnitude',
                        dataType: 'Float32Array',
                        numberOfComponents: 1,
                        tuples: nPts,
                        size: nPts,
                    }],
                    };
                },
                evaluate: (arraysIn, arraysOut) => {
                    const [v02, v03] = arraysIn.map(d => d.getData());
                    const [velocityMag] = arraysOut.map(d => d.getData());
                    for (let i = 0; i < velocityMag.length; i++) {
                        velocityMag[i] = Math.sqrt(v02[i] * v02[i] + v03[i] * v03[i]);
                    }
                    arraysOut.forEach(x => x.modified());
                }
                });
                calculator.update();
                scalarArray = calculator.getOutputData().getPointData().getArrayByName('velocityMagnitude');
            } else if (pointData.getArrayByName('prs')) {
                scalarArray = pointData.getArrayByName('prs');
            } else {
                throw new Error('No suitable scalar arrays found');
            }

            // Get scalar range for isosurface and colormap
            const computedData = calculator.getOutputData();
            computedData.getPointData().setActiveScalars('velocityMagnitude');
            const scalarRange = scalarArray.getRange();
            console.log('Scalar range:', scalarRange);
            const [minV, maxV] = scalarRange;
            console.log(scalarArray.toJSON());
            // Create contour filter (isosurface)
            const marchingCube = vtkImageMarchingCubes.newInstance({
                contourValue: minV + 0.5 * (maxV - minV),
                computeNormals: true,
                mergePoints: true
            });
            marchingCube.setInputData(computedData);

            // Create color transfer function (blue -> white -> red)
            const colorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
            colorTransferFunction.addRGBPoint(scalarRange[0], 0, 0, 1); // Blue at min
            colorTransferFunction.addRGBPoint((scalarRange[0] + scalarRange[1]) / 2, 1, 1, 1); // White at mid
            colorTransferFunction.addRGBPoint(scalarRange[1], 1, 0, 0); // Red at max

            // Create mapper and actor
            const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
            mapper.setInputConnection(marchingCube.getOutputPort());
            mapper.setScalarModeToUsePointFieldData();
            mapper.setScalarRange(scalarRange[0], scalarRange[1]);
            mapper.setLookupTable(colorTransferFunction);
            mapper.setUseLookupTableScalarRange(true);
            mapper.setInterpolateScalarsBeforeMapping(true);

            const actor = vtk.Rendering.Core.vtkActor.newInstance();
            actor.setMapper(mapper);
            actor.getProperty().setOpacity(1.0); // Fully opaque
            actor.getProperty().setLighting(true); // Enable lighting
            actor.getProperty().setDiffuse(1.0); // Smooth shading
            actor.getProperty().setAmbient(0.2);
            actor.getProperty().setSpecular(0.5);
            actor.getProperty().setSpecularPower(20);
            renderer.addActor(actor);

            // Add orientation marker
            const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();
            const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({
                actor: axes,
                interactor: renderWindow.getInteractor(),
            });
            widget.setEnabled(true);
            widget.setViewportCorner(
                vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
            );
            widget.setViewportSize(0.15);
            widget.setMinPixelSize(100);
            widget.setMaxPixelSize(300);

            const interactor = renderWindow.getInteractor();
            renderer.resetCamera();
            renderer.resetCameraClippingRange();
            renderWindow.render();
            interactor.start();
        });
    </script>
</body>
</html>