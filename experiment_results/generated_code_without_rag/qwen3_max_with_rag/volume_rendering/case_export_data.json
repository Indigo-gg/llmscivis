{
  "path": "",
  "name": "",
  "prompt": "Generate an HTML page using vtk.js to visualize the Redsea dataset with volume rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/redsea.vti_x000d_\n_x000d_\nCompute velocity magnitude from the \"velocity\" array and set it as the active scalar_x000d_\n_x000d_\nApply volume rendering using a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nApply a piecewise opacity function to control transparency across scalar values_x000d_\n_x000d_\nSet shading, ambient, diffuse, and specular properties for realistic volume appearance_x000d_\n_x000d_\nAdjust the camera to look along +Z and center on the dataset",
  "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>redsea Example</title>_x000d_\n<script src=\"https://unpkg.com/vtk.js\"></script>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<div id=\"renderer\"></div>_x000d_\n<!-- <script src=\"https://unpkg.com/vtk.js\"></script> -->_x000d_\n<script>_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkVolume = vtk.Rendering.Core.vtkVolume;_x000d_\nconst vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;_x000d_\n_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\nconst vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\n_x000d_\n//init the render window_x000d_\nconst fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [1,1,1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\n_x000d_\n// Load dataset_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\n_x000d_\n_x000d_\n// set url and load the data_x000d_\nreader.setUrl('http://127.0.0.1:5000/dataset/redsea.vti').then(() => {_x000d_\nreader.loadData().then(() => {_x000d_\n//prepare dataset_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\n//set active scalar_x000d_\nconst velocityArray = imageData.getPointData().getArrayByName('velocity');_x000d_\nconst numPoints = imageData.getNumberOfPoints();_x000d_\nconst magnitudeData = new Float64Array(numPoints);_x000d_\nfor (let i = 0; i < numPoints; i++) {_x000d_\nconst vx = velocityArray.getData()[3 * i + 0];_x000d_\nconst vy = velocityArray.getData()[3 * i + 1];_x000d_\nconst vz = velocityArray.getData()[3 * i + 2];_x000d_\nmagnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);_x000d_\n}_x000d_\n_x000d_\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;_x000d_\nconst magnitudeVtkArray = vtkDataArray.newInstance({_x000d_\nnumberOfComponents: 1,_x000d_\nvalues: magnitudeData,_x000d_\nname: 'velocityMagnitude',_x000d_\n});_x000d_\nimageData.getPointData().addArray(magnitudeVtkArray);_x000d_\nconsole.log(imageData.toJSON())_x000d_\n_x000d_\n_x000d_\nimageData.getPointData().setActiveScalars('velocityMagnitude');_x000d_\nimageData.setSpacing(0.05, 0.05, 0.1);_x000d_\n_x000d_\nconsole.log('New bounds:', imageData.getBounds());_x000d_\nconsole.log('Dimensions:', imageData.getDimensions());_x000d_\nconsole.log('Spacing:', imageData.getSpacing());_x000d_\n_x000d_\nconst newRange = magnitudeVtkArray.getRange();_x000d_\nconsole.log('velocityMagnitude range:', newRange);_x000d_\nconst [minV, maxV] = newRange;_x000d_\n_x000d_\n_x000d_\nconsole.log(imageData.getPointData().getScalars().getName());_x000d_\n_x000d_\n_x000d_\n//create the mapper and set its property_x000d_\nconst mapper = vtkVolumeMapper.newInstance();_x000d_\n//console.log(data.toJSON())_x000d_\nmapper.setMaximumSamplesPerRay(4000); // or even higher, up to your hardware limits_x000d_\nmapper.setInputData(imageData);_x000d_\nmapper.setSampleDistance(0.1);_x000d_\n_x000d_\n//create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc._x000d_\nconst actor = vtkVolume.newInstance();_x000d_\n_x000d_\n// Move LocalAmbientOcclusion properties to actor's property_x000d_\nactor.getProperty().setLocalAmbientOcclusion(0);_x000d_\nactor.getProperty().setLAOKernelSize(10);_x000d_\nactor.getProperty().setLAOKernelRadius(5);_x000d_\n// Move ComputeNormalFromOpacity to actor's property_x000d_\nactor.getProperty().setComputeNormalFromOpacity(true);_x000d_\n_x000d_\nconst cfun = vtkColorTransferFunction.newInstance();_x000d_\ncfun.addRGBPoint(minV, 0.0, 0.0, 1.0);_x000d_\ncfun.addRGBPoint((minV + maxV) * 0.5, 1.0, 1.0, 1.0);_x000d_\ncfun.addRGBPoint(maxV, 1.0, 0.0, 0.0);_x000d_\nactor.getProperty().setRGBTransferFunction(0, cfun);_x000d_\n_x000d_\nconst ofun = vtkPiecewiseFunction.newInstance();_x000d_\n_x000d_\nofun.addPoint(minV, 0.0);_x000d_\nofun.addPoint(minV + 0.1 * (maxV - minV), 0.05);_x000d_\nofun.addPoint(minV + 0.5 * (maxV - minV), 0.2);_x000d_\nofun.addPoint(maxV, 1.0);_x000d_\n_x000d_\nactor.getProperty().setScalarOpacity(0, ofun);_x000d_\nactor.getProperty().setInterpolationTypeToLinear();_x000d_\n// this variable makes results lighter_x000d_\nactor.getProperty().setScalarOpacityUnitDistance(0, 0.1);_x000d_\nactor.getProperty().setShade(false);_x000d_\nactor.getProperty().setAmbient(0.3);_x000d_\nactor.getProperty().setDiffuse(1);_x000d_\nactor.getProperty().setSpecular(1);_x000d_\n_x000d_\n//assign mapper to actor and assign mapper to render_x000d_\nactor.setMapper(mapper);_x000d_\nrenderer.addVolume(actor);_x000d_\n_x000d_\nconst bounds = imageData.getBounds();_x000d_\nconst center = [_x000d_\n(bounds[0] + bounds[1]) / 2,_x000d_\n(bounds[2] + bounds[3]) / 2,_x000d_\n(bounds[4] + bounds[5]) / 2,_x000d_\n];_x000d_\n_x000d_\nconst camera = renderer.getActiveCamera();_x000d_\ncamera.setFocalPoint(...center);_x000d_\ncamera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z_x000d_\ncamera.setViewUp(0, 1, 0);_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderWindow.render();_x000d_\nrenderer.resetCamera();_x000d_\nrenderWindow.render();_x000d_\n});_x000d_\n});_x000d_\n_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
  "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n    <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n    <script>\n        // Import required VTK.js modules\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n\n        // Create full screen render window\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderWindow.getRenderer();\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n        // Set data URL\n        const dataURL = 'http://127.0.0.1:5000/dataset/redsea.vti';\n\n        // Create reader for VTI format\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // Load dataset and process\n        reader.setUrl(dataURL).then(() => {\n            const imageData = reader.getOutputData(0);\n\n            // Create calculator to compute velocity magnitude\n            const calculator = vtkCalculator.newInstance();\n            calculator.setInputData(imageData);\n            calculator.setFormulaSimple(\n                vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes.SCALARS,\n                ['velocity'],\n                'velocity_magnitude',\n                (velocity) => Math.sqrt(velocity[0]*velocity[0] + velocity[1]*velocity[1] + velocity[2]*velocity[2])\n            );\n            calculator.update();\n            const processedData = calculator.getOutputData();\n\n            // Get scalar range for velocity magnitude\n            const dataArray = processedData.getPointData().getScalars();\n            const range = dataArray.getRange();\n\n            // Create color transfer function (blue → white → red)\n            const cfun = vtkColorTransferFunction.newInstance();\n            cfun.addRGBPoint(range[0], 0, 0, 1);      // Blue at min\n            cfun.addRGBPoint((range[0]+range[1])/2, 1, 1, 1); // White at mid\n            cfun.addRGBPoint(range[1], 1, 0, 0);      // Red at max\n\n            // Create piecewise opacity function\n            const ofun = vtkPiecewiseFunction.newInstance();\n            ofun.addPoint(range[0], 0.0);\n            ofun.addPoint(range[1]*0.3, 0.1);\n            ofun.addPoint(range[1]*0.6, 0.3);\n            ofun.addPoint(range[1], 0.7);\n\n            // Create volume mapper\n            const mapper = vtkVolumeMapper.newInstance();\n            mapper.setInputData(processedData);\n            mapper.setSampleDistance(1.0);\n\n            // Create volume actor\n            const actor = vtkVolume.newInstance();\n            actor.setMapper(mapper);\n            \n            // Set volume properties\n            const property = actor.getProperty();\n            property.setRGBTransferFunction(0, cfun);\n            property.setScalarOpacity(0, ofun);\n            property.setInterpolationTypeToLinear();\n            property.setShade(true);\n            property.setAmbient(0.3);\n            property.setDiffuse(0.7);\n            property.setSpecular(0.3);\n            property.setSpecularPower(10.0);\n\n            // Add volume to renderer\n            renderer.addVolume(actor);\n\n            // Adjust camera to look along +Z and center on dataset\n            const bounds = processedData.getBounds();\n            const center = [\n                (bounds[0] + bounds[1]) / 2,\n                (bounds[2] + bounds[3]) / 2,\n                (bounds[4] + bounds[5]) / 2\n            ];\n            renderer.getActiveCamera().setFocalPoint(...center);\n            renderer.getActiveCamera().setPosition(center[0], center[1], center[2] - 1000);\n            renderer.getActiveCamera().setViewUp(0, 1, 0);\n            renderer.resetCameraClippingRange();\n\n            // Render the scene\n            renderWindow.render();\n        });\n    </script>\n</body>\n</html>",
  "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
  "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Redsea dataset with volume rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/redsea.vti_x000d_\n_x000d_\nCompute velocity magnitude from the \"velocity\" array and set it as the active scalar_x000d_\n_x000d_\nApply volume rendering using a blue → white → red color map spanning the scalar range (min to max)_x000d_\n_x000d_\nApply a piecewise opacity function to control transparency across scalar values_x000d_\n_x000d_\nSet shading, ambient, diffuse, and specular properties for realistic volume appearance_x000d_\n_x000d_\nAdjust the camera to look along +Z and center on the dataset\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 10.00, Matches: vtkVolumeActor, vtkVolumeMapper):\nDescription: Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.\n\nModules: vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Common.DataModel.vtkPlane, vtk.IO.Core.vtkHttpDataSetReader.newInstance, vtk.Rendering.Core.vtkVolume, vtk.Rendering.Core.vtkVolumeMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        //using volume actor and mapper for rendering\n        const vtkVolumeActor = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        //create clip plan\n        const clipPlane = vtkPlane.newInstance();\n        const clipPlaneNormal = [0, 0, 1]\n\n        //set the data path and the reader\n        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';\n        const reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        //load data from dataPath and render the results by actor and mapper\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n                \n                //compute the range of the data set and set clip plan accordingly\n                const extent = data.getExtent();\n                const spacing = data.getSpacing();\n                const sizeX = extent[1] * spacing[0];\n                const sizeY = extent[3] * spacing[1];\n\n                clipPlanePosition = sizeX / 2;\n\n                const clipPlaneOrigin = [\n                    clipPlanePosition * clipPlaneNormal[0],\n                    clipPlanePosition * clipPlaneNormal[1],\n                    clipPlanePosition * clipPlaneNormal[2],\n                ];\n\n                clipPlane.setNormal(clipPlaneNormal);\n                clipPlane.setOrigin(clipPlaneOrigin);\n\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                mapper.addClippingPlane(clipPlane);\n                mapper.setInputData(data);\n                mapper.setSampleDistance(1);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolumeActor.newInstance();\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.1);\n                ofun.addPoint(255.0, 1.0);\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 2.955);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n    </script>\n</body>\n\n</html>\n\nExample 2 (Score: 10.00, Matches: vtkVolumeActor, vtkVolumeMapper):\nDescription: Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.\n\nModules: vtk.Common.DataModel.vtkPiecewiseFunction, vtk.IO.Core.vtkHttpDataSetReader.newInstance, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkVolume, vtk.Rendering.Core.vtkVolumeMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        //using volume actor and mapper for rendering\n        const vtkVolumeActor = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        //set the data path and the reader\n        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';\n        const reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        //load data from dataPath and render the results by actor and mapper\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                console.log(data.toJSON())\n                mapper.setInputData(data);\n                mapper.setSampleDistance(0.7);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolumeActor.newInstance();\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.1);\n                ofun.addPoint(255.0, 1.0);\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 2.955);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n    </script>\n</body>\n\n</html>\n\nExample 3 (Score: 5.00, Matches: vtkCalculator):\nDescription: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n\nModules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // using vtk namespace\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints = vtk.Common.Core.vtkPoints;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // setting vtkCalculator and set formula\n\n        const simpleFilter = vtkCalculator.newInstance();\n\n        simpleFilter.setFormulaSimple(\n            FieldDataTypes.POINT, // Generate an output array defined over points.\n            [], // We don't request any point-data arrays because point coordinates are made available by default.\n            'outputArray', // Name the output array \n            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125\n        ); \n\n        //using plane source to generate a poly data which can be rendered by vtkActor\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n        const sourceData = planeSource.getOutputData();\n\n        simpleFilter.setInputData(sourceData);\n        const planeActor = vtkActor.newInstance();\n        const planeMapper = vtkMapper.newInstance();\n        planeMapper.setInputData(simpleFilter.getOutputData());\n        planeMapper.setColorByArrayName('outputArray'); \n\n        planeMapper.setScalarModeToUsePointFieldData();   \n        planeActor.setMapper(planeMapper);\n        planeActor.getProperty().setEdgeVisibility(true);\n\n        renderer.addActor(planeActor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 5.00, Matches: vtkCalculator):\nDescription: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageLabelOutline</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Use the vtk namespace to reference each class\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        // Use the vtk namespace to reference constants\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.5, 0.5, 0.5],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const BACKGROUND = 0;\n        const LOW_VALUE = 80;\n        const HIGH_VALUE = 160;\n\n        const FIRST_SEGMENT = 1;\n        const SECOND_SEGMENT = 5;\n\n        /**\n         * Creates a labelmap image with the same dimensions as the background volume.\n         * @param {vtkImageData} backgroundImageData - The background volume data.\n         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.\n         */\n        function createLabelmap(backgroundImageData) {\n            // Create a labelmap image the same dimensions as our background volume.\n            const labelMapData = vtkImageData.newInstance(\n                backgroundImageData.get('spacing', 'origin', 'direction')\n            );\n\n            labelMapData.computeTransforms();\n\n            const dataArray = vtkDataArray.newInstance({\n                numberOfComponents: 1,\n                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),\n            });\n            labelMapData.getPointData().setScalars(dataArray);\n\n            labelMapData.setDimensions(...backgroundImageData.getDimensions());\n            labelMapData.setSpacing(...backgroundImageData.getSpacing());\n            labelMapData.setOrigin(...backgroundImageData.getOrigin());\n            labelMapData.setDirection(...backgroundImageData.getDirection());\n            const mapper = vtkImageMapper.newInstance();\n            mapper.setInputData(labelMapData);\n\n            const actor = vtkImageSlice.newInstance();\n\n            actor.setMapper(mapper);\n\n            const labelMap = {\n                actor,\n                mapper,\n                imageData: labelMapData,\n                cfun: vtkColorTransferFunction.newInstance(),\n                ofun: vtkPiecewiseFunction.newInstance(),\n            };\n\n            // Labelmap pipeline\n            labelMap.mapper.setInputData(labelMapData);\n            labelMap.actor.setMapper(labelMap.mapper);\n\n            // Set up labelMap color and opacity mapping\n            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label \"5\" will be green\n            labelMap.ofun.addPoint(0, 0);\n            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.\n            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.\n\n            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);\n            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);\n            labelMap.actor.getProperty().setInterpolationTypeToNearest();\n\n            labelMap.actor.getProperty().setUseLabelOutline(true);\n            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4\n            // (positioned at array index 4)\n            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);\n            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);\n\n            // This is very important to make sure the labelmap is rendered\n            // correctly\n            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);\n\n            const dims = labelMap.imageData.getDimensions();\n            const values = labelMap.imageData.getPointData().getScalars().getData();\n\n            const backgroundValues = backgroundImageData\n                .getPointData()\n                .getScalars()\n                .getData();\n            const size = dims[0] * dims[1] * dims[2];\n\n            for (let i = 0; i < size; i++) {\n                if (backgroundValues[i] === LOW_VALUE) {\n                    values[i] = FIRST_SEGMENT;\n                } else if (backgroundValues[i] === HIGH_VALUE) {\n                    values[i] = SECOND_SEGMENT;\n                }\n            }\n\n            labelMap.imageData.getPointData().getScalars().setData(values);\n\n            return labelMap;\n        }\n\n        // Create a one slice vtkImageData that has four quadrants of different values\n        const imageData = vtkImageData.newInstance();\n        const dims = [10, 10, 1];\n        imageData.setSpacing(1, 1, 1);\n        imageData.setOrigin(0.1, 0.1, 0.1);\n        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);\n\n        imageData.computeTransforms();\n\n        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);\n\n        let i = 0;\n        for (let y = 0; y < dims[1]; y++) {\n            for (let x = 0; x < dims[0]; x++, i++) {\n                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {\n                    values[i] = BACKGROUND;\n                } else if (x > 4 && x < 6 && y > 4 && y < 7) {\n                    values[i] = LOW_VALUE;\n                } else {\n                    values[i] = HIGH_VALUE;\n                }\n            }\n        }\n\n        const dataArray = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values,\n        });\n        imageData.getPointData().setScalars(dataArray);\n        imageData.modified();\n\n        const data = imageData;\n        const labelMap = createLabelmap(data);\n\n        const actor = vtkImageSlice.newInstance();\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(data);\n        actor.setMapper(mapper);\n        actor.getProperty().setInterpolationTypeToNearest();\n\n        renderer.addActor(actor);\n        renderer.addActor(labelMap.actor);\n        renderer.resetCamera();\n        renderer.resetCameraClippingRange();\n        renderWindow.render();\n\n        window.fullScreen = fullScreenRenderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 5 (Score: 5.00, Matches: vtkCalculator):\nDescription: Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Use vtk namespace to reference classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;\n\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>`;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n\n        console.log(planeSource.getOutputData().toJSON());\n\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkStickMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data ...\n                        name: 'orientation', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 3, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'temperature', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.\n                        numberOfComponents: 1, // ... with this many components ...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data ...\n                        name: 'pressure', // ... with the given name ...\n                        dataType: 'Float32Array', // ... of this type ...\n                        numberOfComponents: 2, // ... with this many components ...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                // array in is null here?\n                console.log(\"arraysIn:\", arraysIn());\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [orient, temp, press] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    orient[i * 3] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 1] =\n                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);\n                    orient[i * 3 + 2] = 1.0;\n\n                    temp[i] = coords[3 * i + 1];\n\n                    press[i * 2] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.05 +\n                        0.05;\n                    press[i * 2 + 1] =\n                        (coords[3 * i] * coords[3 * i] +\n                            coords[3 * i + 1] * coords[3 * i + 1]) *\n                        0.01 +\n                        0.01;\n                }\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n        // The generated 'temperature' array will become the default scalars\n        // so the plane mapper will color by 'temperature':\n        simpleFilter.setInputData(planeSource.getOutputData());\n        simpleFilter.update();\n        concole.log(simpleFilter.getOutputData());\n\n        //mapper.setInputConnection(simpleFilter.getOutputPort());\n\n        //mapper.setOrientationArray('orientation');\n        //mapper.setScaleArray('pressure');\n\n        //actor.setMapper(mapper);\n\n       // renderer.addActor(actor);\n       // renderer.resetCamera();\n        //renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        // fullScreenRenderer.addController(controlPanel);\n        // ['xResolution', 'yResolution'].forEach((propertyName) => {\n        //     document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n        //         const value = Number(e.target.value);\n        //         console.log(\"propertyName\",propertyName);\n        //         console.log(\"value\",value);\n        //         planeSource.set({ [propertyName]: value });\n        //         renderWindow.render();\n        //     });\n        // });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 6 (Score: 5.00, Matches: vtkCalculator):\nDescription: Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.\n\nModules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkConeSource, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkGlyph3DMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtkjs- Rendering-GlyphMapper</title>\n</head>\n\n\n\n<body>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Assuming vtk object is properly imported and available in global environment, proceed with corresponding assignments\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;\n        const vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        const planeSource = vtkPlaneSource.newInstance();\n        const simpleFilter = vtkCalculator.newInstance();\n        const mapper = vtkGlyph3DMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        simpleFilter.setFormula({\n            getArrays: (inputDataSets) => ({\n                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input\n                output: [\n                    // Generate two output arrays:\n                    {\n                        location: FieldDataTypes.POINT, // This array will be point-data...\n                        name: 'pressure', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        numberOfComponents: 3, //... with this many components...\n                    },\n                    {\n                        location: FieldDataTypes.POINT, // This array will be field data...\n                        name: 'temperature', //... with the given name...\n                        dataType: 'Float32Array', //... of this type...\n                        attribute: AttributeTypes.SCALARS, //... and will be marked as the default scalars.\n                        numberOfComponents: 1, //... with this many components...\n                    },\n                ],\n            }),\n            evaluate: (arraysIn, arraysOut) => {\n                // Convert in the input arrays of vtkDataArrays into variables\n                // referencing the underlying JavaScript typed-data arrays:\n                const [coords] = arraysIn.map((d) => d.getData());\n                const [press, temp] = arraysOut.map((d) => d.getData());\n\n                // Since we are passed coords as a 3-component array,\n                // loop over all the points and compute the point-data output:\n                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {\n                    press[i * 3] = (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5);\n                    press[i * 3 + 1] =\n                        ((coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) + 0.125) * 0.1;\n                    press[i * 3 + 2] =\n                        ((coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +\n                            (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) +\n                            0.125) *\n                        0.1;\n                    temp[i] = coords[3 * i + 1] * 0.1;\n                }\n\n                // Mark the output vtkDataArray as modified\n                arraysOut.forEach((x) => x.modified());\n            },\n        });\n\n\n        // console.log(\"planeSource\", planeSource.getOutputPort)\n        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':\n        simpleFilter.setInputConnection(planeSource.getOutputPort());\n\n        mapper.setInputConnection(simpleFilter.getOutputPort(), 0);\n\n        const coneSource = vtkConeSource.newInstance();\n        coneSource.setResolution(12);\n        mapper.setInputConnection(coneSource.getOutputPort(), 1);\n        mapper.setOrientationArray('pressure');\n        mapper.setScalarRange(0.0, 0.1);\n\n        actor.setMapper(mapper);\n\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // -----------------------------------------------------------\n        // UI control handling\n        // -----------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.mapper = mapper;\n        window.actor = actor;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n    </script>\n\n</body>\n\n</html>\n\n",
  "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
  "generator": "qwen3-max",
  "evaluator": "qwen3-max",
  "score": null,
  "workflow": {
    "inquiryExpansion": true,
    "rag": true
  },
  "eval_id": "1765338517",
  "eval_user": "test",
  "export_time": null,
  "console_output": null,
  "eval_time": "2025-12-10 11:48:37",
  "evaluator_evaluation": {
    "score": "0.8333333333333334",
    "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.85</Score>\n        <Reason>The generated code uses vtkCalculator to compute velocity magnitude, which is a valid and more elegant approach than manual computation in the ground truth. However, it omits setting spacing on the image data and does not configure advanced volume rendering properties like LocalAmbientOcclusion, LAOKernelSize, or ComputeNormalFromOpacity. Also, sample distance and maximum samples per ray differ, potentially affecting rendering quality.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.75</Score>\n        <Reason>The color transfer function matches (blue-white-red), but the opacity function differs significantly: the ground truth uses relative range-based points (e.g., min + 0.1*(max-min)), while the generated code uses absolute scaled values (e.g., range[1]*0.3), which may produce incorrect opacity if min ≠ 0. Additionally, background is black instead of white, shading is enabled (vs disabled in GT), and camera position uses a fixed offset (-1000) rather than a data-relative one, likely resulting in a very different view.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.9</Score>\n        <Reason>The generated code is well-structured, uses vtkCalculator appropriately for vector magnitude, and has clear variable names. It follows vtk.js best practices better than the ground truth by avoiding manual array loops. However, it lacks comments and omits error handling or logging present in the ground truth.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.8333333333333334</OverallScore>\n        <Critique>The generated code improves on data processing with vtkCalculator and is cleaner, but deviates in visual parameters (opacity mapping, shading, background, camera) leading to potentially different output appearance.</Critique>\n    </Summary>\n</Evaluation>",
    "parsed_evaluation": {
      "dimensions": {
        "Functionality": {
          "score": 0.85,
          "reason": "The generated code uses vtkCalculator to compute velocity magnitude, which is a valid and more elegant approach than manual computation in the ground truth. However, it omits setting spacing on the image data and does not configure advanced volume rendering properties like LocalAmbientOcclusion, LAOKernelSize, or ComputeNormalFromOpacity. Also, sample distance and maximum samples per ray differ, potentially affecting rendering quality."
        },
        "VisualQuality": {
          "score": 0.75,
          "reason": "The color transfer function matches (blue-white-red), but the opacity function differs significantly: the ground truth uses relative range-based points (e.g., min + 0.1*(max-min)), while the generated code uses absolute scaled values (e.g., range[1]*0.3), which may produce incorrect opacity if min ≠ 0. Additionally, background is black instead of white, shading is enabled (vs disabled in GT), and camera position uses a fixed offset (-1000) rather than a data-relative one, likely resulting in a very different view."
        },
        "CodeQuality": {
          "score": 0.9,
          "reason": "The generated code is well-structured, uses vtkCalculator appropriately for vector magnitude, and has clear variable names. It follows vtk.js best practices better than the ground truth by avoiding manual array loops. However, it lacks comments and omits error handling or logging present in the ground truth."
        }
      },
      "overall": 0.8333333333333334,
      "critique": "The generated code improves on data processing with vtkCalculator and is cleaner, but deviates in visual parameters (opacity mapping, shading, background, camera) leading to potentially different output appearance.",
      "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.85</Score>\n        <Reason>The generated code uses vtkCalculator to compute velocity magnitude, which is a valid and more elegant approach than manual computation in the ground truth. However, it omits setting spacing on the image data and does not configure advanced volume rendering properties like LocalAmbientOcclusion, LAOKernelSize, or ComputeNormalFromOpacity. Also, sample distance and maximum samples per ray differ, potentially affecting rendering quality.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.75</Score>\n        <Reason>The color transfer function matches (blue-white-red), but the opacity function differs significantly: the ground truth uses relative range-based points (e.g., min + 0.1*(max-min)), while the generated code uses absolute scaled values (e.g., range[1]*0.3), which may produce incorrect opacity if min ≠ 0. Additionally, background is black instead of white, shading is enabled (vs disabled in GT), and camera position uses a fixed offset (-1000) rather than a data-relative one, likely resulting in a very different view.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.9</Score>\n        <Reason>The generated code is well-structured, uses vtkCalculator appropriately for vector magnitude, and has clear variable names. It follows vtk.js best practices better than the ground truth by avoiding manual array loops. However, it lacks comments and omits error handling or logging present in the ground truth.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.8333333333333334</OverallScore>\n        <Critique>The generated code improves on data processing with vtkCalculator and is cleaner, but deviates in visual parameters (opacity mapping, shading, background, camera) leading to potentially different output appearance.</Critique>\n    </Summary>\n</Evaluation>"
    }
  },
  "options": null,
  "analysis": [
    {
      "phase": "Data Loading",
      "step_name": "Load Redsea Dataset",
      "vtk_modules": [
        "vtkXMLImageDataReader"
      ],
      "description": "Load the Redsea dataset from 'http://127.0.0.1:5000/dataset/redsea.vti' using vtkXMLImageDataReader."
    },
    {
      "phase": "Data Processing",
      "step_name": "Compute Velocity Magnitude",
      "vtk_modules": [
        "vtkCalculator"
      ],
      "description": "Use vtkCalculator to compute the magnitude of the 'velocity' vector array and set the resulting scalar array as the active scalar for the dataset."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Configure Volume Rendering",
      "vtk_modules": [
        "vtkVolumeMapper",
        "vtkVolumeActor",
        "vtkColorTransferFunction",
        "vtkPiecewiseFunction"
      ],
      "description": "Set up volume rendering with vtkVolumeMapper and vtkVolumeActor. Create a blue → white → red color transfer function spanning the full scalar range of the velocity magnitude. Define a piecewise opacity function to control transparency across scalar values."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Set Volume Shading Properties",
      "vtk_modules": [
        "vtkVolumeProperty"
      ],
      "description": "Enable shading on the volume property and configure ambient, diffuse, and specular coefficients to achieve a realistic appearance."
    },
    {
      "phase": "Rendering & Interaction",
      "step_name": "Configure Camera and Render",
      "vtk_modules": [
        "vtkRenderer",
        "vtkRenderWindow",
        "vtkRenderWindowInteractor"
      ],
      "description": "Initialize the renderer, render window, and interactor. Position the camera to look along the +Z axis and center it on the dataset bounds."
    }
  ],
  "retrieval_results": [
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Rendering-VolumeMapper\\code.html",
      "faiss_id": 431419998,
      "description": "Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.\n",
      "vtkjs_modules": "['vtk.Common.DataModel.vtkPiecewiseFunction', 'vtk.IO.Core.vtkHttpDataSetReader.newInstance', 'vtk.Rendering.Core.vtkColorTransferFunction', 'vtk.Rendering.Core.vtkVolume', 'vtk.Rendering.Core.vtkVolumeMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance']",
      "rerank_score": 38.0,
      "matched_keywords": "['vtkVolumeMapper', 'vtkVolumeActor', 'vtkPiecewiseFunction', 'vtkColorTransferFunction']",
      "match_explanation": "[\"Query: 'Visualization Setup — Apply a blue → white → red color map spanning the scalar range (min to max) using vtkColorTransferFunction;' (w=8.0) -> Hit 1 keys\", \"Query: 'Visualization Setup — Define a piecewise opacity function to control transparency across scalar values using vtkPiecewiseFunction;' (w=10.0) -> Hit 1 keys\", \"Query: 'Volume Rendering — Render the dataset using vtkVolumeMapper and vtkVolumeActor;' (w=10.0) -> Hit 2 keys\"]",
      "title": "Rendering-VolumeMapper"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageLabelOutline\\code.html",
      "faiss_id": 144015752,
      "description": "Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n",
      "vtkjs_modules": "['vtk.Common.Core.vtkDataArray', 'vtk.Common.DataModel.vtkDataSet.FieldAssociations', 'vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes', 'vtk.Common.DataModel.vtkImageData', 'vtk.Common.DataModel.vtkPiecewiseFunction', 'vtk.Filters.General.vtkCalculator', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkColorTransferFunction', 'vtk.Rendering.Core.vtkImageMapper', 'vtk.Rendering.Core.vtkImageSlice', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 32.0,
      "matched_keywords": "['vtkPiecewiseFunction', 'vtkCalculator', 'vtkActor', 'vtkRenderWindow', 'vtkColorTransferFunction']",
      "match_explanation": "[\"Query: 'Data Processing — Compute the velocity magnitude from the 'velocity' array and set it as the active scalar using vtkCalculator;' (w=8.0) -> Hit 1 keys\", \"Query: 'Visualization Setup — Apply a blue → white → red color map spanning the scalar range (min to max) using vtkColorTransferFunction;' (w=8.0) -> Hit 1 keys\", \"Query: 'Visualization Setup — Define a piecewise opacity function to control transparency across scalar values using vtkPiecewiseFunction;' (w=10.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor;' (w=3.0) -> Hit 2 keys\"]",
      "title": "Filter-ImageLabelOutline"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Rendering-ItkWasmVolume\\code.html",
      "faiss_id": 1398812761,
      "description": "Loads a medical image dataset (MHA) and renders it as a 3D volume using `vtkVolumeMapper` with custom color and opacity transfer functions.\n",
      "vtkjs_modules": "['vtk.Common.DataModel.vtkITKHelper', 'vtk.Common.DataModel.vtkPiecewiseFunction', 'vtk.IO.Core.DataAccessHelper.vtkLiteHttpDataAccessHelper', 'vtk.Rendering.Core.vtkColorTransferFunction', 'vtk.Rendering.Core.vtkVolume', 'vtk.Rendering.Core.vtkVolumeMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 31.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkVolumeMapper', 'vtkPiecewiseFunction', 'vtkColorTransferFunction']",
      "match_explanation": "[\"Query: 'Visualization Setup — Apply a blue → white → red color map spanning the scalar range (min to max) using vtkColorTransferFunction;' (w=8.0) -> Hit 1 keys\", \"Query: 'Visualization Setup — Define a piecewise opacity function to control transparency across scalar values using vtkPiecewiseFunction;' (w=10.0) -> Hit 1 keys\", \"Query: 'Volume Rendering — Render the dataset using vtkVolumeMapper and vtkVolumeActor;' (w=10.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor;' (w=3.0) -> Hit 1 keys\"]",
      "title": "Rendering-ItkWasmVolume"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-VolumeClip\\code.html",
      "faiss_id": 895986302,
      "description": "Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.\n",
      "vtkjs_modules": "['vtk.Common.DataModel.vtkPiecewiseFunction', 'vtk.Common.DataModel.vtkPlane', 'vtk.IO.Core.vtkHttpDataSetReader.newInstance', 'vtk.Rendering.Core.vtkVolume', 'vtk.Rendering.Core.vtkVolumeMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance']",
      "rerank_score": 30.0,
      "matched_keywords": "['vtkVolumeActor', 'vtkPiecewiseFunction', 'vtkVolumeMapper']",
      "match_explanation": "[\"Query: 'Visualization Setup — Define a piecewise opacity function to control transparency across scalar values using vtkPiecewiseFunction;' (w=10.0) -> Hit 1 keys\", \"Query: 'Volume Rendering — Render the dataset using vtkVolumeMapper and vtkVolumeActor;' (w=10.0) -> Hit 2 keys\"]",
      "title": "Filter-VolumeClip"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-Calculator\\code.html",
      "faiss_id": 1276004285,
      "description": "This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n",
      "vtkjs_modules": "['vtk.Common.Core.vtkPoints', 'vtk.Common.DataModel.vtkDataSet.FieldDataTypes', 'vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes', 'vtk.Common.DataModel.vtkPolyData', 'vtk.Filters.General.vtkCalculator', 'vtk.Filters.Sources.vtkPlaneSource', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 14.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkCalculator', 'vtkActor']",
      "match_explanation": "[\"Query: 'Data Processing — Compute the velocity magnitude from the 'velocity' array and set it as the active scalar using vtkCalculator;' (w=8.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor;' (w=3.0) -> Hit 2 keys\"]",
      "title": "Filter-Calculator"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\IO-StickMapper\\code.html",
      "faiss_id": 771311485,
      "description": "Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).\n",
      "vtkjs_modules": "['vtk.Common.DataModel.vtkDataSet.FieldAssociations', 'vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes', 'vtk.Filters.General.vtkCalculator', 'vtk.Filters.Sources.vtkPlaneSource', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkStickMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 14.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkCalculator', 'vtkActor']",
      "match_explanation": "[\"Query: 'Data Processing — Compute the velocity magnitude from the 'velocity' array and set it as the active scalar using vtkCalculator;' (w=8.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor;' (w=3.0) -> Hit 2 keys\"]",
      "title": "IO-StickMapper"
    }
  ],
  "metadata": {
    "keyword_aware_retrieval_time": 0.01036524772644043,
    "retrieval_time_seconds": 0.01
  }
}