<!DOCTYPE html>_x000D_
<html lang="en">_x000D_
_x000D_
<head>_x000D_
<meta charset="UTF-8">_x000D_
<meta name="viewport" content="width=device-width, initial-scale=1.0">_x000D_
<title>Isosurface Rendering for Deepwater Dataset</title>_x000D_
<style>_x000D_
body,_x000D_
html {_x000D_
margin: 0;_x000D_
padding: 0;_x000D_
width: 100%;_x000D_
height: 100%;_x000D_
overflow: hidden;_x000D_
}_x000D_
_x000D_
#renderer {_x000D_
width: 100%;_x000D_
height: 100%;_x000D_
}_x000D_
</style>_x000D_
</head>_x000D_
_x000D_
<body>_x000D_
<div id="renderer"></div>_x000D_
<script src="https://unpkg.com/vtk.js"></script>_x000D_
<script>_x000D_
const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000D_
const vtkActor = vtk.Rendering.Core.vtkActor;_x000D_
const vtkMapper = vtk.Rendering.Core.vtkMapper;_x000D_
const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000D_
const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000D_
const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;_x000D_
_x000D_
const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({_x000D_
background: [1,1,1],_x000D_
});_x000D_
const renderWindow = fullScreenRenderWindow.getRenderWindow();_x000D_
const renderer = fullScreenRenderWindow.getRenderer();_x000D_
_x000D_
const reader = vtkXMLImageDataReader.newInstance();_x000D_
reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {_x000D_
reader.loadData().then(() => {_x000D_
const imageData = reader.getOutputData(0);_x000D_
_x000D_
// Output array names in the dataset to help with debugging_x000D_
// Fix: getArrayNames is not a function, use getArrays() to get the array list_x000D_
const arrays = imageData.getPointData().getArrays();_x000D_
const arrayNames = arrays.map(array => array.getName());_x000D_
console.log('Arrays in dataset:', arrayNames);_x000D_
_x000D_
// Use v02 and v03 arrays to calculate velocity magnitude_x000D_
const v02Array = imageData.getPointData().getArrayByName('v02');_x000D_
const v03Array = imageData.getPointData().getArrayByName('v03');_x000D_
_x000D_
if (!v02Array || !v03Array) {_x000D_
console.error('Cannot find v02 or v03 arrays');_x000D_
// Try to use another available array_x000D_
const availableArray = imageData.getPointData().getArrayByName('prs');_x000D_
if (availableArray) {_x000D_
// Directly use pressure (prs) array as scalar field_x000D_
imageData.getPointData().setActiveScalars('prs');_x000D_
} else {_x000D_
console.error('Unable to find suitable array for rendering');_x000D_
return;_x000D_
}_x000D_
} else {_x000D_
// Calculate velocity magnitude_x000D_
const numPoints = imageData.getNumberOfPoints();_x000D_
const magnitudeData = new Float64Array(numPoints);_x000D_
_x000D_
for (let i = 0; i < numPoints; i++) {_x000D_
// v02 and v03 are scalar arrays, directly get values_x000D_
const v2 = v02Array.getData()[i];_x000D_
const v3 = v03Array.getData()[i];_x000D_
// Calculate velocity magnitude_x000D_
magnitudeData[i] = Math.sqrt(v2 * v2 + v3 * v3);_x000D_
}_x000D_
_x000D_
// Create velocity magnitude array_x000D_
const vtkDataArray = vtk.Common.Core.vtkDataArray;_x000D_
const magnitudeVtkArray = vtkDataArray.newInstance({_x000D_
numberOfComponents: 1,_x000D_
values: magnitudeData,_x000D_
name: 'velocityMagnitude',_x000D_
});_x000D_
imageData.getPointData().addArray(magnitudeVtkArray);_x000D_
imageData.getPointData().setActiveScalars('velocityMagnitude');_x000D_
}_x000D_
_x000D_
// Get range of current active scalar_x000D_
const activeScalars = imageData.getPointData().getScalars();_x000D_
const newRange = activeScalars.getRange();_x000D_
const [minV, maxV] = newRange;_x000D_
_x000D_
console.log('Using scalar field:', activeScalars.getName());_x000D_
console.log('Data range:', newRange);_x000D_
_x000D_
const marchingCube = vtkImageMarchingCubes.newInstance({_x000D_
contourValue: minV + 0.5 * (maxV - minV),_x000D_
computeNormals: true,_x000D_
mergePoints: true_x000D_
});_x000D_
_x000D_
marchingCube.setInputData(imageData);_x000D_
_x000D_
const mapper = vtkMapper.newInstance();_x000D_
mapper.setInputConnection(marchingCube.getOutputPort());_x000D_
_x000D_
const colorTransferFunction = vtkColorTransferFunction.newInstance();_x000D_
colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);_x000D_
colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);_x000D_
colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);_x000D_
colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);_x000D_
colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);_x000D_
_x000D_
mapper.setLookupTable(colorTransferFunction);_x000D_
mapper.setScalarRange(minV, maxV);_x000D_
mapper.setInterpolateScalarsBeforeMapping(true);_x000D_
_x000D_
const actor = vtkActor.newInstance();_x000D_
actor.setMapper(mapper);_x000D_
actor.getProperty().setRepresentationToSurface();_x000D_
actor.getProperty().setEdgeVisibility(false);_x000D_
actor.getProperty().setOpacity(1.0);_x000D_
actor.getProperty().setAmbient(0.3);_x000D_
actor.getProperty().setDiffuse(0.7);_x000D_
actor.getProperty().setSpecular(0.4);_x000D_
_x000D_
renderer.addActor(actor);_x000D_
_x000D_
const bounds = imageData.getBounds();_x000D_
const center = [_x000D_
(bounds[0] + bounds[1]) / 2,_x000D_
(bounds[2] + bounds[3]) / 2,_x000D_
(bounds[4] + bounds[5]) / 2,_x000D_
];_x000D_
_x000D_
const camera = renderer.getActiveCamera();_x000D_
camera.setFocalPoint(...center);_x000D_
camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);_x000D_
camera.setViewUp(0, 0, 1);_x000D_
renderer.resetCameraClippingRange();_x000D_
renderWindow.render();_x000D_
renderer.resetCamera();_x000D_
renderWindow.render();_x000D_
_x000D_
const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();_x000D_
const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({_x000D_
actor: axes,_x000D_
interactor: renderWindow.getInteractor(),_x000D_
});_x000D_
widget.setEnabled(true);_x000D_
widget.setViewportCorner(_x000D_
vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT_x000D_
);_x000D_
widget.setViewportSize(0.15);_x000D_
widget.setMinPixelSize(100);_x000D_
widget.setMaxPixelSize(300);_x000D_
_x000D_
const interactor = renderWindow.getInteractor();_x000D_
interactor.start();_x000D_
});_x000D_
});_x000D_
</script>_x000D_
</body>_x000D_
_x000D_
</html>