
<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<title>Deepwater Dataset Isosurface Visualization</title>
<style>
body {
margin: 0;
padding: 0;
overflow: hidden;
}
</style>
</head>

<body>
<script src="https://unpkg.com/vtk.js@34.10.0/vtk.js"></script>
<script>
// Import necessary VTK.js modules
const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
const vtkDataArray = vtk.Common.Core.vtkDataArray;
const vtkMapper = vtk.Rendering.Core.vtkMapper;
const vtkActor = vtk.Rendering.Core.vtkActor;
const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;
const vtkAnnotatedCubeActor = vtk.Rendering.Core.vtkAnnotatedCubeActor;

const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
// const vtkContourFilter = vtk.Filters.General.vtkContourFilter;
const vtkContourFilter = vtk.Filters.General.vtkContourFilter;
const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;
// Create full screen render window
const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance(
    {
        backgroundColor: [0, 0, 0],
    }
);
const renderWindow = fullScreenRenderWindow.getRenderWindow();
const renderer = fullScreenRenderWindow.getRenderer();
const reader = vtkXMLImageDataReader.newInstance();

reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {
reader.loadData().then(() => {
const dataset = reader.getOutputData(0);

// Compute velocity magnitude from v02 and v03 if available
let scalarName = 'velocityMagnitude';
const v02 = dataset.getPointData().getArrayByName('v02');
const v03 = dataset.getPointData().getArrayByName('v03');
if (v02 && v03) {
const numPoints = dataset.getNumberOfPoints();
const vMagData = new Float32Array(numPoints);
for (let i = 0; i < numPoints; i++) {
const v2 = v02.getTuple(i);
const v3 = v03.getTuple(i);
vMagData[i] = Math.sqrt(v2[0] * v2[0] + v3[0] * v3[0]);
}
const vMagArray = vtkDataArray.newInstance({
name: 'velocityMagnitude',
values: vMagData,
numberOfComponents: 1,
});
dataset.getPointData().addArray(vMagArray);
scalarName = 'velocityMagnitude';
}
dataset.getPointData().setActiveScalars('velocityMagnitude');

// Get scalar range
const scalarRange = dataset.getPointData().getArrayByName(scalarName).getRange();
console.log(scalarRange);
const isoValue = scalarRange[0] + 0.5 * (scalarRange[1] - scalarRange[0]);

// Create isosurface filter
const marchingCube = vtkImageMarchingCubes.newInstance({
          contourValue: isoValue,
          computeNormals: true,
          mergePoints: true,
        });
marchingCube.setInputData(dataset);

// Create mapper and actor
const mapper = vtkMapper.newInstance();
// mapper.setInputConnection(contour.getOutputPort());
mapper.setInputConnection(marchingCube.getOutputPort());
 console.log(marchingCube.getOutputPort());
// console.log(marchingCube.getOutput());
mapper.setScalarModeToUsePointData();
mapper.setScalarVisibility(true);
mapper.setColorByArrayName('velocityMagnitude');
const ctf = vtkColorTransferFunction.newInstance();
mapper.setLookupTable(ctf);
ctf.setMappingRange(scalarRange[0], scalarRange[1]);
ctf.addRGBPoint(scalarRange[0], 0, 0, 1);
ctf.addRGBPoint((scalarRange[0] + scalarRange[1]) / 2, 1, 1, 1);
ctf.addRGBPoint(scalarRange[1], 1, 0, 0);
ctf.build();
mapper.setScalarRange(scalarRange[0], scalarRange[1]);

const actor = vtkActor.newInstance();
actor.setMapper(mapper);
actor.getProperty().setOpacity(1.0); // Fully opaque
actor.getProperty().setInterpolationToPhong(); // Smooth shading

// Set up color map: blue → white → red

// Add actor to renderer
renderer.addActor(actor);
renderer.resetCamera();
renderWindow.render();

renderWindow.getInteractor().start();
});
});
</script>
</body>

</html>
