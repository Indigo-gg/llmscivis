
Generate only the HTML code without any additional text.
User Requirements:
Generate an HTML page using vtk.js to visualize the rotor dataset._x000d_
_x000d_
- Load the dataset from: http://127.0.0.1:5000/dataset/rotor.vti_x000d_
- Set the active scalar array to "Pressure"._x000d_
- Apply a slice along the Y axis at 95% depth of the dataset (convert percentage to slice index)._x000d_
- Use a blue → white → red color map for pressure values, spanning from the minimum to maximum scalar range._x000d_
- Set opacity to fully opaque (no transparency variation)._x000d_
- Add an orientation marker with XYZ axes in the bottom-right corner._x000d_
- No interactive GUI controls are required._x000d_


Relevant VTK.js Examples:

--------------------------------------------------------------------------------Example 1 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):
Description: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.

Modules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js ImageLabelOutline</title>
    <style>
        #renderer {
            width: 100%;
            height: 600px;
            background-color: #333;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // Use the vtk namespace to reference each class
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const vtkImageData = vtk.Common.DataModel.vtkImageData;
        const vtkDataArray = vtk.Common.Core.vtkDataArray;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;

        // Use the vtk namespace to reference constants
        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0.5, 0.5, 0.5],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const BACKGROUND = 0;
        const LOW_VALUE = 80;
        const HIGH_VALUE = 160;

        const FIRST_SEGMENT = 1;
        const SECOND_SEGMENT = 5;

        /**
         * Creates a labelmap image with the same dimensions as the background volume.
         * @param {vtkImageData} backgroundImageData - The background volume data.
         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.
         */
        function createLabelmap(backgroundImageData) {
            // Create a labelmap image the same dimensions as our background volume.
            const labelMapData = vtkImageData.newInstance(
                backgroundImageData.get('spacing', 'origin', 'direction')
            );

            labelMapData.computeTransforms();

            const dataArray = vtkDataArray.newInstance({
                numberOfComponents: 1,
                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),
            });
            labelMapData.getPointData().setScalars(dataArray);

            labelMapData.setDimensions(...backgroundImageData.getDimensions());
            labelMapData.setSpacing(...backgroundImageData.getSpacing());
            labelMapData.setOrigin(...backgroundImageData.getOrigin());
            labelMapData.setDirection(...backgroundImageData.getDirection());
            const mapper = vtkImageMapper.newInstance();
            mapper.setInputData(labelMapData);

            const actor = vtkImageSlice.newInstance();

            actor.setMapper(mapper);

            const labelMap = {
                actor,
                mapper,
                imageData: labelMapData,
                cfun: vtkColorTransferFunction.newInstance(),
                ofun: vtkPiecewiseFunction.newInstance(),
            };

            // Labelmap pipeline
            labelMap.mapper.setInputData(labelMapData);
            labelMap.actor.setMapper(labelMap.mapper);

            // Set up labelMap color and opacity mapping
            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label "1" will be red
            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label "1" will be red
            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label "5" will be green
            labelMap.ofun.addPoint(0, 0);
            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.
            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.

            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);
            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);
            labelMap.actor.getProperty().setInterpolationTypeToNearest();

            labelMap.actor.getProperty().setUseLabelOutline(true);
            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4
            // (positioned at array index 4)
            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);
            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);

            // This is very important to make sure the labelmap is rendered
            // correctly
            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);

            const dims = labelMap.imageData.getDimensions();
            const values = labelMap.imageData.getPointData().getScalars().getData();

            const backgroundValues = backgroundImageData
                .getPointData()
                .getScalars()
                .getData();
            const size = dims[0] * dims[1] * dims[2];

            for (let i = 0; i < size; i++) {
                if (backgroundValues[i] === LOW_VALUE) {
                    values[i] = FIRST_SEGMENT;
                } else if (backgroundValues[i] === HIGH_VALUE) {
                    values[i] = SECOND_SEGMENT;
                }
            }

            labelMap.imageData.getPointData().getScalars().setData(values);

            return labelMap;
        }

        // Create a one slice vtkImageData that has four quadrants of different values
        const imageData = vtkImageData.newInstance();
        const dims = [10, 10, 1];
        imageData.setSpacing(1, 1, 1);
        imageData.setOrigin(0.1, 0.1, 0.1);
        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);
        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);

        imageData.computeTransforms();

        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);

        let i = 0;
        for (let y = 0; y < dims[1]; y++) {
            for (let x = 0; x < dims[0]; x++, i++) {
                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {
                    values[i] = BACKGROUND;
                } else if (x > 4 && x < 6 && y > 4 && y < 7) {
                    values[i] = LOW_VALUE;
                } else {
                    values[i] = HIGH_VALUE;
                }
            }
        }

        const dataArray = vtkDataArray.newInstance({
            numberOfComponents: 1,
            values,
        });
        imageData.getPointData().setScalars(dataArray);
        imageData.modified();

        const data = imageData;
        const labelMap = createLabelmap(data);

        const actor = vtkImageSlice.newInstance();
        const mapper = vtkImageMapper.newInstance();
        mapper.setInputData(data);
        actor.setMapper(mapper);
        actor.getProperty().setInterpolationTypeToNearest();

        renderer.addActor(actor);
        renderer.addActor(labelMap.actor);
        renderer.resetCamera();
        renderer.resetCameraClippingRange();
        renderWindow.render();

        window.fullScreen = fullScreenRenderWindow;

    </script>
</body>

</html>

Example 2 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):
Description: Generates and displays a 2D random image (100x100) using `vtkImageSlice` and `vtkImageMapper`.

Modules: vtk.Common.Core.vtkDataArray.newInstance, vtk.Common.DataModel.vtkImageData, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;// Actor for rendering 2D image slices
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageData = vtk.Common.DataModel.vtkImageData;

        // Create render window
        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // Create image data
        const imageData = vtkImageData.newInstance();
        imageData.setDimensions(100, 100, 1);
        imageData.setSpacing(1.0, 1.0, 1.0);
        imageData.setOrigin(0.0, 0.0, 0.0);

        // Set pixel values for image data
        const scalars = new Uint8Array(100 * 100);
        for (let i = 0; i < 100 * 100; i++) {
            scalars[i] = Math.random() * 255;
        }
        imageData.getPointData().setScalars(vtk.Common.Core.vtkDataArray.newInstance({ values: scalars, numberOfComponents: 1 }));

        // Create mapper and actor
        const mapper = vtkImageMapper.newInstance();
        mapper.setInputData(imageData);

        const actor = vtkImageSlice.newInstance();
        actor.setMapper(mapper);

        // Add actor to renderer
        renderer.addActor(actor);
        renderer.resetCamera();
        renderWindow.render();
    </script>
</body>

</html>


Example 3 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):
Description: Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.

Modules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const dataPath = 'http://kitware.github.io/vtk-js/data/volume/headsq.vti';

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const imageActorI = vtkImageSlice.newInstance();
        const imageActorJ = vtkImageSlice.newInstance();
        const imageActorK = vtkImageSlice.newInstance();

        renderer.addActor(imageActorK);
        renderer.addActor(imageActorJ);
        renderer.addActor(imageActorI);

        const reader = vtkHttpDataSetReader.newInstance({
            fetchGzip: true,
        });
        reader
            .setUrl(dataPath, { loadData: true })
            .then(() => {
                const data = reader.getOutputData();
                const dataRange = data.getPointData().getScalars().getRange();
                const extent = data.getExtent();

                const imageMapperK = vtkImageMapper.newInstance();
                imageMapperK.setInputData(data);
                imageMapperK.setKSlice(30);
                imageActorK.setMapper(imageMapperK);

                const imageMapperJ = vtkImageMapper.newInstance();
                imageMapperJ.setInputData(data);
                imageMapperJ.setJSlice(30);
                imageActorJ.setMapper(imageMapperJ);

                const imageMapperI = vtkImageMapper.newInstance();
                imageMapperI.setInputData(data);
                imageMapperI.setISlice(30);
                imageActorI.setMapper(imageMapperI);

                renderer.resetCamera();
                renderWindow.render();
            });
    </script>
</body>

</html>

Example 4 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):
Description: Displays a synthetic 2D image generated by `vtkRTAnalyticSource` using `vtkImageMapper` and `vtkImageSlice`.
Modules: vtk.Common.DataModel.vtkImageData, vtk.Filters.Sources.vtkRTAnalyticSource, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageData = vtk.Common.DataModel.vtkImageData;

        // create render window
        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        const vtkImgSource = vtk.Filters.Sources.vtkRTAnalyticSource;
        const imgSource = vtkImgSource.newInstance();
        imgSource.update();
        const img = imgSource.getOutputData();

        // set mapper and actor
        const mapper = vtkImageMapper.newInstance();
        mapper.setInputData(img);

        const actor = vtkImageSlice.newInstance();
        actor.setMapper(mapper);

        // adding actor to render
        renderer.addActor(actor);
        renderer.resetCamera();
        renderWindow.render();
    </script>
</body>

</html>

Example 5 (Score: 10.00, Matches: vtkImageMapper, vtkImageSlice):
Description: Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.

Modules: vtk.IO.Core.vtkHttpDataSetReader, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js Isosurface Visualization</title>
    <link rel="stylesheet" href="https://kit.fontawesome.com/419a5ebb56.css" crossorigin="anonymous">
    <style>
        #renderer {
            width: 100%;
            height: 600px;
            background-color: #333;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <!-- Set vtk.js favicon -->
    <script type="module" src="https://unpkg.com/vtk.js/favicon.js"></script>

    <!-- Load WebGL and WebGPU rendering modules -->
    <script type="module" src="https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Volume.js"></script>

    <!-- Force DataAccessHelper to access various data sources -->
    <script type="module"
        src="https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper.js"></script>
    <script type="module"
        src="https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper.js"></script>
    <script type="module"
        src="https://unpkg.com/vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js"></script>

    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const path = 'http://kitware.github.io/vtk-js/data'

        // Reference HTML template
        const controlPanel = `<table>
    <tr>
        <td>Slice I</td>
        <td>
            <input class='sliceI' type="range" min="0" max="2.0" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>Slice J</td>
        <td>
            <input class='sliceJ' type="range" min="0" max="2.0" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>Slice K</td>
        <td>
            <input class='sliceK' type="range" min="0" max="100" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>Color level</td>
        <td>
            <input class='colorLevel' type="range" min="-3926" max="3926" step="1" value="1" />
        </td>
    </tr>
    <tr>
        <td>ColorWindow</td>
        <td>
            <input class='colorWindow' type="range" min="0" max="3926" step="1" value="1" />
        </td>
    </tr>
</table>
`;
        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();
        fullScreenRenderWindow.addController(controlPanel);

        const imageActorI = vtkImageSlice.newInstance();
        const imageActorJ = vtkImageSlice.newInstance();
        const imageActorK = vtkImageSlice.newInstance();

        renderer.addActor(imageActorK);
        renderer.addActor(imageActorJ);
        renderer.addActor(imageActorI);

        function updateColorLevel(e) {
            const colorLevel = Number(
                (e ? e.target : document.querySelector('.colorLevel')).value
            );
            imageActorI.getProperty().setColorLevel(colorLevel);
            imageActorJ.getProperty().setColorLevel(colorLevel);
            imageActorK.getProperty().setColorLevel(colorLevel);
            renderWindow.render();
        }

        function updateColorWindow(e) {
            const colorLevel = Number(
                (e ? e.target : document.querySelector('.colorWindow')).value
            );
            imageActorI.getProperty().setColorWindow(colorLevel);
            imageActorJ.getProperty().setColorWindow(colorLevel);
            imageActorK.getProperty().setColorWindow(colorLevel);
            renderWindow.render();
        }

        const reader = vtkHttpDataSetReader.newInstance({
            fetchGzip: true,
        });
        reader
            .setUrl(`${path}/data/volume/headsq.vti`, { loadData: true })
            .then(() => {
                const data = reader.getOutputData();
                const dataRange = data.getPointData().getScalars().getRange();
                const extent = data.getExtent();

                const imageMapperK = vtkImageMapper.newInstance();
                imageMapperK.setInputData(data);
                imageMapperK.setKSlice(30);
                imageActorK.setMapper(imageMapperK);

                const imageMapperJ = vtkImageMapper.newInstance();
                imageMapperJ.setInputData(data);
                imageMapperJ.setJSlice(30);
                imageActorJ.setMapper(imageMapperJ);

                const imageMapperI = vtkImageMapper.newInstance();
                imageMapperI.setInputData(data);
                imageMapperI.setISlice(30);
                imageActorI.setMapper(imageMapperI);

                renderer.resetCamera();
                renderer.resetCameraClippingRange();
                renderWindow.render();

                ['.sliceI', '.sliceJ', '.sliceK'].forEach((selector, idx) => {
                    const el = document.querySelector(selector);
                    el.setAttribute('min', extent[idx * 2 + 0]);
                    el.setAttribute('max', extent[idx * 2 + 1]);
                    el.setAttribute('value', 30);
                });

                ['.colorLevel', '.colorWindow'].forEach((selector) => {
                    document.querySelector(selector).setAttribute('max', dataRange[1]);
                    document.querySelector(selector).setAttribute('value', dataRange[1]);
                });
                document
                    .querySelector('.colorLevel')
                    .setAttribute('value', (dataRange[0] + dataRange[1]) / 2);
                updateColorLevel();
                updateColorWindow();
            });

        document.querySelector('.sliceI').addEventListener('input', (e) => {
            imageActorI.getMapper().setISlice(Number(e.target.value));
            renderWindow.render();
        });

        document.querySelector('.sliceJ').addEventListener('input', (e) => {
            imageActorJ.getMapper().setJSlice(Number(e.target.value));
            renderWindow.render();
        });

        document.querySelector('.sliceK').addEventListener('input', (e) => {
            imageActorK.getMapper().setKSlice(Number(e.target.value));
            renderWindow.render();
        });

        document
            .querySelector('.colorLevel')
            .addEventListener('input', updateColorLevel);
        document
            .querySelector('.colorWindow')
            .addEventListener('input', updateColorWindow);

        window.fullScreen = fullScreenRenderWindow;
        window.imageActorI = imageActorI;
        window.imageActorJ = imageActorJ;
        window.imageActorK = imageActorK;

    </script>
</body>

</html>

