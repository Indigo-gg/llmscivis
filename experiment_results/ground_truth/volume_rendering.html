<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>redsea Example</title>
    <script src="https://unpkg.com/vtk.js"></script>
</head>

<body>
    <div id="renderer"></div>
    <!-- <script src="https://unpkg.com/vtk.js"></script> -->
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkVolume = vtk.Rendering.Core.vtkVolume;
        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;

        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;

        //init the render window
        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();


        // Load dataset
        const reader = vtkXMLImageDataReader.newInstance();


        // set url and load the data
        reader.setUrl('http://127.0.0.1:5000/dataset/redsea.vti').then(() => {
            reader.loadData().then(() => {
                //prepare dataset
                const imageData = reader.getOutputData(0);
                //set active scalar
                const velocityArray = imageData.getPointData().getArrayByName('velocity');
                const numPoints = imageData.getNumberOfPoints();
                const magnitudeData = new Float64Array(numPoints);
                for (let i = 0; i < numPoints; i++) {
                    const vx = velocityArray.getData()[3 * i + 0];
                    const vy = velocityArray.getData()[3 * i + 1];
                    const vz = velocityArray.getData()[3 * i + 2];
                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);
                }

                const vtkDataArray = vtk.Common.Core.vtkDataArray;
                const magnitudeVtkArray = vtkDataArray.newInstance({
                    numberOfComponents: 1,
                    values: magnitudeData,
                    name: 'velocityMagnitude',
                });
                imageData.getPointData().addArray(magnitudeVtkArray);
                console.log(imageData.toJSON())


                imageData.getPointData().setActiveScalars('velocityMagnitude');
                imageData.setSpacing(0.05, 0.05, 0.1);

                console.log('New bounds:', imageData.getBounds());
                console.log('Dimensions:', imageData.getDimensions());
                console.log('Spacing:', imageData.getSpacing());

                const newRange = magnitudeVtkArray.getRange();
                console.log('velocityMagnitude range:', newRange);
                const [minV, maxV] = newRange;


                console.log(imageData.getPointData().getScalars().getName());


                //create the mapper and set its property
                const mapper = vtkVolumeMapper.newInstance();
                //console.log(data.toJSON())
                mapper.setMaximumSamplesPerRay(4000);  // or even higher, up to your hardware limits
                mapper.setInputData(imageData);
                mapper.setSampleDistance(0.1);

                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.
                const actor = vtkVolume.newInstance();

                // Move LocalAmbientOcclusion properties to actor's property
                actor.getProperty().setLocalAmbientOcclusion(0);
                actor.getProperty().setLAOKernelSize(10);
                actor.getProperty().setLAOKernelRadius(5);
                // Move ComputeNormalFromOpacity to actor's property
                actor.getProperty().setComputeNormalFromOpacity(true);

                const cfun = vtkColorTransferFunction.newInstance();
                cfun.addRGBPoint(minV, 0.0, 0.0, 1.0);
                cfun.addRGBPoint((minV + maxV) * 0.5, 1.0, 1.0, 1.0);
                cfun.addRGBPoint(maxV, 1.0, 0.0, 0.0);
                actor.getProperty().setRGBTransferFunction(0, cfun);

                const ofun = vtkPiecewiseFunction.newInstance();

                ofun.addPoint(minV, 0.0);
                ofun.addPoint(minV + 0.1 * (maxV - minV), 0.05);
                ofun.addPoint(minV + 0.5 * (maxV - minV), 0.2);
                ofun.addPoint(maxV, 1.0);

                actor.getProperty().setScalarOpacity(0, ofun);
                actor.getProperty().setInterpolationTypeToLinear();
                // this variable makes results lighter
                actor.getProperty().setScalarOpacityUnitDistance(0, 0.1);
                actor.getProperty().setShade(false);
                actor.getProperty().setAmbient(0.3);
                actor.getProperty().setDiffuse(1);
                actor.getProperty().setSpecular(1);

                //assign mapper to actor and assign mapper to render
                actor.setMapper(mapper);
                renderer.addVolume(actor);

                const bounds = imageData.getBounds();
                const center = [
                    (bounds[0] + bounds[1]) / 2,
                    (bounds[2] + bounds[3]) / 2,
                    (bounds[4] + bounds[5]) / 2,
                ];

                const camera = renderer.getActiveCamera();
                camera.setFocalPoint(...center);
                camera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z
                camera.setViewUp(0, 1, 0);
                renderer.resetCameraClippingRange();
                renderWindow.render();
                renderer.resetCamera();
                renderWindow.render();
            });
        });

    </script>
</body>

</html>