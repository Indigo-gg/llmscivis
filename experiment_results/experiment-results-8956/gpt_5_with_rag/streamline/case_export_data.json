{
  "path": "",
  "name": "",
  "prompt": "Generate an HTML page using vtk.js to visualize the Isabel dataset with streamline rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/isabel.vti_x000d_\n_x000d_\nUse the \"Velocity\" array as the vector field for streamlines_x000d_\n_x000d_\nGenerate seed points at the center of the dataset with sufficient density to cover the domain_x000d_\n_x000d_\nCompute streamlines following the velocity field_x000d_\n_x000d_\nRender streamlines in cyan ([0, 1, 1]) with a specified line width_x000d_\n_x000d_\nRender a dataset outline in red ([1, 0, 0]) with a specified line width",
  "ground_truth": "<!DOCTYPE html>_x000d_\n<html lang=\"en\">_x000d_\n_x000d_\n<head>_x000d_\n<meta charset=\"UTF-8\">_x000d_\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">_x000d_\n<title>Isosurface Rendering for Isabel Dataset</title>_x000d_\n</head>_x000d_\n_x000d_\n<body>_x000d_\n<!-- Renderer container -->_x000d_\n<div id=\"renderer\"></div>_x000d_\n<!-- Load VTK.js library -->_x000d_\n<script src=\"https://unpkg.com/vtk.js\"></script>_x000d_\n<script>_x000d_\n// Import required VTK.js classes_x000d_\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;_x000d_\nconst vtkActor = vtk.Rendering.Core.vtkActor;_x000d_\nconst vtkMapper = vtk.Rendering.Core.vtkMapper;_x000d_\nconst vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;_x000d_\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;_x000d_\nconst vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;_x000d_\n_x000d_\n// Initialize render window, set background color to black_x000d_\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({_x000d_\nbackground: [0.1, 0.1, 0.1],_x000d_\n});_x000d_\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();_x000d_\nconst renderer = fullScreenRenderWindow.getRenderer();_x000d_\n_x000d_\n// Create XML image data reader instance_x000d_\nconst reader = vtkXMLImageDataReader.newInstance();_x000d_\n_x000d_\n// Set data file URL and load data_x000d_\nreader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\isabel.vti').then(() => {_x000d_\n// After data URL is set successfully, load data_x000d_\nreader.loadData().then(() => {_x000d_\n// Get loaded image data_x000d_\nconst imageData = reader.getOutputData(0);_x000d_\n_x000d_\n// Get velocity vector field from data_x000d_\nconst velocityArray = imageData.getPointData().getArrayByName('Velocity');_x000d_\n// Get total number of data points_x000d_\nconst numPoints = imageData.getNumberOfPoints();_x000d_\n// Create new array to store velocity magnitude_x000d_\nconst magnitudeData = new Float64Array(numPoints);_x000d_\n_x000d_\n// Calculate velocity magnitude (norm of velocity vector) for each point_x000d_\nfor (let i = 0; i < numPoints; i++) {_x000d_\n// Get three components of velocity_x000d_\nconst vx = velocityArray.getData()[3 * i + 0]; // x component_x000d_\nconst vy = velocityArray.getData()[3 * i + 1]; // y component_x000d_\nconst vz = velocityArray.getData()[3 * i + 2]; // z component_x000d_\n// Calculate velocity magnitude (Euclidean norm)_x000d_\nmagnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);_x000d_\n}_x000d_\n_x000d_\n// Create VTK data array class_x000d_\nconst vtkDataArray = vtk.Common.Core.vtkDataArray;_x000d_\n// Create VTK array for velocity magnitude_x000d_\nconst magnitudeVtkArray = vtkDataArray.newInstance({_x000d_\nnumberOfComponents: 1, // Scalar data, only one component_x000d_\nvalues: magnitudeData, // Data values_x000d_\nname: 'velocityMagnitude', // Array name_x000d_\n});_x000d_\nimageData.getPointData().addArray(magnitudeVtkArray);_x000d_\n_x000d_\nimageData.getPointData().setActiveScalars('velocityMagnitude');_x000d_\nimageData.setSpacing(2.5, 2.5, 1.0);_x000d_\n_x000d_\nconst newRange = magnitudeVtkArray.getRange();_x000d_\nconsole.log('Velocity magnitude range:', newRange);_x000d_\nconst [minV, maxV] = newRange;_x000d_\n_x000d_\nconst marchingCube = vtkImageMarchingCubes.newInstance({_x000d_\ncontourValue: minV + 0.5 * (maxV - minV), // Set isosurface value to middle of data range_x000d_\ncomputeNormals: true, // Compute normals for lighting effects_x000d_\nmergePoints: true // Merge duplicate points to reduce data size_x000d_\n});_x000d_\n_x000d_\nmarchingCube.setInputData(imageData);_x000d_\n_x000d_\nconst mapper = vtkMapper.newInstance();_x000d_\nmapper.setInputConnection(marchingCube.getOutputPort());_x000d_\n_x000d_\nconst actor = vtkActor.newInstance();_x000d_\nactor.setMapper(mapper);_x000d_\nrenderer.addActor(actor);_x000d_\nconst camera = renderer.getActiveCamera();_x000d_\nrenderer.resetCameraClippingRange();_x000d_\nrenderer.resetCamera();_x000d_\nrenderWindow.render();_x000d_\n});_x000d_\n});_x000d_\n</script>_x000d_\n</body>_x000d_\n_x000d_\n</html>",
  "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Isabel Streamlines with Outline (vtk.js)</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      height: 100%;\n      overflow: hidden;\n      background: #000; /* Black background to match requirement of clean visualization */\n    }\n  </style>\n</head>\n<body>\n  <!-- Requirement: Use VTK.js from CDN (v34.10.0) -->\n  <script src=\"https://unpkg.com/vtk.js@34.10.0/vtk.js\"></script>\n  <script>\n    // Import required vtk.js modules using the vtk global namespace\n    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    const vtkActor = vtk.Rendering.Core.vtkActor;\n    const vtkMapper = vtk.Rendering.Core.vtkMapper;\n\n    const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader; // Requirement: vti format -> use vtkXMLImageDataReader (not HttpDatasetReader)\n    const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline; // Requirement: Compute streamlines following the velocity field\n    const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;     // Requirement: Render dataset outline\n    const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;         // Requirement: Generate seed points (plane at dataset center)\n\n    // ----------------------------------------------------------------------------\n    // Rendering setup (no UI controls -> clean view as requested)\n    // ----------------------------------------------------------------------------\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n      background: [0, 0, 0], // Black background\n    });\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // ----------------------------------------------------------------------------\n    // Pipeline creation after data loading\n    // ----------------------------------------------------------------------------\n    const reader = vtkXMLImageDataReader.newInstance();\n\n    // Requirement: Load the Isabel dataset from provided URL (vti format)\n    const DATA_URL = 'http://127.0.0.1:5000/dataset/isabel.vti';\n\n    // Load the VTI file using the correct XML reader\n    reader.setUrl(DATA_URL).then(() => {\n      // Get the image data\n      const imageData = reader.getOutputData();\n\n      // Requirement: Use \"Velocity\" array as the vector field for streamlines\n      // Ensure the \"Velocity\" array is set as the active vectors on the point data\n      const pd = imageData.getPointData();\n      const velocityArray = pd.getArrayByName('Velocity');\n      if (!velocityArray) {\n        console.error('Vector array \"Velocity\" not found in dataset. Check the dataset arrays.');\n      } else {\n        pd.setVectors(velocityArray); // This sets the active vector field used by vtkImageStreamline\n      }\n\n      // Requirement: Generate seed points at the center of the dataset with sufficient density to cover the domain\n      // Compute dataset bounds and center\n      const bounds = imageData.getBounds(); // [xmin, xmax, ymin, ymax, zmin, zmax]\n      const center = [\n        0.5 * (bounds[0] + bounds[1]),\n        0.5 * (bounds[2] + bounds[3]),\n        0.5 * (bounds[4] + bounds[5]),\n      ];\n\n      // Use an XY plane placed at the center Z, spanning the full XY domain\n      const planeSource = vtkPlaneSource.newInstance();\n      planeSource.setOrigin(bounds[0], bounds[2], center[2]);\n      planeSource.setPoint1(bounds[1], bounds[2], center[2]);\n      planeSource.setPoint2(bounds[0], bounds[3], center[2]);\n\n      // Choose seed density based on dataset dimensions, capped for performance\n      const dims = imageData.getDimensions(); // [nx, ny, nz]\n      const xRes = Math.min(60, Math.max(20, Math.floor(dims[0] / 4)));\n      const yRes = Math.min(60, Math.max(20, Math.floor(dims[1] / 4)));\n      planeSource.setXResolution(xRes);\n      planeSource.setYResolution(yRes);\n      // The plane's grid points serve as streamline seed points, covering the domain center slice\n\n      // Requirement: Compute streamlines following the velocity field\n      const streamlines = vtkImageStreamline.newInstance();\n\n      // Integration parameters: choose a step relative to voxel spacing to ensure stable tracing\n      const spacing = imageData.getSpacing();\n      const minSpacing = Math.min(spacing[0], spacing[1], spacing[2]);\n      streamlines.setIntegrationStep(0.4 * minSpacing); // reasonable step based on grid spacing\n\n      // Connect streamline inputs: port 0 -> vector image, port 1 -> seed geometry\n      streamlines.setInputConnection(reader.getOutputPort());          // vector field (image data)\n      streamlines.setInputConnection(planeSource.getOutputPort(), 1);  // seed points\n\n      // Requirement: Render streamlines in cyan ([0, 1, 1]) with a specified line width\n      const streamlineMapper = vtkMapper.newInstance();\n      streamlineMapper.setInputConnection(streamlines.getOutputPort());\n      streamlineMapper.setScalarVisibility(false); // use solid actor color\n\n      const streamlineActor = vtkActor.newInstance();\n      streamlineActor.setMapper(streamlineMapper);\n      streamlineActor.getProperty().setColor(0, 1, 1);   // cyan color\n      streamlineActor.getProperty().setLineWidth(2.5);   // specified line width (note: actual width may vary by platform)\n\n      // Requirement: Render a dataset outline in red ([1, 0, 0]) with a specified line width\n      const outlineFilter = vtkOutlineFilter.newInstance();\n      outlineFilter.setInputConnection(reader.getOutputPort());\n\n      const outlineMapper = vtkMapper.newInstance();\n      outlineMapper.setInputConnection(outlineFilter.getOutputPort());\n      outlineMapper.setScalarVisibility(false);\n\n      const outlineActor = vtkActor.newInstance();\n      outlineActor.setMapper(outlineMapper);\n      outlineActor.getProperty().setColor(1, 0, 0);    // red color\n      outlineActor.getProperty().setLineWidth(2.0);    // specified line width\n\n      // Add actors to the scene\n      renderer.addActor(streamlineActor);\n      renderer.addActor(outlineActor);\n\n      // Render\n      renderer.resetCamera();\n      renderWindow.render();\n    }).catch((err) => {\n      console.error('Failed to load VTI dataset:', err);\n    });\n\n    // Notes in code comments mapping to user requirements:\n    // - Used vtkXMLImageDataReader to load .vti (Requirement: correct IO module for vti; not HttpDatasetReader)\n    // - Loaded dataset from http://127.0.0.1:5000/dataset/isabel.vti (Requirement: specific path)\n    // - Set \"Velocity\" as the active vectors for streamlines (Requirement: use Velocity array)\n    // - Generated a central plane of seed points covering the domain with adequate density (Requirement: seed generation)\n    // - Computed streamlines using vtkImageStreamline (Requirement: streamline rendering)\n    // - Streamlines colored cyan with line width set (Requirement: streamline color & width)\n    // - Outline of dataset rendered in red with line width set (Requirement: outline color & width)\n    // - No UI controls were added (Requirement: display without UI unless requested)\n  </script>\n</body>\n</html>",
  "generator_prompt": "You are a VTK.js visualization expert. Based on the user's requirements and the provided VTK.js examples, generate complete and functional HTML code that meets all specified requirements.\n    Please follow these guidelines:\n    1. Generate complete HTML code that can run independently\n    2. Use the VTK.js library from CDN (https://unpkg.com/vtk.js@34.10.0/vtk.js)\n    3. Implement ALL requirements specified in the user question\n    4. Add detailed comments explaining how each requirement is implemented\n    5. Ensure the visualization is displayed properly without UI controls unless specifically requested\n    6. Pay special attention to data loading paths and visualization parameters\n    7. The data format for generating code is vti format, please use the correct IO module,The system reading method does not support HttpDatasetReader. Please use another appropriate module, such as vtkXMLImageDataReader\n    Important: Highlight in comments how each specific user requirement is addressed in the code.\n",
  "final_prompt": "\nGenerate only the HTML code without any additional text.\nUser Requirements:\nGenerate an HTML page using vtk.js to visualize the Isabel dataset with streamline rendering._x000d_\n_x000d_\nLoad the dataset from: http://127.0.0.1:5000/dataset/isabel.vti_x000d_\n_x000d_\nUse the \"Velocity\" array as the vector field for streamlines_x000d_\n_x000d_\nGenerate seed points at the center of the dataset with sufficient density to cover the domain_x000d_\n_x000d_\nCompute streamlines following the velocity field_x000d_\n_x000d_\nRender streamlines in cyan ([0, 1, 1]) with a specified line width_x000d_\n_x000d_\nRender a dataset outline in red ([1, 0, 0]) with a specified line width\n\nRelevant VTK.js Examples:\n\n--------------------------------------------------------------------------------Example 1 (Score: 30.00, Matches: vtkMapper, vtkActor, vtkOutlineFilter, vtkImageStreamline):\nDescription: Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkImageData, vtk.Filters.General.vtkImageStreamline, vtk.Filters.General.vtkOutlineFilter, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.Property, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Core.vtkProperty.Representation, vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance, vtk.macro\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageOutlineFilter</title>\n    <!-- <link rel=\"stylesheet\" href=\"https://kit.fontawesome.com/419a5ebb56.css\" crossorigin=\"anonymous\"> -->\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n\n    <script type=\"text/javascript\" src=\"https://unpkg.com/@babel/polyfill@7.0.0/dist/polyfill.js\"></script>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkImageStreamline = vtk.Filters.General.vtkImageStreamline;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        console.log(vtk.Rendering.Core.Property);\n\n        const Representation = vtk.Rendering.Core.vtkProperty.Representation;\n        // const Representation = Constants.representation;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const macro = vtk.macro;\n\n        // Load control panel HTML\n        const controlPanel = `<table>\n  <tr>\n    <td>X Resolution</td>\n    <td>\n      <input class='xResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n  <tr>\n    <td>Y Resolution</td>\n    <td>\n      <input class='yResolution' type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"10\" />\n    </td>\n  </tr>\n</table>\n`\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // ----------------------------------------------------------------------------\n        // Example code\n        // ----------------------------------------------------------------------------\n\n        function addRepresentation(name, filter, props = {}) {\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputConnection(filter.getOutputPort());\n\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n            actor.getProperty().set(props);\n            renderer.addActor(actor);\n\n            window[`${name}Actor`] = actor;\n            window[`${name}Mapper`] = mapper;\n        }\n\n        // ----------------------------------------------------------------------------\n\n        const vecSource = macro.newInstance((publicAPI, model) => {\n            macro.obj(publicAPI, model); // make it an object\n            macro.algo(publicAPI, model, 0, 1); // mixin algorithm code 1 in, 1 out\n            publicAPI.requestData = (inData, outData) => {\n                // implement requestData\n                if (!outData[0]) {\n                    const id = vtkImageData.newInstance();\n                    id.setSpacing(0.1, 0.1, 0.1);\n                    id.setExtent(0, 9, 0, 9, 0, 9);\n                    const dims = [10, 10, 10];\n\n                    const newArray = new Float32Array(3 * dims[0] * dims[1] * dims[2]);\n\n                    let i = 0;\n                    for (let z = 0; z <= 9; z++) {\n                        for (let y = 0; y <= 9; y++) {\n                            for (let x = 0; x <= 9; x++) {\n                                newArray[i++] = 0.1 * x;\n                                const v = 0.1 * y;\n                                newArray[i++] = v * v;\n                                newArray[i++] = 0;\n                            }\n                        }\n                    }\n\n                    const da = vtkDataArray.newInstance({\n                        numberOfComponents: 3,\n                        values: newArray,\n                    });\n                    da.setName('vectors');\n\n                    const cpd = id.getPointData();\n                    cpd.setVectors(da);\n\n                    // Update output\n                    outData[0] = id;\n                }\n            };\n        })();\n\n        const planeSource = vtkPlaneSource.newInstance();\n        planeSource.setOrigin(0.05, 0.05, 0.05);\n        planeSource.setPoint1(0.05, 0.85, 0.05);\n        planeSource.setPoint2(0.05, 0.05, 0.85);\n\n        const sline = vtkImageStreamline.newInstance();\n        sline.setIntegrationStep(0.01);\n        sline.setInputConnection(vecSource.getOutputPort());\n        sline.setInputConnection(planeSource.getOutputPort(), 1);\n\n        const outlineFilter = vtkOutlineFilter.newInstance();\n        outlineFilter.setInputConnection(vecSource.getOutputPort());\n\n        addRepresentation('streamLine', sline, {\n            diffuseColor: [0, 1, 1],\n            lineWidth: 5,\n        });\n        addRepresentation('outline', outlineFilter, {\n            diffuseColor: [1, 0, 0],\n            lineWidth: 3,\n        });\n        addRepresentation('seed', planeSource, {\n            representation: Representation.POINTS,\n            pointSize: 10,\n        });\n\n        // -----------------------------------------------------------\n\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // ----------------------------------------------------------------------------\n        // UI control handling\n        // ----------------------------------------------------------------------------\n\n        fullScreenRenderer.addController(controlPanel);\n\n        ['xResolution', 'yResolution'].forEach((propertyName) => {\n            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {\n                const value = Number(e.target.value);\n                planeSource.set({ [propertyName]: value });\n                renderWindow.render();\n            });\n        });\n\n        // -----------------------------------------------------------\n        // Make some variables global so that you can inspect and\n        // modify objects in your browser's developer console:\n        // -----------------------------------------------------------\n\n        window.planeSource = planeSource;\n        window.sline = sline;\n        window.outlineFilter = outlineFilter;\n        window.renderer = renderer;\n        window.renderWindow = renderWindow;\n\n\n    </script>\n\n</body>\n\n</html>\n\nExample 2 (Score: 20.00, Matches: vtkMapper, vtkActor):\nDescription: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n\nModules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // using vtk namespace\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints = vtk.Common.Core.vtkPoints;\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;\n\n        // ----------------------------------------------------------------------------\n        // Standard rendering code setup\n        // ----------------------------------------------------------------------------\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // setting vtkCalculator and set formula\n\n        const simpleFilter = vtkCalculator.newInstance();\n\n        simpleFilter.setFormulaSimple(\n            FieldDataTypes.POINT, // Generate an output array defined over points.\n            [], // We don't request any point-data arrays because point coordinates are made available by default.\n            'outputArray', // Name the output array \n            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125\n        ); \n\n        //using plane source to generate a poly data which can be rendered by vtkActor\n        const planeSource = vtkPlaneSource.newInstance({\n            xResolution: 25,\n            yResolution: 25,\n        });\n\n        const sourceData = planeSource.getOutputData();\n\n        simpleFilter.setInputData(sourceData);\n        const planeActor = vtkActor.newInstance();\n        const planeMapper = vtkMapper.newInstance();\n        planeMapper.setInputData(simpleFilter.getOutputData());\n        planeMapper.setColorByArrayName('outputArray'); \n\n        planeMapper.setScalarModeToUsePointFieldData();   \n        planeActor.setMapper(planeMapper);\n        planeActor.getProperty().setEdgeVisibility(true);\n\n        renderer.addActor(planeActor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 3 (Score: 20.00, Matches: vtkMapper, vtkActor):\nDescription: Generates a closed circular polyline from 16 points and triangulates it using `vtkContourTriangulator` for wireframe rendering.\n\nModules: vtk.Common.Core.vtkCellArray, vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkContourTriangulator, vtk.Filters.Sources.vtkSphereSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkCamera, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        //init necessary path \n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkSphereSource = vtk.Filters.Sources.vtkSphereSource;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkContourTriangulator = vtk.Filters.General.vtkContourTriangulator;\n        const vtkCamera = vtk.Rendering.Core.vtkCamera;\n        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;\n        const vtkPoints  = vtk.Common.Core.vtkPoints;\n        const vtkCellArray = vtk.Common.Core.vtkCellArray;\n\n        //init render actor and mapper\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        const actor = vtkActor.newInstance();\n        renderer.addActor(actor);\n\n        const mapper = vtkMapper.newInstance({ interpolateScalarBeforeMapping: true });\n        actor.setMapper(mapper);\n        actor.getProperty().setRepresentationToWireframe();\n        \n        // Generate a ring of points\n        const source = vtkPolyData.newInstance();\n        const nbPoints = 16;\n        const points = vtkPoints.newInstance({\n            size: nbPoints * 3,\n        });\n        source.setPoints(points);\n        const lines = vtkCellArray.newInstance();\n        source.setLines(lines);\n\n        for (let i = 0; i < nbPoints; i++) {\n            const phi = (i * (2 * Math.PI)) / nbPoints;\n            points.setPoint(i, Math.cos(phi), Math.sin(phi), 0);\n\n            // Connect points with lines\n            if (i === nbPoints - 1) {\n                lines.insertNextCell([i, 0]);\n            } else {\n                lines.insertNextCell([i, i + 1]);\n            }\n        }\n\n        //apply triangular filter on data sources \n        const filter = vtkContourTriangulator.newInstance();\n        filter.setInputData(source);\n        mapper.setInputConnection(filter.getOutputPort());\n\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n\n</html>\n\nExample 4 (Score: 20.00, Matches: vtkMapper, vtkActor):\nDescription: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n\nModules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js ImageLabelOutline</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Use the vtk namespace to reference each class\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n        const vtkImageData = vtk.Common.DataModel.vtkImageData;\n        const vtkDataArray = vtk.Common.Core.vtkDataArray;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n\n        // Use the vtk namespace to reference constants\n        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;\n        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.5, 0.5, 0.5],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const BACKGROUND = 0;\n        const LOW_VALUE = 80;\n        const HIGH_VALUE = 160;\n\n        const FIRST_SEGMENT = 1;\n        const SECOND_SEGMENT = 5;\n\n        /**\n         * Creates a labelmap image with the same dimensions as the background volume.\n         * @param {vtkImageData} backgroundImageData - The background volume data.\n         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.\n         */\n        function createLabelmap(backgroundImageData) {\n            // Create a labelmap image the same dimensions as our background volume.\n            const labelMapData = vtkImageData.newInstance(\n                backgroundImageData.get('spacing', 'origin', 'direction')\n            );\n\n            labelMapData.computeTransforms();\n\n            const dataArray = vtkDataArray.newInstance({\n                numberOfComponents: 1,\n                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),\n            });\n            labelMapData.getPointData().setScalars(dataArray);\n\n            labelMapData.setDimensions(...backgroundImageData.getDimensions());\n            labelMapData.setSpacing(...backgroundImageData.getSpacing());\n            labelMapData.setOrigin(...backgroundImageData.getOrigin());\n            labelMapData.setDirection(...backgroundImageData.getDirection());\n            const mapper = vtkImageMapper.newInstance();\n            mapper.setInputData(labelMapData);\n\n            const actor = vtkImageSlice.newInstance();\n\n            actor.setMapper(mapper);\n\n            const labelMap = {\n                actor,\n                mapper,\n                imageData: labelMapData,\n                cfun: vtkColorTransferFunction.newInstance(),\n                ofun: vtkPiecewiseFunction.newInstance(),\n            };\n\n            // Labelmap pipeline\n            labelMap.mapper.setInputData(labelMapData);\n            labelMap.actor.setMapper(labelMap.mapper);\n\n            // Set up labelMap color and opacity mapping\n            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label \"1\" will be red\n            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label \"5\" will be green\n            labelMap.ofun.addPoint(0, 0);\n            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.\n            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.\n\n            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);\n            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);\n            labelMap.actor.getProperty().setInterpolationTypeToNearest();\n\n            labelMap.actor.getProperty().setUseLabelOutline(true);\n            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4\n            // (positioned at array index 4)\n            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);\n            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);\n\n            // This is very important to make sure the labelmap is rendered\n            // correctly\n            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);\n\n            const dims = labelMap.imageData.getDimensions();\n            const values = labelMap.imageData.getPointData().getScalars().getData();\n\n            const backgroundValues = backgroundImageData\n                .getPointData()\n                .getScalars()\n                .getData();\n            const size = dims[0] * dims[1] * dims[2];\n\n            for (let i = 0; i < size; i++) {\n                if (backgroundValues[i] === LOW_VALUE) {\n                    values[i] = FIRST_SEGMENT;\n                } else if (backgroundValues[i] === HIGH_VALUE) {\n                    values[i] = SECOND_SEGMENT;\n                }\n            }\n\n            labelMap.imageData.getPointData().getScalars().setData(values);\n\n            return labelMap;\n        }\n\n        // Create a one slice vtkImageData that has four quadrants of different values\n        const imageData = vtkImageData.newInstance();\n        const dims = [10, 10, 1];\n        imageData.setSpacing(1, 1, 1);\n        imageData.setOrigin(0.1, 0.1, 0.1);\n        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);\n\n        imageData.computeTransforms();\n\n        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);\n\n        let i = 0;\n        for (let y = 0; y < dims[1]; y++) {\n            for (let x = 0; x < dims[0]; x++, i++) {\n                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {\n                    values[i] = BACKGROUND;\n                } else if (x > 4 && x < 6 && y > 4 && y < 7) {\n                    values[i] = LOW_VALUE;\n                } else {\n                    values[i] = HIGH_VALUE;\n                }\n            }\n        }\n\n        const dataArray = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values,\n        });\n        imageData.getPointData().setScalars(dataArray);\n        imageData.modified();\n\n        const data = imageData;\n        const labelMap = createLabelmap(data);\n\n        const actor = vtkImageSlice.newInstance();\n        const mapper = vtkImageMapper.newInstance();\n        mapper.setInputData(data);\n        actor.setMapper(mapper);\n        actor.getProperty().setInterpolationTypeToNearest();\n\n        renderer.addActor(actor);\n        renderer.addActor(labelMap.actor);\n        renderer.resetCamera();\n        renderer.resetCameraClippingRange();\n        renderWindow.render();\n\n        window.fullScreen = fullScreenRenderWindow;\n\n    </script>\n</body>\n\n</html>\n\nExample 5 (Score: 20.00, Matches: vtkMapper, vtkActor):\nDescription: Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.\nModules: vtk.Common.DataModel.vtkSphere, vtk.Filters.General.vtkImageMarchingCubes, vtk.Imaging.Hybrid.vtkSampleFunction, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n<body>\n    <script src=\"https://unpkg.com/vtk.js@32.6.0/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        const mCubes = vtkImageMarchingCubes.newInstance({ contourValue: 0.1 });\n        \n        //using the sphere function and sample function to create the source code\n        const vtkSphere = vtk.Common.DataModel.vtkSphere;\n        const vtkSampleFunction = vtk.Imaging.Hybrid.vtkSampleFunction;\n        const sphere = vtkSphere.newInstance({ center: [0.0, 0.0, 0.0], radius: 0.5 });\n        const sample = vtkSampleFunction.newInstance({\n            implicitFunction: sphere,\n            sampleDimensions: [50, 50, 50],\n            modelBounds: [-0.5, 0.5, -0.5, 0.5, -0.5, 0.5],\n        });\n\n        //connecting actor with render\n        const actor = vtkActor.newInstance();\n        renderer.addActor(actor);\n        \n        //connecting mapper with actor\n        const mapper = vtkMapper.newInstance();\n        actor.setMapper(mapper);\n\n        // Connect the pipeline proper\n        mCubes.setInputConnection(sample.getOutputPort());\n        mapper.setInputConnection(mCubes.getOutputPort());\n\n        renderer.resetCamera();\n        renderWindow.render();\n\n    </script>\n</body>\n\n</html>\n\nExample 6 (Score: 20.00, Matches: vtkMapper, vtkActor):\nDescription: Creates a 3D visualization by sampling an implicit boolean function and extracting contour lines with `vtkImageMarchingSquares`.\n\nModules: vtk.Common.DataModel.vtkImplicitBoolean, vtk.Common.DataModel.vtkPlane, vtk.Filters.General.vtkImageMarchingSquares, vtk.Filters.Sources.vtkSphereSource, vtk.Imaging.Hybrid.vtkSampleFunction, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow\nCode:\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n</head>\n\n<body>\n  <div id=\"renderer\"></div>\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <script>\n    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    const vtkActor = vtk.Rendering.Core.vtkActor;\n    const vtkSphereSource = vtk.Filters.Sources.vtkSphereSource;\n    const vtkMapper = vtk.Rendering.Core.vtkMapper;\n    const vtkImageMarchingSquares = vtk.Filters.General.vtkImageMarchingSquares;\n\n    const vtkPlane = vtk.Common.DataModel.vtkPlane;\n    const vtkImplicitBoolean = vtk.Common.DataModel.vtkImplicitBoolean;\n    const vtkSampleFunction = vtk.Imaging.Hybrid.vtkSampleFunction;\n\n    //const sphere = vtkSphereSource.newInstance({ center: [-2.5, 0.0, 0.0], radius: 0.5 });\n\n    const plane = vtkPlane.newInstance({ origin: [0, 0, 0], normal: [0, 1, 0] });\n\n    const { Operation } = vtkImplicitBoolean;\n\n    const impBool = vtkImplicitBoolean.newInstance({\n      operation: Operation.UNION,\n      functions: [plane],\n    });\n\n    const sample = vtkSampleFunction.newInstance({\n      implicitFunction: impBool,\n      sampleDimensions: [5, 3, 3],\n      modelBounds: [-5.0, 5.0, -1.0, 1.0, -1.0, 1.0],\n    });\n\n    ms = vtkImageMarchingSquares.newInstance();\n    //connect the sphere filter with the marchingsqures\n    ms.setInputConnection(sample.getOutputPort())\n\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputConnection(ms.getOutputPort());\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n\n\n    // adding actor into the scene\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // Add actor to renderer\n    renderer.addActor(actor);\n\n    // Reset camera and start rendering\n    renderer.resetCamera();\n    renderWindow.render();\n\n  </script>\n</body>\n\n</html>\n\n",
  "evaluator_prompt": "# Role\n\nYou are an expert Evaluator for vtk.js and web-based scientific visualization. Your task is to compare the [GENERATED_CODE] against the [GROUND_TRUTH] and evaluate it based on specific dimensions.\n\n# Input Data\n\n## Ground Truth Code:\n\n[GROUND_TRUTH]\n\n## Generated Code:\n\n[GENERATED_CODE]\n\n# Evaluation Criteria & Rubric (0.0 to 1.0)\n\nPlease evaluate the generated code based on the following 3 dimensions. \n\n1. **Functionality & Completeness (Task Completion)**: \n   - Does the code implement the same visualization pipeline as the ground truth? (e.g., correct readers, mappers, filters).\n   - Are critical elements present (e.g., color transfer functions, full-screen rendering)?\n   - Score 1.0 if logic is identical; lower if steps are missing.\n\n2. **Visual Fidelity (Visual Quality)**:\n   - Based on the code logic, will the visual output look similar to the ground truth?\n   - Check camera parameters, background colors, and opacity transfer functions.\n   - Check if the correct data arrays (scalars/vectors) are selected for coloring.\n\n3. **Code Quality & Maintainability**:\n   - Is the code readable, well-structured, and using vtk.js best practices?\n   - Is the variable naming clear?\n\n# Response Format\n\nYou must output the evaluation in the following Strict XML format. Do not use Markdown block quotes.\n\n<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>[SCORE_FLOAT]</Score>\n        <Reason>[BRIEF_REASONING]</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>[AVERAGE_SCORE]</OverallScore>\n        <Critique>[ONE_SENTENCE_SUMMARY]</Critique>\n    </Summary>\n</Evaluation>",
  "generator": "gpt-5",
  "evaluator": "qwen3-max",
  "score": null,
  "workflow": {
    "inquiryExpansion": true,
    "rag": true
  },
  "eval_id": "1765341696",
  "eval_user": "test",
  "export_time": null,
  "console_output": null,
  "eval_time": "2025-12-10 12:41:36",
  "evaluator_evaluation": {
    "score": "0.3",
    "evaluator_evaluation": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.0</Score>\n        <Reason>The generated code implements a completely different visualization task: it renders streamlines and an outline, while the ground truth renders an isosurface of velocity magnitude using marching cubes. Critical components like vtkImageMarchingCubes, velocity magnitude computation, and scalar field setup are missing.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.0</Score>\n        <Reason>The visual output will be fundamentally different: cyan streamlines and a red wireframe outline versus a single shaded isosurface colored by a transfer function (though not explicitly defined, the pipeline implies surface rendering with lighting). Camera setup and background differ slightly, but the core geometry is unrelated.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.9</Score>\n        <Reason>The generated code is well-structured, readable, uses clear variable names, includes helpful comments mapping to requirements, and follows vtk.js best practices for pipeline construction and error handling. However, it solves a different problem than intended.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.3</OverallScore>\n        <Critique>The generated code is high-quality but implements streamline visualization instead of the required isosurface rendering, resulting in complete functional and visual mismatch.</Critique>\n    </Summary>\n</Evaluation>",
    "parsed_evaluation": {
      "dimensions": {
        "Functionality": {
          "score": 0.0,
          "reason": "The generated code implements a completely different visualization task: it renders streamlines and an outline, while the ground truth renders an isosurface of velocity magnitude using marching cubes. Critical components like vtkImageMarchingCubes, velocity magnitude computation, and scalar field setup are missing."
        },
        "VisualQuality": {
          "score": 0.0,
          "reason": "The visual output will be fundamentally different: cyan streamlines and a red wireframe outline versus a single shaded isosurface colored by a transfer function (though not explicitly defined, the pipeline implies surface rendering with lighting). Camera setup and background differ slightly, but the core geometry is unrelated."
        },
        "CodeQuality": {
          "score": 0.9,
          "reason": "The generated code is well-structured, readable, uses clear variable names, includes helpful comments mapping to requirements, and follows vtk.js best practices for pipeline construction and error handling. However, it solves a different problem than intended."
        }
      },
      "overall": 0.3,
      "critique": "The generated code is high-quality but implements streamline visualization instead of the required isosurface rendering, resulting in complete functional and visual mismatch.",
      "raw_xml": "<Evaluation>\n    <Dimension name=\"Functionality\">\n        <Score>0.0</Score>\n        <Reason>The generated code implements a completely different visualization task: it renders streamlines and an outline, while the ground truth renders an isosurface of velocity magnitude using marching cubes. Critical components like vtkImageMarchingCubes, velocity magnitude computation, and scalar field setup are missing.</Reason>\n    </Dimension>\n    <Dimension name=\"VisualQuality\">\n        <Score>0.0</Score>\n        <Reason>The visual output will be fundamentally different: cyan streamlines and a red wireframe outline versus a single shaded isosurface colored by a transfer function (though not explicitly defined, the pipeline implies surface rendering with lighting). Camera setup and background differ slightly, but the core geometry is unrelated.</Reason>\n    </Dimension>\n    <Dimension name=\"CodeQuality\">\n        <Score>0.9</Score>\n        <Reason>The generated code is well-structured, readable, uses clear variable names, includes helpful comments mapping to requirements, and follows vtk.js best practices for pipeline construction and error handling. However, it solves a different problem than intended.</Reason>\n    </Dimension>\n    <Summary>\n        <OverallScore>0.3</OverallScore>\n        <Critique>The generated code is high-quality but implements streamline visualization instead of the required isosurface rendering, resulting in complete functional and visual mismatch.</Critique>\n    </Summary>\n</Evaluation>"
    }
  },
  "options": null,
  "analysis": [
    {
      "phase": "Data Loading",
      "step_name": "Load Isabel Dataset",
      "vtk_modules": [
        "vtkXMLImageDataReader"
      ],
      "description": "Load the Isabel dataset from 'http://127.0.0.1:5000/dataset/isabel.vti' using vtkXMLImageDataReader."
    },
    {
      "phase": "Data Processing",
      "step_name": "Generate Seed Points",
      "vtk_modules": [
        "vtkRTAnalyticSource",
        "vtkPlaneSource"
      ],
      "description": "Create a dense grid of seed points at the center of the dataset domain to ensure adequate coverage for streamline integration."
    },
    {
      "phase": "Data Processing",
      "step_name": "Compute Streamlines",
      "vtk_modules": [
        "vtkImageStreamline"
      ],
      "description": "Use the 'Velocity' vector field from the loaded dataset to compute streamlines starting from the generated seed points via vtkImageStreamline."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Configure Streamline Rendering",
      "vtk_modules": [
        "vtkMapper",
        "vtkActor"
      ],
      "description": "Set up streamline rendering with cyan color [0, 1, 1] and a specified line width using vtkMapper and vtkActor."
    },
    {
      "phase": "Visualization Setup",
      "step_name": "Render Dataset Outline",
      "vtk_modules": [
        "vtkOutlineFilter",
        "vtkMapper",
        "vtkActor"
      ],
      "description": "Apply vtkOutlineFilter to generate the dataset boundary, then render it in red [1, 0, 0] with a specified line width using vtkMapper and vtkActor."
    },
    {
      "phase": "Rendering & Interaction",
      "step_name": "Initialize Renderer",
      "vtk_modules": [
        "vtkRenderWindow",
        "vtkRenderer",
        "vtkRenderWindowInteractor"
      ],
      "description": "Create a renderer, add both streamline and outline actors, and initialize the render window and interactor for display."
    }
  ],
  "retrieval_results": [
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageStreamline\\code.html",
      "faiss_id": 1619381550,
      "description": "Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.\n",
      "vtkjs_modules": "['vtk.Common.Core.vtkDataArray', 'vtk.Common.DataModel.vtkImageData', 'vtk.Filters.General.vtkImageStreamline', 'vtk.Filters.General.vtkOutlineFilter', 'vtk.Filters.Sources.vtkPlaneSource', 'vtk.Rendering.Core.Property', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkMapper', 'vtk.Rendering.Core.vtkProperty.Representation', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance', 'vtk.macro']",
      "rerank_score": 18.0,
      "matched_keywords": "['vtkOutlineFilter', 'vtkActor']",
      "match_explanation": "[\"Query: 'Streamline Visualization  Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=5.0) -> Hit 1 keys\", \"Query: 'Outline Generation  Extract the outline of the dataset using vtkOutlineFilter;' (w=6.0) -> Hit 1 keys\", \"Query: 'Outline Rendering  Render the dataset outline in red ([1, 0, 0]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=4.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor, and vtkViewStream;' (w=3.0) -> Hit 1 keys\"]",
      "title": "Filter-ImageStreamline"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Rendering-ManyRenderers\\code.html",
      "faiss_id": 215600877,
      "description": "Displays multiple interactive 3D objects (cone, sphere, cube, cylinder) in separate, independently styled renderers with animation and layout adjustments.\n",
      "vtkjs_modules": "['vtk.Filters.Sources.vtkConeSource', 'vtk.Filters.Sources.vtkCubeSource', 'vtk.Filters.Sources.vtkCylinderSource', 'vtk.Filters.Sources.vtkSphereSource', 'vtk.Interaction.Style.vtkInteractorStyleTrackballCamera', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkMapper', 'vtk.Rendering.Core.vtkRenderWindow', 'vtk.Rendering.Core.vtkRenderWindowInteractor', 'vtk.Rendering.Core.vtkRenderer', 'vtk.js', 'vtk.jsvtk']",
      "rerank_score": 18.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkActor', 'vtkRenderer']",
      "match_explanation": "[\"Query: 'Streamline Visualization  Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=5.0) -> Hit 1 keys\", \"Query: 'Outline Rendering  Render the dataset outline in red ([1, 0, 0]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=4.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor, and vtkViewStream;' (w=3.0) -> Hit 3 keys\"]",
      "title": "Rendering-ManyRenderers"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-Calculator\\code.html",
      "faiss_id": 1276004285,
      "description": "This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.\n",
      "vtkjs_modules": "['vtk.Common.Core.vtkPoints', 'vtk.Common.DataModel.vtkDataSet.FieldDataTypes', 'vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes', 'vtk.Common.DataModel.vtkPolyData', 'vtk.Filters.General.vtkCalculator', 'vtk.Filters.Sources.vtkPlaneSource', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 15.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkActor']",
      "match_explanation": "[\"Query: 'Streamline Visualization  Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=5.0) -> Hit 1 keys\", \"Query: 'Outline Rendering  Render the dataset outline in red ([1, 0, 0]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=4.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor, and vtkViewStream;' (w=3.0) -> Hit 2 keys\"]",
      "title": "Filter-Calculator"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-ContourTriangulator\\code.html",
      "faiss_id": 600787990,
      "description": "Generates a closed circular polyline from 16 points and triangulates it using `vtkContourTriangulator` for wireframe rendering.\n",
      "vtkjs_modules": "['vtk.Common.Core.vtkCellArray', 'vtk.Common.Core.vtkPoints', 'vtk.Common.DataModel.vtkPolyData', 'vtk.Filters.General.vtkContourTriangulator', 'vtk.Filters.Sources.vtkSphereSource', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkCamera', 'vtk.Rendering.Core.vtkMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 15.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkActor']",
      "match_explanation": "[\"Query: 'Streamline Visualization  Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=5.0) -> Hit 1 keys\", \"Query: 'Outline Rendering  Render the dataset outline in red ([1, 0, 0]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=4.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor, and vtkViewStream;' (w=3.0) -> Hit 2 keys\"]",
      "title": "Filter-ContourTriangulator"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageLabelOutline\\code.html",
      "faiss_id": 144015752,
      "description": "Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.\n",
      "vtkjs_modules": "['vtk.Common.Core.vtkDataArray', 'vtk.Common.DataModel.vtkDataSet.FieldAssociations', 'vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes', 'vtk.Common.DataModel.vtkImageData', 'vtk.Common.DataModel.vtkPiecewiseFunction', 'vtk.Filters.General.vtkCalculator', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkColorTransferFunction', 'vtk.Rendering.Core.vtkImageMapper', 'vtk.Rendering.Core.vtkImageSlice', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 15.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkActor']",
      "match_explanation": "[\"Query: 'Streamline Visualization  Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=5.0) -> Hit 1 keys\", \"Query: 'Outline Rendering  Render the dataset outline in red ([1, 0, 0]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=4.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor, and vtkViewStream;' (w=3.0) -> Hit 2 keys\"]",
      "title": "Filter-ImageLabelOutline"
    },
    {
      "file_path": "data\\vtkjs-examples\\prompt-sample\\Filter-ImageMarchingCubes\\code.html",
      "faiss_id": 875726136,
      "description": "Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.",
      "vtkjs_modules": "['vtk.Common.DataModel.vtkSphere', 'vtk.Filters.General.vtkImageMarchingCubes', 'vtk.Imaging.Hybrid.vtkSampleFunction', 'vtk.Rendering.Core.vtkActor', 'vtk.Rendering.Core.vtkMapper', 'vtk.Rendering.Misc.vtkFullScreenRenderWindow']",
      "rerank_score": 15.0,
      "matched_keywords": "['vtkRenderWindow', 'vtkActor']",
      "match_explanation": "[\"Query: 'Streamline Visualization  Render streamlines in cyan ([0, 1, 1]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=5.0) -> Hit 1 keys\", \"Query: 'Outline Rendering  Render the dataset outline in red ([1, 0, 0]) with a specified line width using vtkPolyDataMapper and vtkActor;' (w=4.0) -> Hit 1 keys\", \"Query: 'Integrate all components and render the visualization using vtkRenderWindow, vtkRenderer, vtkActor, and vtkViewStream;' (w=3.0) -> Hit 2 keys\"]",
      "title": "Filter-ImageMarchingCubes"
    }
  ],
  "metadata": {
    "keyword_aware_retrieval_time": 0.01240658760070801,
    "retrieval_time_seconds": 0.01
  }
}