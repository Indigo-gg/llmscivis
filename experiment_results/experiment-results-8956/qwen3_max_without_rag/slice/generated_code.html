<!DOCTYPE html>
<html>
<head>
  <title>ROTOR Dataset Visualization</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    #vtkContainer {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="vtkContainer"></div>

  <script type="module">
    import vtk from 'https://unpkg.com/vtk.js@34.10.0/vtk.js';

    // Get container and create renderer, render window, and interactor
    const container = document.getElementById('vtkContainer');
    const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      background: [0.1, 0.1, 0.1],
      container: container,
    });
    const renderer = fullScreenRenderer.getRenderer();
    const renderWindow = fullScreenRenderer.getRenderWindow();

    // Create reader for VTI dataset
    const reader = vtk.IO.XML.vtkXMLImageDataReader.newInstance();
    
    // Load the rotor dataset from specified URL
    reader.setUrl('http://127.0.0.1:5000/dataset/rotor.vti').then(() => {
      reader.loadData().then(() => {
        const imageData = reader.getOutputData(0);
        
        // Set active scalar array to "Pressure"
        imageData.getPointData().setActiveScalars('Pressure');
        
        // Get data bounds and dimensions to calculate slice index at 95% depth along Y axis
        const bounds = imageData.getBounds();
        const dims = imageData.getDimensions();
        const yIndex = Math.floor((dims[1] - 1) * 0.95); // Convert 95% to slice index
        
        // Create image slice with Y-normal (slicing along Y axis)
        const slice = vtk.Filters.General.vtkImageSliceFilter.newInstance();
        slice.setSlicingMode(vtk.Filters.General.vtkImageSliceFilter.SlicingMode.Y);
        slice.setSliceIndex(yIndex);
        slice.setInputData(imageData);
        
        // Create color lookup table: blue → white → red
        const lookupTable = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
        const dataArray = imageData.getPointData().getScalars();
        const range = dataArray.getRange();
        lookupTable.addRGBPoint(range[0], 0, 0, 1);     // Blue at min
        lookupTable.addRGBPoint((range[0] + range[1]) / 2, 1, 1, 1); // White at midpoint
        lookupTable.addRGBPoint(range[1], 1, 0, 0);     // Red at max
        
        // Create mapper for the slice
        const mapper = vtk.Rendering.Core.vtkImageMapper.newInstance();
        mapper.setInputConnection(slice.getOutputPort());
        mapper.setColorWindow(range[1] - range[0]);
        mapper.setColorLevel((range[1] + range[0]) / 2);
        mapper.setLookupTable(lookupTable);
        
        // Create actor and set opacity to fully opaque (1.0)
        const actor = vtk.Rendering.Core.vtkImageSlice.newInstance();
        actor.setMapper(mapper);
        actor.getProperty().setOpacity(1.0); // Fully opaque
        
        // Add actor to renderer
        renderer.addActor(actor);
        
        // Add orientation marker (axes in bottom-right corner)
        const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();
        const orientationWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({
          actor: axes,
          interactor: renderWindow.getInteractor(),
        });
        orientationWidget.setEnabled(true);
        orientationWidget.setViewportCorner(
          vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
        );
        orientationWidget.setViewportSize(0.15);
        orientationWidget.setMinPixelSize(100);
        orientationWidget.setMaxPixelSize(300);
        
        // Reset camera and render
        renderer.resetCamera();
        renderWindow.render();
      });
    }).catch(error => {
      console.error('Error loading dataset:', error);
    });
  </script>
</body>
</html>