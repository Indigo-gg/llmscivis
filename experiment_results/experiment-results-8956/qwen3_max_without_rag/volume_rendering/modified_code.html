<!DOCTYPE html>
<html>
<head>
  <title>Redsea Volume Rendering</title>
  <script src="https://unpkg.com/vtk.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    #vtkContainer {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="vtkContainer"></div>

  <script>
    // Initialize rendering pipeline
    const container = document.getElementById('vtkContainer');
    const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: container,
      background: [0, 0, 0],
    });

    const renderer = fullScreenRenderer.getRenderer();
    const renderWindow = fullScreenRenderer.getRenderWindow();

    // Create volume mapper and actor
    const volumeMapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();
    const volumeActor = vtk.Rendering.Core.vtkVolume.newInstance();
    volumeActor.setMapper(volumeMapper);

    // Load Redsea dataset
    const reader = vtk.IO.XML.vtkXMLImageDataReader.newInstance();
    
    reader.setUrl('http://127.0.0.1:5000/dataset/redsea.vti').then(() => {
      const imageData = reader.getOutputData(0);
      
      // Compute velocity magnitude from "velocity" array
      const velocityArray = imageData.getPointData().getArray('velocity');
      if (velocityArray) {
        const numTuples = velocityArray.getNumberOfTuples();
        const magnitudeArray = new Float32Array(numTuples);
        
        for (let i = 0; i < numTuples; i++) {
          const x = velocityArray.getComponent(i, 0);
          const y = velocityArray.getComponent(i, 1);
          const z = velocityArray.getComponent(i, 2);
          magnitudeArray[i] = Math.sqrt(x * x + y * y + z * z);
        }
        
        // Create new scalar array for magnitude
        const magnitudeDataArray = vtk.Common.Core.vtkDataArray.newInstance({
          name: 'VelocityMagnitude',
          values: magnitudeArray,
          numberOfComponents: 1,
        });
        
        // Set as active scalars
        imageData.getPointData().setScalars(magnitudeDataArray);
        
        // Get scalar range for color mapping
        const range = magnitudeDataArray.getRange();
        
        // Create color transfer function (blue → white → red)
        const ctfun = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
        ctfun.addRGBPoint(range[0], 0, 0, 1);     // Blue at min
        ctfun.addRGBPoint((range[0] + range[1]) / 2, 1, 1, 1); // White at mid
        ctfun.addRGBPoint(range[1], 1, 0, 0);     // Red at max
        
        // Create opacity function
        const ofun = vtk.Common.DataModel.vtkPiecewiseFunction.newInstance();
        ofun.addPoint(range[0], 0.0);
        ofun.addPoint(range[0] + (range[1] - range[0]) * 0.2, 0.1);
        ofun.addPoint(range[0] + (range[1] - range[0]) * 0.5, 0.3);
        ofun.addPoint(range[1], 0.6);
        
        // Set volume properties
        const volumeProperty = volumeActor.getProperty();
        volumeProperty.setRGBTransferFunction(0, ctfun);
        volumeProperty.setScalarOpacity(0, ofun);
        
        // Set shading properties for realistic appearance
        volumeProperty.setShade(true);
        volumeProperty.setAmbient(0.2);
        volumeProperty.setDiffuse(0.7);
        volumeProperty.setSpecular(0.3);
        volumeProperty.setSpecularPower(10.0);
        
        // Set the data to the mapper
        volumeMapper.setInputData(imageData);
        
        // Add volume to renderer
        renderer.addVolume(volumeActor);
        
        // Adjust camera to look along +Z and center on dataset
        renderer.resetCamera();
        const bounds = imageData.getBounds();
        const center = [
          (bounds[0] + bounds[1]) / 2,
          (bounds[2] + bounds[3]) / 2,
          (bounds[4] + bounds[5]) / 2
        ];
        
        // Position camera to look along +Z axis
        renderer.getActiveCamera().setPosition(center[0], center[1], center[2] - 100);
        renderer.getActiveCamera().setFocalPoint(center[0], center[1], center[2]);
        renderer.getActiveCamera().setViewUp(0, 1, 0);
        
        // Render
        renderWindow.render();
      }
    }).catch(error => {
      console.error('Error loading dataset:', error);
    });
  </script>
</body>
</html>