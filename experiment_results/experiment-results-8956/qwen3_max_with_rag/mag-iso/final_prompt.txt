
Generate only the HTML code without any additional text.
User Requirements:
Generate an HTML page using vtk.js to visualize the Deepwater dataset with isosurface rendering._x000d_
_x000d_
Load the dataset from: http://127.0.0.1:5000/dataset/deepwater.vti_x000d_
_x000d_
Compute velocity magnitude from arrays v02 and v03; if not available, use prs as the scalar_x000d_
_x000d_
Generate an isosurface at the mid-value of the scalar range_x000d_
_x000d_
Use a blue → white → red color map spanning the scalar range (min to max)_x000d_
_x000d_
Set the isosurface to fully opaque with smooth shading_x000d_
_x000d_
Add an XYZ orientation marker in the bottom-right corner

Relevant VTK.js Examples:

--------------------------------------------------------------------------------Example 1 (Score: 5.00, Matches: vtkCalculator):
Description: This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.

Modules: vtk.Common.Core.vtkPoints, vtk.Common.DataModel.vtkDataSet.FieldDataTypes, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkPolyData, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // using vtk namespace
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
        const vtkPolyData = vtk.Common.DataModel.vtkPolyData;
        const vtkPoints = vtk.Common.Core.vtkPoints;
        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldDataTypes;

        // ----------------------------------------------------------------------------
        // Standard rendering code setup
        // ----------------------------------------------------------------------------

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // setting vtkCalculator and set formula

        const simpleFilter = vtkCalculator.newInstance();

        simpleFilter.setFormulaSimple(
            FieldDataTypes.POINT, // Generate an output array defined over points.
            [], // We don't request any point-data arrays because point coordinates are made available by default.
            'outputArray', // Name the output array 
            (x) => (x[0] - 0.5) * (x[0] - 0.5) + (x[1] - 0.5) * (x[1] - 0.5) + 0.125
        ); 

        //using plane source to generate a poly data which can be rendered by vtkActor
        const planeSource = vtkPlaneSource.newInstance({
            xResolution: 25,
            yResolution: 25,
        });

        const sourceData = planeSource.getOutputData();

        simpleFilter.setInputData(sourceData);
        const planeActor = vtkActor.newInstance();
        const planeMapper = vtkMapper.newInstance();
        planeMapper.setInputData(simpleFilter.getOutputData());
        planeMapper.setColorByArrayName('outputArray'); 

        planeMapper.setScalarModeToUsePointFieldData();   
        planeActor.setMapper(planeMapper);
        planeActor.getProperty().setEdgeVisibility(true);

        renderer.addActor(planeActor);
        renderer.resetCamera();
        renderWindow.render();
    </script>
</body>

</html>

Example 2 (Score: 5.00, Matches: vtkCalculator):
Description: Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.

Modules: vtk.Common.Core.vtkDataArray, vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Common.DataModel.vtkImageData, vtk.Common.DataModel.vtkPiecewiseFunction, vtk.Filters.General.vtkCalculator, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkColorTransferFunction, vtk.Rendering.Core.vtkImageMapper, vtk.Rendering.Core.vtkImageSlice, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js ImageLabelOutline</title>
    <style>
        #renderer {
            width: 100%;
            height: 600px;
            background-color: #333;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // Use the vtk namespace to reference each class
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const vtkImageData = vtk.Common.DataModel.vtkImageData;
        const vtkDataArray = vtk.Common.Core.vtkDataArray;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;

        // Use the vtk namespace to reference constants
        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [0.5, 0.5, 0.5],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const BACKGROUND = 0;
        const LOW_VALUE = 80;
        const HIGH_VALUE = 160;

        const FIRST_SEGMENT = 1;
        const SECOND_SEGMENT = 5;

        /**
         * Creates a labelmap image with the same dimensions as the background volume.
         * @param {vtkImageData} backgroundImageData - The background volume data.
         * @returns {Object} An object containing the labelmap actor, mapper, image data, color transfer function, and opacity function.
         */
        function createLabelmap(backgroundImageData) {
            // Create a labelmap image the same dimensions as our background volume.
            const labelMapData = vtkImageData.newInstance(
                backgroundImageData.get('spacing', 'origin', 'direction')
            );

            labelMapData.computeTransforms();

            const dataArray = vtkDataArray.newInstance({
                numberOfComponents: 1,
                values: new Uint8Array(backgroundImageData.getNumberOfPoints()),
            });
            labelMapData.getPointData().setScalars(dataArray);

            labelMapData.setDimensions(...backgroundImageData.getDimensions());
            labelMapData.setSpacing(...backgroundImageData.getSpacing());
            labelMapData.setOrigin(...backgroundImageData.getOrigin());
            labelMapData.setDirection(...backgroundImageData.getDirection());
            const mapper = vtkImageMapper.newInstance();
            mapper.setInputData(labelMapData);

            const actor = vtkImageSlice.newInstance();

            actor.setMapper(mapper);

            const labelMap = {
                actor,
                mapper,
                imageData: labelMapData,
                cfun: vtkColorTransferFunction.newInstance(),
                ofun: vtkPiecewiseFunction.newInstance(),
            };

            // Labelmap pipeline
            labelMap.mapper.setInputData(labelMapData);
            labelMap.actor.setMapper(labelMap.mapper);

            // Set up labelMap color and opacity mapping
            labelMap.cfun.addRGBPoint(0, 0, 0, 0); // label "1" will be red
            labelMap.cfun.addRGBPoint(FIRST_SEGMENT, 1, 0, 0); // label "1" will be red
            labelMap.cfun.addRGBPoint(SECOND_SEGMENT, 0, 1, 0); // label "5" will be green
            labelMap.ofun.addPoint(0, 0);
            labelMap.ofun.addPoint(FIRST_SEGMENT, 0.1); // Red will have an opacity of 0.1.
            labelMap.ofun.addPoint(SECOND_SEGMENT, 0.1); // Green will have an opacity of 0.1.

            labelMap.actor.getProperty().setRGBTransferFunction(0, labelMap.cfun);
            labelMap.actor.getProperty().setScalarOpacity(0, labelMap.ofun);
            labelMap.actor.getProperty().setInterpolationTypeToNearest();

            labelMap.actor.getProperty().setUseLabelOutline(true);
            // Label outline thickness is for first segment -> 2 (positioned at array index 0), second segment -> 4
            // (positioned at array index 4)
            labelMap.actor.getProperty().setLabelOutlineThickness([2, 1, 1, 1, 4]);
            labelMap.actor.getProperty().setLabelOutlineOpacity(1.0);

            // This is very important to make sure the labelmap is rendered
            // correctly
            labelMap.actor.getProperty().setUseLookupTableScalarRange(true);

            const dims = labelMap.imageData.getDimensions();
            const values = labelMap.imageData.getPointData().getScalars().getData();

            const backgroundValues = backgroundImageData
                .getPointData()
                .getScalars()
                .getData();
            const size = dims[0] * dims[1] * dims[2];

            for (let i = 0; i < size; i++) {
                if (backgroundValues[i] === LOW_VALUE) {
                    values[i] = FIRST_SEGMENT;
                } else if (backgroundValues[i] === HIGH_VALUE) {
                    values[i] = SECOND_SEGMENT;
                }
            }

            labelMap.imageData.getPointData().getScalars().setData(values);

            return labelMap;
        }

        // Create a one slice vtkImageData that has four quadrants of different values
        const imageData = vtkImageData.newInstance();
        const dims = [10, 10, 1];
        imageData.setSpacing(1, 1, 1);
        imageData.setOrigin(0.1, 0.1, 0.1);
        imageData.setDirection(1, 0, 0, 0, 1, 0, 0, 0, 1);
        imageData.setExtent(0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1);

        imageData.computeTransforms();

        const values = new Uint8Array(dims[0] * dims[1] * dims[2]);

        let i = 0;
        for (let y = 0; y < dims[1]; y++) {
            for (let x = 0; x < dims[0]; x++, i++) {
                if ((x < 3 && y < 3) || (x > 7 && y > 7)) {
                    values[i] = BACKGROUND;
                } else if (x > 4 && x < 6 && y > 4 && y < 7) {
                    values[i] = LOW_VALUE;
                } else {
                    values[i] = HIGH_VALUE;
                }
            }
        }

        const dataArray = vtkDataArray.newInstance({
            numberOfComponents: 1,
            values,
        });
        imageData.getPointData().setScalars(dataArray);
        imageData.modified();

        const data = imageData;
        const labelMap = createLabelmap(data);

        const actor = vtkImageSlice.newInstance();
        const mapper = vtkImageMapper.newInstance();
        mapper.setInputData(data);
        actor.setMapper(mapper);
        actor.getProperty().setInterpolationTypeToNearest();

        renderer.addActor(actor);
        renderer.addActor(labelMap.actor);
        renderer.resetCamera();
        renderer.resetCameraClippingRange();
        renderWindow.render();

        window.fullScreen = fullScreenRenderWindow;

    </script>
</body>

</html>

Example 3 (Score: 5.00, Matches: vtkCalculator):
Description: Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).

Modules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>

    <script>
        // Use vtk namespace to reference classes
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;

        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;

        const controlPanel = `<table>
  <tr>
    <td>X Resolution</td>
    <td>
      <input class='xResolution' type="range" min="1" max="25" step="1" value="10" />
    </td>
  </tr>
  <tr>
    <td>Y Resolution</td>
    <td>
      <input class='yResolution' type="range" min="1" max="25" step="1" value="10" />
    </td>
  </tr>
</table>`;

        // ----------------------------------------------------------------------------
        // Standard rendering code setup
        // ----------------------------------------------------------------------------

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // ----------------------------------------------------------------------------
        // Example code
        // ----------------------------------------------------------------------------

        const planeSource = vtkPlaneSource.newInstance({
            xResolution: 25,
            yResolution: 25,
        });


        console.log(planeSource.getOutputData().toJSON());

        const simpleFilter = vtkCalculator.newInstance();
        const mapper = vtkStickMapper.newInstance();
        const actor = vtkActor.newInstance();

        simpleFilter.setFormula({
            getArrays: (inputDataSets) => ({
                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input
                output: [
                    // Generate two output arrays:
                    {
                        location: FieldDataTypes.POINT, // This array will be point-data ...
                        name: 'orientation', // ... with the given name ...
                        dataType: 'Float32Array', // ... of this type ...
                        numberOfComponents: 3, // ... with this many components ...
                    },
                    {
                        location: FieldDataTypes.POINT, // This array will be field data ...
                        name: 'temperature', // ... with the given name ...
                        dataType: 'Float32Array', // ... of this type ...
                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.
                        numberOfComponents: 1, // ... with this many components ...
                    },
                    {
                        location: FieldDataTypes.POINT, // This array will be field data ...
                        name: 'pressure', // ... with the given name ...
                        dataType: 'Float32Array', // ... of this type ...
                        numberOfComponents: 2, // ... with this many components ...
                    },
                ],
            }),
            evaluate: (arraysIn, arraysOut) => {
                // Convert in the input arrays of vtkDataArrays into variables
                // referencing the underlying JavaScript typed-data arrays:
                // array in is null here?
                console.log("arraysIn:", arraysIn());
                const [coords] = arraysIn.map((d) => d.getData());
                const [orient, temp, press] = arraysOut.map((d) => d.getData());

                // Since we are passed coords as a 3-component array,
                // loop over all the points and compute the point-data output:
                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {
                    orient[i * 3] =
                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +
                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);
                    orient[i * 3 + 1] =
                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +
                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);
                    orient[i * 3 + 2] = 1.0;

                    temp[i] = coords[3 * i + 1];

                    press[i * 2] =
                        (coords[3 * i] * coords[3 * i] +
                            coords[3 * i + 1] * coords[3 * i + 1]) *
                        0.05 +
                        0.05;
                    press[i * 2 + 1] =
                        (coords[3 * i] * coords[3 * i] +
                            coords[3 * i + 1] * coords[3 * i + 1]) *
                        0.01 +
                        0.01;
                }
                // Mark the output vtkDataArray as modified
                arraysOut.forEach((x) => x.modified());
            },
        });

        // The generated 'temperature' array will become the default scalars
        // so the plane mapper will color by 'temperature':
        simpleFilter.setInputData(planeSource.getOutputData());
        simpleFilter.update();
        concole.log(simpleFilter.getOutputData());

        //mapper.setInputConnection(simpleFilter.getOutputPort());

        //mapper.setOrientationArray('orientation');
        //mapper.setScaleArray('pressure');

        //actor.setMapper(mapper);

       // renderer.addActor(actor);
       // renderer.resetCamera();
        //renderWindow.render();

        // -----------------------------------------------------------
        // UI control handling
        // -----------------------------------------------------------

        // fullScreenRenderer.addController(controlPanel);
        // ['xResolution', 'yResolution'].forEach((propertyName) => {
        //     document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {
        //         const value = Number(e.target.value);
        //         console.log("propertyName",propertyName);
        //         console.log("value",value);
        //         planeSource.set({ [propertyName]: value });
        //         renderWindow.render();
        //     });
        // });

        // -----------------------------------------------------------
        // Make some variables global so that you can inspect and
        // modify objects in your browser's developer console:
        // -----------------------------------------------------------

        window.planeSource = planeSource;
        window.mapper = mapper;
        window.actor = actor;
        window.renderer = renderer;
        window.renderWindow = renderWindow;

    </script>
</body>

</html>

Example 4 (Score: 5.00, Matches: vtkCalculator):
Description: Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.

Modules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkConeSource, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkGlyph3DMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtkjs- Rendering-GlyphMapper</title>
</head>



<body>

    <script src="https://unpkg.com/vtk.js"></script>

    <script>
        // Assuming vtk object is properly imported and available in global environment, proceed with corresponding assignments
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;
        const vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;
        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;
        const controlPanel = `<table>
  <tr>
    <td>X Resolution</td>
    <td>
      <input class='xResolution' type="range" min="1" max="25" step="1" value="10" />
    </td>
  </tr>
  <tr>
    <td>Y Resolution</td>
    <td>
      <input class='yResolution' type="range" min="1" max="25" step="1" value="10" />
    </td>
  </tr>
</table>
`

        // ----------------------------------------------------------------------------
        // Standard rendering code setup
        // ----------------------------------------------------------------------------

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // ----------------------------------------------------------------------------
        // Example code
        // ----------------------------------------------------------------------------

        const planeSource = vtkPlaneSource.newInstance();
        const simpleFilter = vtkCalculator.newInstance();
        const mapper = vtkGlyph3DMapper.newInstance();
        const actor = vtkActor.newInstance();

        simpleFilter.setFormula({
            getArrays: (inputDataSets) => ({
                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input
                output: [
                    // Generate two output arrays:
                    {
                        location: FieldDataTypes.POINT, // This array will be point-data...
                        name: 'pressure', //... with the given name...
                        dataType: 'Float32Array', //... of this type...
                        numberOfComponents: 3, //... with this many components...
                    },
                    {
                        location: FieldDataTypes.POINT, // This array will be field data...
                        name: 'temperature', //... with the given name...
                        dataType: 'Float32Array', //... of this type...
                        attribute: AttributeTypes.SCALARS, //... and will be marked as the default scalars.
                        numberOfComponents: 1, //... with this many components...
                    },
                ],
            }),
            evaluate: (arraysIn, arraysOut) => {
                // Convert in the input arrays of vtkDataArrays into variables
                // referencing the underlying JavaScript typed-data arrays:
                const [coords] = arraysIn.map((d) => d.getData());
                const [press, temp] = arraysOut.map((d) => d.getData());

                // Since we are passed coords as a 3-component array,
                // loop over all the points and compute the point-data output:
                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {
                    press[i * 3] = (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5);
                    press[i * 3 + 1] =
                        ((coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) + 0.125) * 0.1;
                    press[i * 3 + 2] =
                        ((coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +
                            (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5) +
                            0.125) *
                        0.1;
                    temp[i] = coords[3 * i + 1] * 0.1;
                }

                // Mark the output vtkDataArray as modified
                arraysOut.forEach((x) => x.modified());
            },
        });


        // console.log("planeSource", planeSource.getOutputPort)
        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':
        simpleFilter.setInputConnection(planeSource.getOutputPort());

        mapper.setInputConnection(simpleFilter.getOutputPort(), 0);

        const coneSource = vtkConeSource.newInstance();
        coneSource.setResolution(12);
        mapper.setInputConnection(coneSource.getOutputPort(), 1);
        mapper.setOrientationArray('pressure');
        mapper.setScalarRange(0.0, 0.1);

        actor.setMapper(mapper);

        renderer.addActor(actor);
        renderer.resetCamera();
        renderWindow.render();

        // -----------------------------------------------------------
        // UI control handling
        // -----------------------------------------------------------

        fullScreenRenderer.addController(controlPanel);
        ['xResolution', 'yResolution'].forEach((propertyName) => {
            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {
                const value = Number(e.target.value);
                planeSource.set({ [propertyName]: value });
                renderWindow.render();
            });
        });

        // -----------------------------------------------------------
        // Make some variables global so that you can inspect and
        // modify objects in your browser's developer console:
        // -----------------------------------------------------------

        window.planeSource = planeSource;
        window.mapper = mapper;
        window.actor = actor;
        window.renderer = renderer;
        window.renderWindow = renderWindow;
    </script>

</body>

</html>

Example 5 (Score: 5.00, Matches: vtkCalculator):
Description: Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.

Modules: vtk.Common.DataModel.vtkDataSet.FieldAssociations, vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes, vtk.Filters.General.vtkCalculator, vtk.Filters.Sources.vtkPlaneSource, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkStickMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vtk.js StickMapper</title>
    <link rel="stylesheet" href="https://kit.fontawesome.com/419a5ebb56.css" crossorigin="anonymous">
    <style>
        #renderer {
            width: 100%;
            height: 600px;
            background-color: #333;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Geometry"></script>
    <script src="https://unpkg.com/vtk.js/Sources/Rendering/Profiles/Molecule"></script>
    <script src="https://unpkg.com/vtk.js"></script>

    <script>
        // Use vtk namespace to reference classes
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkCalculator = vtk.Filters.General.vtkCalculator;
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkPlaneSource = vtk.Filters.Sources.vtkPlaneSource;
        const vtkStickMapper = vtk.Rendering.Core.vtkStickMapper;

        const AttributeTypes = vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes;
        const FieldDataTypes = vtk.Common.DataModel.vtkDataSet.FieldAssociations;

        const controlPanel = `<table>
  <tr>
    <td>X Resolution</td>
    <td>
      <input class='xResolution' type="range" min="1" max="25" step="1" value="10" />
    </td>
  </tr>
  <tr>
    <td>Y Resolution</td>
    <td>
      <input class='yResolution' type="range" min="1" max="25" step="1" value="10" />
    </td>
  </tr>
</table>`;

        // ----------------------------------------------------------------------------
        // Standard rendering code setup
        // ----------------------------------------------------------------------------

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            background: [0, 0, 0],
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // ----------------------------------------------------------------------------
        // Example code
        // ----------------------------------------------------------------------------

        const planeSource = vtkPlaneSource.newInstance();
        const simpleFilter = vtkCalculator.newInstance();
        const mapper = vtkStickMapper.newInstance();
        const actor = vtkActor.newInstance();

        simpleFilter.setFormula({
            getArrays: (inputDataSets) => ({
                input: [{ location: FieldDataTypes.COORDINATE }], // Require point coordinates as input
                output: [
                    // Generate two output arrays:
                    {
                        location: FieldDataTypes.POINT, // This array will be point-data ...
                        name: 'orientation', // ... with the given name ...
                        dataType: 'Float32Array', // ... of this type ...
                        numberOfComponents: 3, // ... with this many components ...
                    },
                    {
                        location: FieldDataTypes.POINT, // This array will be field data ...
                        name: 'temperature', // ... with the given name ...
                        dataType: 'Float32Array', // ... of this type ...
                        attribute: AttributeTypes.SCALARS, // ... and will be marked as the default scalars.
                        numberOfComponents: 1, // ... with this many components ...
                    },
                    {
                        location: FieldDataTypes.POINT, // This array will be field data ...
                        name: 'pressure', // ... with the given name ...
                        dataType: 'Float32Array', // ... of this type ...
                        numberOfComponents: 2, // ... with this many components ...
                    },
                ],
            }),
            evaluate: (arraysIn, arraysOut) => {
                // Convert in the input arrays of vtkDataArrays into variables
                // referencing the underlying JavaScript typed-data arrays:
                const [coords] = arraysIn.map((d) => d.getData());
                const [orient, temp, press] = arraysOut.map((d) => d.getData());

                // Since we are passed coords as a 3-component array,
                // loop over all the points and compute the point-data output:
                for (let i = 0, sz = coords.length / 3; i < sz; ++i) {
                    orient[i * 3] =
                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +
                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);
                    orient[i * 3 + 1] =
                        (coords[3 * i] - 0.5) * (coords[3 * i] - 0.5) +
                        (coords[3 * i + 1] - 0.5) * (coords[3 * i + 1] - 0.5);
                    orient[i * 3 + 2] = 1.0;

                    temp[i] = coords[3 * i + 1];

                    press[i * 2] =
                        (coords[3 * i] * coords[3 * i] +
                            coords[3 * i + 1] * coords[3 * i + 1]) *
                        0.05 +
                        0.05;
                    press[i * 2 + 1] =
                        (coords[3 * i] * coords[3 * i] +
                            coords[3 * i + 1] * coords[3 * i + 1]) *
                        0.01 +
                        0.01;
                }
                // Mark the output vtkDataArray as modified
                arraysOut.forEach((x) => x.modified());
            },
        });

        // The generated 'temperature' array will become the default scalars, so the plane mapper will color by 'temperature':
        simpleFilter.setInputConnection(planeSource.getOutputPort());

        mapper.setInputConnection(simpleFilter.getOutputPort());

        mapper.setOrientationArray('orientation');
        mapper.setScaleArray('pressure');

        actor.setMapper(mapper);

        renderer.addActor(actor);
        renderer.resetCamera();
        renderWindow.render();

        // -----------------------------------------------------------
        // UI control handling
        // -----------------------------------------------------------

        fullScreenRenderer.addController(controlPanel);
        ['xResolution', 'yResolution'].forEach((propertyName) => {
            document.querySelector(`.${propertyName}`).addEventListener('input', (e) => {
                const value = Number(e.target.value);
                planeSource.set({ [propertyName]: value });
                renderWindow.render();
            });
        });

        // -----------------------------------------------------------
        // Make some variables global so that you can inspect and
        // modify objects in your browser's developer console:
        // -----------------------------------------------------------

        window.planeSource = planeSource;
        window.mapper = mapper;
        window.actor = actor;
        window.renderer = renderer;
        window.renderWindow = renderWindow;

    </script>
</body>

</html>

Example 6 (Score: 5.00, Matches: vtkImageMarchingCubes):
Description: Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.
Modules: vtk.Common.DataModel.vtkSphere, vtk.Filters.General.vtkImageMarchingCubes, vtk.Imaging.Hybrid.vtkSampleFunction, vtk.Rendering.Core.vtkActor, vtk.Rendering.Core.vtkMapper, vtk.Rendering.Misc.vtkFullScreenRenderWindow
Code:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
</head>

<body>
    <script src="https://unpkg.com/vtk.js@32.6.0/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;

        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        const mCubes = vtkImageMarchingCubes.newInstance({ contourValue: 0.1 });
        
        //using the sphere function and sample function to create the source code
        const vtkSphere = vtk.Common.DataModel.vtkSphere;
        const vtkSampleFunction = vtk.Imaging.Hybrid.vtkSampleFunction;
        const sphere = vtkSphere.newInstance({ center: [0.0, 0.0, 0.0], radius: 0.5 });
        const sample = vtkSampleFunction.newInstance({
            implicitFunction: sphere,
            sampleDimensions: [50, 50, 50],
            modelBounds: [-0.5, 0.5, -0.5, 0.5, -0.5, 0.5],
        });

        //connecting actor with render
        const actor = vtkActor.newInstance();
        renderer.addActor(actor);
        
        //connecting mapper with actor
        const mapper = vtkMapper.newInstance();
        actor.setMapper(mapper);

        // Connect the pipeline proper
        mCubes.setInputConnection(sample.getOutputPort());
        mapper.setInputConnection(mCubes.getOutputPort());

        renderer.resetCamera();
        renderWindow.render();

    </script>
</body>

</html>

