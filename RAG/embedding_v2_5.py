from llm_agent.ollma_chat import get_llm_response

import os
import time

import pandas as pd
import json
import sys

des="""

### Filter-Calculator
This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.

---

### Filter-ContourTriangulator
Generates a closed circular polyline from 16 points and triangulates it using `vtkContourTriangulator` for wireframe rendering.

---

### Filter-ImageLabelOutline
Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.

---

### Filter-ImageMarchingCubes
Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.

---

### Filter-ImageMarchingSquares
Creates a 3D visualization by sampling an implicit boolean function and extracting contour lines with `vtkImageMarchingSquares`.

---

### Filter-ImageSlice
Generates and displays a 2D random image (100x100) using `vtkImageSlice` and `vtkImageMapper`.

---

### Filter-ImageStreamline
Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.

---

### Filter-MultiImageSlice
Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.

---

### Filter-TriangleFilter
Visualizes a 3D cylinder generated by `vtkCylinderSource`, ensuring triangular geometry with `vtkTriangleFilter` for wireframe rendering.

---

### Filter-VolumeClip
Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.

---

### Filter-VolumeContour
Loads a 3D volumetric dataset (`headsq.vti`) and extracts an isosurface using `vtkImageMarchingCubes`, with a real-time adjustable iso-value.

---

### IO-ElevationReader
Loads and visualizes 3D elevation data from a CSV, applying a texture image, using `vtkElevationReader` and `vtkMapper`.

---

### IO-GCodeReader
Loads and visualizes a G-code file as 3D colored line segments per layer using `vtkGCodeReader`.

---

### IO-HttpdatasetReader
Loads and visualizes a 3D model (VTP format) from a remote URL using `vtkHttpDataSetReader` with gzip support.

---

### IO-OBJReader
Loads and renders a 3D OBJ model with its associated MTL materials using `vtkOBJReader` and `vtkMTLReader`, allowing mesh part visibility toggling.

---

### IO-PDBReader
Loads a PDB file (caffeine molecule) and visualizes it with `vtkPDBReader` and `vtkMoleculeToRepresentation`, showing atoms as spheres and bonds as sticks.

---

### IO-PolyDataReader
Loads and visualizes a 3D polygonal data file (`test_cone.vtp`) using `vtkXMLPolyDataReader` and `vtkMapper`.

---

### IO-Screenshot
Renders a 3D sphere and captures the canvas as a PNG image (`IO-Screenshot.png`).

---

### IO-StickMapper
Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).

---

### IO-XMLImageDataWriter
Loads 3D volume data, writes it to a binary XML format using `vtkXMLImageDataWriter`, reads it back with `vtkXMLImageDataReader`, and visualizes it.

---

### IO-XMLImagePolyDataWriter
Loads 3D polydata, writes it to a string using `vtkXMLPolyDataWriter`, reads it back with `vtkXMLPolyDataReader`, and renders it, allowing download of the generated VTP file.

---

### Rendering-GlyphMapper
Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.

---

### Rendering-Image2D
Displays a synthetic 2D image generated by `vtkRTAnalyticSource` using `vtkImageMapper` and `vtkImageSlice`.

---

### Rendering-ItkWasmVolume
Loads a medical image dataset (MHA) and renders it as a 3D volume using `vtkVolumeMapper` with custom color and opacity transfer functions.

---

### Rendering-ManyRenderers
Displays multiple interactive 3D objects (cone, sphere, cube, cylinder) in separate, independently styled renderers with animation and layout adjustments.

---

### Rendering-MultiSliceImageMapper
Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.

---

### Rendering-SphereMapper
Visualizes a 3D sphere generated by `vtkSphereSource` and rendered with `vtkSphereMapper`.

---

### Rendering-StickMapper
Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.

---

### Rendering-VolumeMapper
Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.

"""
def slipt_query(query):
    system="""
     You are a professional VTK.js visualization assistant. Please break down the user's visualization query into clear, actionable steps.

        Example format:
        Original query: [Generate HTML with vtk.js to visualize sliced rotor data

        Load data:
        - Load from http://127.0.0.1:5000/dataset/rotor.vti

        Processing:
        - Slice ：Set as active scalar "Pressure"
        - Applies a Y-axis slice at 80% /depth (setSlice, setSlicingMode).
        Visualization:
        - Maps pressure values to colors (blue→white→red gradient) and opacity (full opacity).
        - UI: Adds an orientation marker (XYZ axes) for spatial reference.
        6. No GUI controls required]

        Step breakdown:
       querys = [
        {"description": "Introduce necessary VTK.js modules via the CDN link: https://unpkg.com/vtk.js;"},
        {"description": "Data Loading — Load the VTK dataset from http://127.0.0.1:5000/dataset/rotor.vti using vtkXMLImageDataReader;"},
        {"description": "Data Processing — Set 'Pressure' as the active scalar and apply a slice at 80% /depth along the Y-axis using vtkImageSlice;"},
        {"description": "Visualization Setup — Map pressure values to a blue→white→red color gradient and set full opacity using vtkColorTransferFunction, vtkPiecewiseFunction, vtkMapper;"},
        {"description": "Add UI Element — Integrate an XYZ axes orientation marker for spatial reference using vtkOrientationMarkerWidget, vtkAxesActor;"},
        {"description": "Integrate all components and render the visualization without GUI controls using vtkRenderWindow, vtkRenderer,vtkActor;"}
    ]
        Please break down the following query using the above format
    """


    # query=
    model_name="qwen2.5-14b"
    return get_llm_response(query, model_name, system)

def main(query):

    system="""
You are a query assistant. Your task is to find the most relevant information from the provided "Content Library" ONLY. Do NOT use any external knowledge. Return only the top 6 most relevant results(title + content), without any additional text or explanation.
"""
    Q=f"""From the provided content library, please find the top 6 most relevant pieces of information for the current query. Return only the results, one per line.
Query: {query}
Content Library: {des}
"""


    model_name="qwen3-plus"
    r=get_llm_response(Q, model_name, system)
    print(r)
    return r

def process_rag_benchmark(input_file="res2.xlsx", output_file="res2.xlsx"):
    """
    读取Excel文件中的Benchmark prompt列，对每个问题进行RAG检索，
    统计检索耗时，并将结果写入Excel文件
    
    Args:
        input_file: 输入Excel文件路径
        output_file: 输出Excel文件路径
    """
    # 读取Excel文件
    df = pd.read_excel(input_file, sheet_name='检索效果对比')
    
    # 确保必要的列存在，如果不存在则创建并初始化为空字符串
    if 'rag_retrieval_result' not in df.columns:
        df['rag_retrieval_result'] = ''
    if 'time_spend_rag' not in df.columns:
        df['time_spend_rag'] = ''
    
    # 强制将这两列转换为字符串类型，避免数据类型冲突
    df['rag_retrieval_result'] = df['rag_retrieval_result'].astype(str)
    df['time_spend_rag'] = df['time_spend_rag'].astype(str)
    
    # 处理每个问题
    for index, row in df.iterrows():
        prompt = row['Benchmark prompt']
        
        if pd.isna(prompt) or prompt == '':
            print(f"跳过第{index+1}行：空问题")
            # 确保空值也被转换为字符串
            df.at[index, 'rag_retrieval_result'] = str("")
            df.at[index, 'time_spend_rag'] = str("")
            continue
            
        print(f"正在处理第{index+1}个问题的RAG检索...")
        
        # 记录开始时间
        start_time = time.time()
        
        try:
            # 进行RAG检索
            result = main(prompt)
            
            # 记录结束时间
            end_time = time.time()
            time_spent = end_time - start_time
            
            # 将结果写入DataFrame，确保转换为字符串
            if result is not None:
                # 保存检索结果
                df.at[index, 'rag_retrieval_result'] = str(result)
                df.at[index, 'time_spend_rag'] = str(f"{time_spent:.2f}")
                print(f"第{index+1}个问题RAG检索完成，耗时: {time_spent:.2f}秒")
            else:
                df.at[index, 'rag_retrieval_result'] = str("检索失败")
                df.at[index, 'time_spend_rag'] = str(f"{time_spent:.2f}")
                print(f"第{index+1}个问题检索失败，耗时: {time_spent:.2f}秒")
                
        except Exception as e:
            # 记录结束时间
            end_time = time.time()
            time_spent = end_time - start_time
            
            df.at[index, 'rag_retrieval_result'] = str(f"检索出错: {str(e)}")
            df.at[index, 'time_spend_rag'] = str(f"{time_spent:.2f}")
            print(f"第{index+1}个问题检索出错: {e}，耗时: {time_spent:.2f}秒")
    
    # 保存到Excel文件
    try:
        with pd.ExcelWriter(output_file, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
            df.to_excel(writer, sheet_name='检索效果对比', index=False)
        print(f"RAG检索处理完成，结果已保存到 {output_file}")
    except Exception as e:
        print(f"保存文件时出错: {e}")
        # 尝试另存为新文件
        backup_file = output_file.replace('.xlsx', '_rag_backup.xlsx')
        df.to_excel(backup_file, sheet_name='检索效果对比', index=False)
        print(f"已保存到备份文件: {backup_file}")

def batch_process_rag_benchmark():
    """
    批量处理RAG基准问题的主函数
    """
    try:
        path = "D://Pcode//LLM4VIS//llmscivis//data//recoreds//res2.xlsx"
        process_rag_benchmark(input_file=path, output_file=path)
        print("所有RAG问题处理完成！")
    except Exception as e:
        print(f"批量处理RAG过程中出错: {e}")



if __name__ == "__main__":
    batch_process_rag_benchmark()


# if __name__ == "__main__":
#    # 读取res2.xlsx文件，然后使用benchmark prompt的问题调用函数，记录耗时和返回的结果，耗时写在time_spend_llm列，返回的结果写在llm_result列
#    pass

    


   
