from llm_agent.ollma_chat import get_llm_response

import os
import time

import pandas as pd
import json
import sys

des="""

### Filter-Calculator
This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.

---

### Filter-ContourTriangulator
Generates a closed circular polyline from 16 points and triangulates it using `vtkContourTriangulator` for wireframe rendering.

---

### Filter-ImageLabelOutline
Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.

---

### Filter-ImageMarchingCubes
Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.

---

### Filter-ImageMarchingSquares
Creates a 3D visualization by sampling an implicit boolean function and extracting contour lines with `vtkImageMarchingSquares`.

---

### Filter-ImageSlice
Generates and displays a 2D random image (100x100) using `vtkImageSlice` and `vtkImageMapper`.

---

### Filter-ImageStreamline
Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.

---

### Filter-MultiImageSlice
Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.

---

### Filter-TriangleFilter
Visualizes a 3D cylinder generated by `vtkCylinderSource`, ensuring triangular geometry with `vtkTriangleFilter` for wireframe rendering.

---

### Filter-VolumeClip
Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.

---

### Filter-VolumeContour
Loads a 3D volumetric dataset (`headsq.vti`) and extracts an isosurface using `vtkImageMarchingCubes`, with a real-time adjustable iso-value.

---

### IO-ElevationReader
Loads and visualizes 3D elevation data from a CSV, applying a texture image, using `vtkElevationReader` and `vtkMapper`.

---

### IO-GCodeReader
Loads and visualizes a G-code file as 3D colored line segments per layer using `vtkGCodeReader`.

---

### IO-HttpdatasetReader
Loads and visualizes a 3D model (VTP format) from a remote URL using `vtkHttpDataSetReader` with gzip support.

---

### IO-OBJReader
Loads and renders a 3D OBJ model with its associated MTL materials using `vtkOBJReader` and `vtkMTLReader`, allowing mesh part visibility toggling.

---

### IO-PDBReader
Loads a PDB file (caffeine molecule) and visualizes it with `vtkPDBReader` and `vtkMoleculeToRepresentation`, showing atoms as spheres and bonds as sticks.

---

### IO-PolyDataReader
Loads and visualizes a 3D polygonal data file (`test_cone.vtp`) using `vtkXMLPolyDataReader` and `vtkMapper`.

---

### IO-Screenshot
Renders a 3D sphere and captures the canvas as a PNG image (`IO-Screenshot.png`).

---

### IO-StickMapper
Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).

---

### IO-XMLImageDataWriter
Loads 3D volume data, writes it to a binary XML format using `vtkXMLImageDataWriter`, reads it back with `vtkXMLImageDataReader`, and visualizes it.

---

### IO-XMLImagePolyDataWriter
Loads 3D polydata, writes it to a string using `vtkXMLPolyDataWriter`, reads it back with `vtkXMLPolyDataReader`, and renders it, allowing download of the generated VTP file.

---

### Rendering-GlyphMapper
Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.

---

### Rendering-Image2D
Displays a synthetic 2D image generated by `vtkRTAnalyticSource` using `vtkImageMapper` and `vtkImageSlice`.

---

### Rendering-ItkWasmVolume
Loads a medical image dataset (MHA) and renders it as a 3D volume using `vtkVolumeMapper` with custom color and opacity transfer functions.

---

### Rendering-ManyRenderers
Displays multiple interactive 3D objects (cone, sphere, cube, cylinder) in separate, independently styled renderers with animation and layout adjustments.

---

### Rendering-MultiSliceImageMapper
Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.

---

### Rendering-SphereMapper
Visualizes a 3D sphere generated by `vtkSphereSource` and rendered with `vtkSphereMapper`.

---

### Rendering-StickMapper
Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.

---

### Rendering-VolumeMapper
Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.

"""
def slipt_query(query):
    system="""
     You are a professional VTK.js visualization assistant. Please break down the user's visualization query into clear, actionable steps.

        Example format:
        Original query: [Generate HTML with vtk.js to visualize sliced rotor data

        Load data:
        - Load from http://127.0.0.1:5000/dataset/rotor.vti

        Processing:
        - Slice ：Set as active scalar "Pressure"
        - Applies a Y-axis slice at 80% /depth (setSlice, setSlicingMode).
        Visualization:
        - Maps pressure values to colors (blue→white→red gradient) and opacity (full opacity).
        - UI: Adds an orientation marker (XYZ axes) for spatial reference.
        6. No GUI controls required]

        Step breakdown:
       querys = [
        {"description": "Introduce necessary VTK.js modules via the CDN link: https://unpkg.com/vtk.js;"},
        {"description": "Data Loading — Load the VTK dataset from http://127.0.0.1:5000/dataset/rotor.vti using vtkXMLImageDataReader;"},
        {"description": "Data Processing — Set 'Pressure' as the active scalar and apply a slice at 80% /depth along the Y-axis using vtkImageSlice;"},
        {"description": "Visualization Setup — Map pressure values to a blue→white→red color gradient and set full opacity using vtkColorTransferFunction, vtkPiecewiseFunction, vtkMapper;"},
        {"description": "Add UI Element — Integrate an XYZ axes orientation marker for spatial reference using vtkOrientationMarkerWidget, vtkAxesActor;"},
        {"description": "Integrate all components and render the visualization without GUI controls using vtkRenderWindow, vtkRenderer,vtkActor;"}
    ]
        Please break down the following query using the above format
    """


    # query=
    model_name="qwen2.5-14b"
    return get_llm_response(query, model_name, system)

def main(query):

    system="""
You are a query assistant. Your task is to find the most relevant information from the provided "Content Library" ONLY. Do NOT use any external knowledge. Return only the top 6 most relevant results(title + content), without any additional text or explanation.
"""
    Q=f"""From the provided content library, please find the top 6 most relevant pieces of information for the current query. Return only the results, one per line.
Query: {query}
Content Library: {des}
"""


    model_name="qwen2.5-14b"
    r=get_llm_response(Q, model_name, system)
    print(r)
    return r

def process_rag_benchmark(input_file, output_file):
    """
    Read the Benchmark prompt column from Excel file, perform RAG retrieval for each question,
    record retrieval time, and write results to Excel file
    
    Args:
        input_file: Input Excel file path
        output_file: Output Excel file path
    """
    # 读取Excel文件
    df = pd.read_excel(input_file, sheet_name='第二期实验数据')
    
    # Ensure necessary columns exist, create and initialize to empty string if not
    if 'rag_retrieval_result' not in df.columns:
        df['rag_retrieval_result'] = ''
    if 'time_spend_rag' not in df.columns:
        df['time_spend_rag'] = ''
    
    # Force convert these columns to string type to avoid data type conflicts
    df['rag_retrieval_result'] = df['rag_retrieval_result'].astype(str)
    df['time_spend_rag'] = df['time_spend_rag'].astype(str)
    
    # Process each question
    for index, row in df.iterrows():
        prompt = row['Benchmark prompt']
        
        if pd.isna(prompt) or prompt == '':
            print(f"Skipping row {index+1}: Empty question")
            # Ensure empty values are also converted to strings
            df.at[index, 'rag_retrieval_result'] = str("")
            df.at[index, 'time_spend_rag'] = str("")
            continue
            
        print(f"Processing RAG retrieval for question {index+1}...")
        
        # Record start time
        start_time = time.time()
        
        try:
            # Perform RAG retrieval
            result = main(prompt)
            
            # 记录结束时间
            end_time = time.time()
            time_spent = end_time - start_time
            
            # Write results to DataFrame, ensure conversion to string
            if result is not None:
                # Save retrieval results
                df.at[index, 'rag_retrieval_result'] = str(result)
                df.at[index, 'time_spend_rag'] = str(f"{time_spent:.2f}")
                print(f"RAG retrieval for question {index+1} completed, time spent: {time_spent:.2f} seconds")
            else:
                df.at[index, 'rag_retrieval_result'] = str("Retrieval failed")
                df.at[index, 'time_spend_rag'] = str(f"{time_spent:.2f}")
                print(f"Retrieval failed for question {index+1}, time spent: {time_spent:.2f} seconds")
                
        except Exception as e:
            # Record end time
            end_time = time.time()
            time_spent = end_time - start_time
            
            df.at[index, 'rag_retrieval_result'] = str(f"Retrieval error: {str(e)}")
            df.at[index, 'time_spend_rag'] = str(f"{time_spent:.2f}")
            print(f"Retrieval error for question {index+1}: {e}, time spent: {time_spent:.2f} seconds")
    
    # Save to Excel file
    try:
        with pd.ExcelWriter(output_file, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
            df.to_excel(writer, sheet_name='第二期实验数据', index=False)
        print(f"RAG检索处理完成，结果已保存到 {output_file}")
    except Exception as e:
        print(f"Error saving file: {e}")
        # Try to save as new file
        backup_file = output_file.replace('.xlsx', '_rag_backup.xlsx')
        df.to_excel(backup_file, sheet_name='第二期实验数据', index=False)
        print(f"已保存到备份文件: {backup_file}")

def batch_process_rag_benchmark():
    """
    Main function for batch processing RAG benchmark questions
    """
    try:
        path = "D://Pcode//LLM4VIS//llmscivis//data//recoreds//res2.xlsx"
        process_rag_benchmark(input_file=path, output_file=path)
        print("All RAG questions processed!")
    except Exception as e:
        print(f"Error during batch RAG processing: {e}")



if __name__ == "__main__":
    batch_process_rag_benchmark()


# if __name__ == "__main__":
#    # Read res2.xlsx file, then call function with benchmark prompt questions, record time spent and results, write time spent in time_spend_llm column, write results in llm_result column
#    pass

    


   
