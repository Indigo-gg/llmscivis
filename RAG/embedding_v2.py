import re
from typing import List, Dict, Tuple
import numpy as np
from langchain_community.embeddings import OllamaEmbeddings # Replace with OllamaEmbeddings

# Define your question list
querys = [
    {"description": "Introduce necessary VTK.js modules via CDN link: https://unpkg.com/vtk.js"},
    {"description": "Data Loading — Load VTK dataset from http://127.0.0.1:5000/dataset/isabel.vti"},
    {"description": "Data Processing — Calculate velocity magnitude from 'Velocity' field and set it as active scalar 'velocityMagnitude'"},
    {"description": "Visualization Setup — Apply blue to red color mapping, configure surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4), set data spacing (2.5, 2.5, 5.0), and line width 2.0"},
    {"description": "Add UI Element — Integrate XYZ axes widget"},
    {"description": "Integrate all components and render the visualization without GUI controls"}
]

# Define your sample descriptions
sample_text = """
### Filter-Calculator
This code visualizes a 3D plane colored by a mathematical function, using `vtkCalculator` for scalar values and `vtkMapper` for coloring.

---

### Filter-ContourTriangulator
Generates a closed circular polyline from 16 points and triangulates it using `vtkContourTriangulator` for wireframe rendering.

---

### Filter-ImageLabelOutline
Displays a 2D image volume with an outlined labelmap. Specific regions (high/low values) are highlighted in red/green with transparent outlines.

---

### Filter-ImageMarchingCubes
Visualizes a 3D sphere by generating a scalar field with `vtkSampleFunction` and extracting an isosurface using `vtkImageMarchingCubes`.

---

### Filter-ImageMarchingSquares
Creates a 3D visualization by sampling an implicit boolean function and extracting contour lines with `vtkImageMarchingSquares`.

---

### Filter-ImageSlice
Generates and displays a 2D random image (100x100) using `vtkImageSlice` and `vtkImageMapper`.

---

### Filter-ImageStreamline
Visualizes a 3D vector field using `vtkImageStreamline` for streamlines, `vtkOutlineFilter` for data bounds, and seed points, with interactive resolution controls.

---

### Filter-MultiImageSlice
Loads a 3D volume and displays three orthogonal image slices (I, J, K planes) at the 30th layer using `vtkHttpDataSetReader` and `vtkImageSlice`.

---

### Filter-TriangleFilter
Visualizes a 3D cylinder generated by `vtkCylinderSource`, ensuring triangular geometry with `vtkTriangleFilter` for wireframe rendering.

---

### Filter-VolumeClip
Renders a 3D medical volume (`headsq.vti`) with a clipping plane, using `vtkVolumeMapper` and `vtkVolumeActor` for customized appearance.

---

### Filter-VolumeContour
Loads a 3D volumetric dataset (`headsq.vti`) and extracts an isosurface using `vtkImageMarchingCubes`, with a real-time adjustable iso-value.

---

### IO-ElevationReader
Loads and visualizes 3D elevation data from a CSV, applying a texture image, using `vtkElevationReader` and `vtkMapper`.

---

### IO-GCodeReader
Loads and visualizes a G-code file as 3D colored line segments per layer using `vtkGCodeReader`.

---

### IO-HttpdatasetReader
Loads and visualizes a 3D model (VTP format) from a remote URL using `vtkHttpDataSetReader` with gzip support.

---

### IO-OBJReader
Loads and renders a 3D OBJ model with its associated MTL materials using `vtkOBJReader` and `vtkMTLReader`, allowing mesh part visibility toggling.

---

### IO-PDBReader
Loads a PDB file (caffeine molecule) and visualizes it with `vtkPDBReader` and `vtkMoleculeToRepresentation`, showing atoms as spheres and bonds as sticks.

---

### IO-PolyDataReader
Loads and visualizes a 3D polygonal data file (`test_cone.vtp`) using `vtkXMLPolyDataReader` and `vtkMapper`.

---

### IO-Screenshot
Renders a 3D sphere and captures the canvas as a PNG image (`IO-Screenshot.png`).

---

### IO-StickMapper
Generates a plane and uses `vtkCalculator` to create custom point data ('orientation', 'temperature', 'pressure'), which `vtkStickMapper` could use for rendering (currently not fully connected).

---

### IO-XMLImageDataWriter
Loads 3D volume data, writes it to a binary XML format using `vtkXMLImageDataWriter`, reads it back with `vtkXMLImageDataReader`, and visualizes it.

---

### IO-XMLImagePolyDataWriter
Loads 3D polydata, writes it to a string using `vtkXMLPolyDataWriter`, reads it back with `vtkXMLPolyDataReader`, and renders it, allowing download of the generated VTP file.

---

### Rendering-GlyphMapper
Visualizes a 3D plane with glyphs (e.g., cones) whose scale and orientation are based on scalar and vector data, using `vtkGlyph3DMapper` and `vtkCalculator`.

---

### Rendering-Image2D
Displays a synthetic 2D image generated by `vtkRTAnalyticSource` using `vtkImageMapper` and `vtkImageSlice`.

---

### Rendering-ItkWasmVolume
Loads a medical image dataset (MHA) and renders it as a 3D volume using `vtkVolumeMapper` with custom color and opacity transfer functions.

---

### Rendering-ManyRenderers
Displays multiple interactive 3D objects (cone, sphere, cube, cylinder) in separate, independently styled renderers with animation and layout adjustments.

---

### Rendering-MultiSliceImageMapper
Loads a 3D volume (`headsq.vti`) and displays three orthogonal slices (I, J, K) with interactive controls for position and color properties.

---

### Rendering-SphereMapper
Visualizes a 3D sphere generated by `vtkSphereSource` and rendered with `vtkSphereMapper`.

---

### Rendering-StickMapper
Creates a 3D visualization where a plane is rendered using a `vtkStickMapper`. The plane's geometry is generated with a `vtkPlaneSource`, and `vtkCalculator` processes the data to generate custom point attributes ('orientation', 'temperature', 'pressure') which `vtkStickMapper` uses to control the orientation and scaling of the sticks. The visualization is displayed in a full-screen renderer with a dark background. Additionally, UI controls allow adjusting the X and Y resolution of the plane, which dynamically updates the visualization.

---

### Rendering-VolumeMapper
Loads a 3D volume dataset and renders it using `vtkVolumeActor` and `vtkVolumeMapper` with extensive customization for appearance and quality.
"""

# Initialize embedding model, now using OllamaEmbeddings
# model="llama3.1" will instruct Ollama to use the downloaded llama3.1 model to generate embeddings
# If your Ollama service is not at the default address (http://localhost:11434), please specify base_url
embeddings_model = OllamaEmbeddings(model="llama3.1")

def parse_sample_descriptions(sample_text: str) -> List[Dict[str, str]]:
    """
    Parse sample description string, extract title and content.
    """
    # Use regular expressions to match titles after ### and their content until the next ### or end of string
    pattern = re.compile(r"###\s*(.*?)\n(.*?)(?=\n###|\Z)", re.DOTALL)
    
    matches = pattern.finditer(sample_text)
    parsed_data = []
    for match in matches:
        title = match.group(1).strip()
        description = match.group(2).strip()
        parsed_data.append({"title": title, "description": description})
    return parsed_data

def get_embeddings(texts: List[str]) -> np.ndarray:
    """
    Convert text list to embedding vectors.
    """
    # OllamaEmbeddings' embed_documents method receives a list
    embeddings = embeddings_model.embed_documents(texts)
    return np.array(embeddings)

def cosine_similarity(vec1: np.ndarray, vec2: np.ndarray) -> float:
    """
    Calculate cosine similarity between two vectors.
    """
    dot_product = np.dot(vec1, vec2)
    norm_vec1 = np.linalg.norm(vec1)
    norm_vec2 = np.linalg.norm(vec2)
    if norm_vec1 == 0 or norm_vec2 == 0:
        return 0.0
    return dot_product / (norm_vec1 * norm_vec2)

def find_top_k_similar(
    query_description: str,
    sample_descriptions: List[Dict[str, str]],
    k: int = 2
) -> List[Tuple[str, float, str]]:
    """
    Find the K most similar sample descriptions to the given query description.
    """
    # Get query embeddings
    # Note: OllamaEmbeddings' embed_documents method returns a list of lists, even if the input is a single text
    # So we take [0] to get the first (and only) embedding vector
    query_embedding = get_embeddings([query_description])[0] 

    similarities = []
    for sample_desc_item in sample_descriptions:
        sample_title = sample_desc_item['title']
        sample_desc_text = sample_desc_item['description']
        
        # Get sample embeddings
        sample_embedding = get_embeddings([sample_desc_text])[0]

        similarity = cosine_similarity(query_embedding, sample_embedding)
        similarities.append((sample_title, similarity, sample_desc_text))

    # Sort by similarity in descending order
    similarities.sort(key=lambda x: x[1], reverse=True)
    
    # Return top K
    return similarities[:k]

if __name__ == "__main__":
    # 1. Parse sample descriptions
    parsed_sample_data = parse_sample_descriptions(sample_text)
    print(f"Parsed {len(parsed_sample_data)} sample descriptions.")

    # 2. Find the two most similar for each query
    print("\n--- Finding most similar descriptions for each query (using Llama 3.1 embeddings) ---")
    for i, query_item in enumerate(querys):
        query_desc = query_item['description']
        print(f"\nQuery {i+1}: \"{query_desc}\"")
        
        top_2_similar = find_top_k_similar(query_desc, parsed_sample_data, k=2)
        
        if top_2_similar:
            for j, (title, score, desc) in enumerate(top_2_similar):
                print(f"  Most similar {j+1}:")
                print(f"    Title: {title}")
                print(f"    Similarity: {score:.4f}")
                # If you want to display content, uncomment the line below
                # print(f"    Content: {desc[:100]}...") # 只显示部分内容
        else:
            print("  No similar descriptions found.")

    print("\n--- All queries processed ---")