[
    {
        "path": null,
        "name": null,
        "prompt": "Create rotor isosurface visualization with vtk.js\n\nData:\n- Load from: http://127.0.0.1:5000/dataset/rotor_simplified.vti\n- Calculate velocityMagnitude scalar field\n\nVisualization:\n- Marching Cubes isosurfaces\n- Rainbow color mapping\n- Axis indicator\n\nControls:\n- Isosurface value slider\n- Color scheme selector\n- Opacity control\n\nRendering:\n- Dark gray background\n- Surface mode\n- Standard lighting",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotor数据集等值面渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n\n        /* 控制面板样式 */\n        .control-panel {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background: rgba(255, 255, 255, 0.8);\n            border-radius: 5px;\n            padding: 10px;\n            width: 250px;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n            z-index: 1000;\n        }\n\n        .control-group {\n            margin-bottom: 10px;\n        }\n\n        .control-group label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n\n        .slider-container {\n            display: flex;\n            align-items: center;\n        }\n\n        .slider-container input[type=\"range\"] {\n            flex: 1;\n            margin-right: 10px;\n        }\n\n        button {\n            background: #4CAF50;\n            color: white;\n            border: none;\n            padding: 8px 12px;\n            border-radius: 4px;\n            cursor: pointer;\n            width: 100%;\n        }\n\n        button:hover {\n            background: #45a049;\n        }\n\n        select {\n            width: 100%;\n            padding: 5px;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    \n    <!-- 控制面板 -->\n    <div class=\"control-panel\">\n        <h3 style=\"margin-top: 0;\">Rotor等值面控制</h3>\n        \n        <div class=\"control-group\">\n            <label>等值面值:</label>\n            <div class=\"slider-container\">\n                <input type=\"range\" id=\"isovalue\" min=\"0\" max=\"100\" value=\"50\">\n                <span id=\"isovalueValue\">50</span>\n            </div>\n        </div>\n        \n        <div class=\"control-group\">\n            <label>颜色映射:</label>\n            <select id=\"colorMap\">\n                <option value=\"blue-red\" selected>蓝-红</option>\n                <option value=\"rainbow\">彩虹</option>\n                <option value=\"grayscale\">灰度</option>\n            </select>\n        </div>\n        \n        <div class=\"control-group\">\n            <label>不透明度:</label>\n            <div class=\"slider-container\">\n                <input type=\"range\" id=\"opacity\" min=\"0\" max=\"100\" value=\"100\">\n                <span id=\"opacityValue\">1.0</span>\n            </div>\n        </div>\n        \n        <button id=\"applyChanges\">应用更改</button>\n    </div>\n    \n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n        // 声明全局变量，用于控制面板交互\n        let dataRange = [0, 1];\n        let marchingCube, colorTransferFunction, actor, renderWindow;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const reader = vtkXMLImageDataReader.newInstance();\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\rotor_simplified.vti').then(() => {\n            reader.loadData().then(() => {\n                const imageData = reader.getOutputData(0);\n\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                const numPoints = imageData.getNumberOfPoints();\n                const magnitudeData = new Float64Array(numPoints);\n\n                for (let i = 0; i < numPoints; i++) {\n                    const vx = velocityArray.getData()[3 * i + 0];\n                    const vy = velocityArray.getData()[3 * i + 1];\n                    const vz = velocityArray.getData()[3 * i + 2];\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1,\n                    values: magnitudeData,\n                    name: 'velocityMagnitude',\n                });\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n\n                const newRange = magnitudeVtkArray.getRange();\n                const [minV, maxV] = newRange;\n                \n                // 保存数据范围到全局变量\n                dataRange = newRange;\n                console.log('速度大小范围:', dataRange);\n                \n                // 更新控制面板的初始值\n                updateIsoValueControls(dataRange);\n\n                marchingCube = vtkImageMarchingCubes.newInstance({\n                    contourValue: minV + 0.5 * (maxV - minV),\n                    computeNormals: true,\n                    mergePoints: true\n                });\n\n                marchingCube.setInputData(imageData);\n\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(marchingCube.getOutputPort());\n\n                colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n\n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(minV, maxV);\n                mapper.setInterpolateScalarsBeforeMapping(true);\n\n                actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setOpacity(1.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n\n                renderer.addActor(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);\n                camera.setViewUp(0, 0, 1);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n\n                const interactor = renderWindow.getInteractor();\n                interactor.start();\n            });\n        });\n        \n        // 更新等值面控制器\n        function updateIsoValueControls(range) {\n            const slider = document.getElementById('isovalue');\n            const valueDisplay = document.getElementById('isovalueValue');\n            const initialValue = range[0] + 0.5 * (range[1] - range[0]);\n            \n            slider.min = 0;\n            slider.max = 100;\n            slider.value = 50;\n            valueDisplay.textContent = initialValue.toFixed(2);\n            \n            // 设置不透明度初始值\n            document.getElementById('opacityValue').textContent = '1.0';\n        }\n        \n        // 更新颜色映射\n        function updateColorMap(mapType) {\n            colorTransferFunction.removeAllPoints();\n            \n            const [minV, maxV] = dataRange;\n            \n            switch(mapType) {\n                case 'blue-red':\n                    colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);\n                    colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n                    break;\n                case 'rainbow':\n                    colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 1.0, 1.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 0.0, 1.0, 0.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 1.0, 0.0);\n                    colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n                    break;\n                case 'grayscale':\n                    colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.0);\n                    colorTransferFunction.addRGBPoint(maxV, 1.0, 1.0, 1.0);\n                    break;\n            }\n            \n            renderWindow.render();\n        }\n        \n        // 事件监听器\n        document.getElementById('isovalue').addEventListener('input', function() {\n            const value = dataRange[0] + (this.value / 100) * (dataRange[1] - dataRange[0]);\n            document.getElementById('isovalueValue').textContent = value.toFixed(2);\n        });\n        \n        document.getElementById('opacity').addEventListener('input', function() {\n            const value = this.value / 100;\n            document.getElementById('opacityValue').textContent = value.toFixed(2);\n        });\n        \n        document.getElementById('colorMap').addEventListener('change', function() {\n            updateColorMap(this.value);\n        });\n                                     \n        document.getElementById('applyChanges').addEventListener('click', function() {\n            // 应用等值面值更改\n            const isovalue = dataRange[0] + (document.getElementById('isovalue').value / 100) * (dataRange[1] - dataRange[0]);\n            marchingCube.setContourValue(isovalue);\n            \n            // 应用不透明度更改\n            const opacity = document.getElementById('opacity').value / 100;\n            actor.getProperty().setOpacity(opacity);\n            \n            // 重新渲染场景\n            renderWindow.render();\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-32b",
        "evaluator": "qwen3-32b",
        "score": null,
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1748095235",
        "eval_user": "test",
        "eval_time": "2025-05-24 22:00:35",
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "path": "IO-Filter-Rendering\\isosurface\\rotor\\description.txt",
        "name": "description.txt",
        "prompt": "Rotor Isosurface Visualization Requirements:\n- Data: Load from rotor_simplified.vti dataset\n- Process: Calculate velocity magnitude from vector components (√(vx²+vy²+vz²))\n- Features:\n  * Isosurface extraction using Marching Cubes algorithm\n  * Rainbow colormap (blue->cyan->white->orange->red)\n  * Surface rendering with ambient(0.3), diffuse(0.7), specular(0.4) lighting\n  * Interactive 3D view with orientation axes widget\n- Implementation: vtk.js framework with responsive UI",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotor数据集等值面渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const reader = vtkXMLImageDataReader.newInstance();\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\rotor_simplified.vti').then(() => {\n            reader.loadData().then(() => {\n                const imageData = reader.getOutputData(0);\n\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                const numPoints = imageData.getNumberOfPoints();\n                const magnitudeData = new Float64Array(numPoints);\n\n                for (let i = 0; i < numPoints; i++) {\n                    const vx = velocityArray.getData()[3 * i + 0];\n                    const vy = velocityArray.getData()[3 * i + 1];\n                    const vz = velocityArray.getData()[3 * i + 2];\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1,\n                    values: magnitudeData,\n                    name: 'velocityMagnitude',\n                });\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n\n                const newRange = magnitudeVtkArray.getRange();\n                const [minV, maxV] = newRange;\n\n                const marchingCube = vtkImageMarchingCubes.newInstance({\n                    contourValue: minV + 0.5 * (maxV - minV),\n                    computeNormals: true,\n                    mergePoints: true\n                });\n\n                marchingCube.setInputData(imageData);\n\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(marchingCube.getOutputPort());\n\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n\n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(minV, maxV);\n                mapper.setInterpolateScalarsBeforeMapping(true);\n\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setOpacity(1.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n\n                renderer.addActor(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);\n                camera.setViewUp(0, 0, 1);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n\n                const interactor = renderWindow.getInteractor();\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-turbo",
        "evaluator": "qwen3-32b",
        "score": null,
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1748097605",
        "eval_user": "test",
        "eval_time": "2025-05-24 22:40:05",
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "path": "IO-Filter-Panel-Rendering\\isosurface\\rotor\\description.txt",
        "name": "description.txt",
        "prompt": "Create rotor isosurface visualization with vtk.js\n\nData:\n- Load from: http://127.0.0.1:5000/dataset/rotor_simplified.vti\n- Calculate velocityMagnitude scalar field\n\nVisualization:\n- Marching Cubes isosurfaces\n- Rainbow color mapping\n- Axis indicator\n\nControls:\n- Isosurface value slider\n- Color scheme selector\n- Opacity control\n\nRendering:\n- Dark gray background\n- Surface mode\n- Standard lighting",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotor数据集等值面渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n\n        /* 控制面板样式 */\n        .control-panel {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background: rgba(255, 255, 255, 0.8);\n            border-radius: 5px;\n            padding: 10px;\n            width: 250px;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n            z-index: 1000;\n        }\n\n        .control-group {\n            margin-bottom: 10px;\n        }\n\n        .control-group label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n\n        .slider-container {\n            display: flex;\n            align-items: center;\n        }\n\n        .slider-container input[type=\"range\"] {\n            flex: 1;\n            margin-right: 10px;\n        }\n\n        button {\n            background: #4CAF50;\n            color: white;\n            border: none;\n            padding: 8px 12px;\n            border-radius: 4px;\n            cursor: pointer;\n            width: 100%;\n        }\n\n        button:hover {\n            background: #45a049;\n        }\n\n        select {\n            width: 100%;\n            padding: 5px;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    \n    <!-- 控制面板 -->\n    <div class=\"control-panel\">\n        <h3 style=\"margin-top: 0;\">Rotor等值面控制</h3>\n        \n        <div class=\"control-group\">\n            <label>等值面值:</label>\n            <div class=\"slider-container\">\n                <input type=\"range\" id=\"isovalue\" min=\"0\" max=\"100\" value=\"50\">\n                <span id=\"isovalueValue\">50</span>\n            </div>\n        </div>\n        \n        <div class=\"control-group\">\n            <label>颜色映射:</label>\n            <select id=\"colorMap\">\n                <option value=\"blue-red\" selected>蓝-红</option>\n                <option value=\"rainbow\">彩虹</option>\n                <option value=\"grayscale\">灰度</option>\n            </select>\n        </div>\n        \n        <div class=\"control-group\">\n            <label>不透明度:</label>\n            <div class=\"slider-container\">\n                <input type=\"range\" id=\"opacity\" min=\"0\" max=\"100\" value=\"100\">\n                <span id=\"opacityValue\">1.0</span>\n            </div>\n        </div>\n        \n        <button id=\"applyChanges\">应用更改</button>\n    </div>\n    \n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;\n\n        // 声明全局变量，用于控制面板交互\n        let dataRange = [0, 1];\n        let marchingCube, colorTransferFunction, actor, renderWindow;\n\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        const reader = vtkXMLImageDataReader.newInstance();\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\rotor_simplified.vti').then(() => {\n            reader.loadData().then(() => {\n                const imageData = reader.getOutputData(0);\n\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                const numPoints = imageData.getNumberOfPoints();\n                const magnitudeData = new Float64Array(numPoints);\n\n                for (let i = 0; i < numPoints; i++) {\n                    const vx = velocityArray.getData()[3 * i + 0];\n                    const vy = velocityArray.getData()[3 * i + 1];\n                    const vz = velocityArray.getData()[3 * i + 2];\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1,\n                    values: magnitudeData,\n                    name: 'velocityMagnitude',\n                });\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n\n                const newRange = magnitudeVtkArray.getRange();\n                const [minV, maxV] = newRange;\n                \n                // 保存数据范围到全局变量\n                dataRange = newRange;\n                console.log('速度大小范围:', dataRange);\n                \n                // 更新控制面板的初始值\n                updateIsoValueControls(dataRange);\n\n                marchingCube = vtkImageMarchingCubes.newInstance({\n                    contourValue: minV + 0.5 * (maxV - minV),\n                    computeNormals: true,\n                    mergePoints: true\n                });\n\n                marchingCube.setInputData(imageData);\n\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(marchingCube.getOutputPort());\n\n                colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n\n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(minV, maxV);\n                mapper.setInterpolateScalarsBeforeMapping(true);\n\n                actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setOpacity(1.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n\n                renderer.addActor(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);\n                camera.setViewUp(0, 0, 1);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n\n                const interactor = renderWindow.getInteractor();\n                interactor.start();\n            });\n        });\n        \n        // 更新等值面控制器\n        function updateIsoValueControls(range) {\n            const slider = document.getElementById('isovalue');\n            const valueDisplay = document.getElementById('isovalueValue');\n            const initialValue = range[0] + 0.5 * (range[1] - range[0]);\n            \n            slider.min = 0;\n            slider.max = 100;\n            slider.value = 50;\n            valueDisplay.textContent = initialValue.toFixed(2);\n            \n            // 设置不透明度初始值\n            document.getElementById('opacityValue').textContent = '1.0';\n        }\n        \n        // 更新颜色映射\n        function updateColorMap(mapType) {\n            colorTransferFunction.removeAllPoints();\n            \n            const [minV, maxV] = dataRange;\n            \n            switch(mapType) {\n                case 'blue-red':\n                    colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);\n                    colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n                    break;\n                case 'rainbow':\n                    colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 1.0, 1.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 0.0, 1.0, 0.0);\n                    colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 1.0, 0.0);\n                    colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);\n                    break;\n                case 'grayscale':\n                    colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.0);\n                    colorTransferFunction.addRGBPoint(maxV, 1.0, 1.0, 1.0);\n                    break;\n            }\n            \n            renderWindow.render();\n        }\n        \n        // 事件监听器\n        document.getElementById('isovalue').addEventListener('input', function() {\n            const value = dataRange[0] + (this.value / 100) * (dataRange[1] - dataRange[0]);\n            document.getElementById('isovalueValue').textContent = value.toFixed(2);\n        });\n        \n        document.getElementById('opacity').addEventListener('input', function() {\n            const value = this.value / 100;\n            document.getElementById('opacityValue').textContent = value.toFixed(2);\n        });\n        \n        document.getElementById('colorMap').addEventListener('change', function() {\n            updateColorMap(this.value);\n        });\n                                     \n        document.getElementById('applyChanges').addEventListener('click', function() {\n            // 应用等值面值更改\n            const isovalue = dataRange[0] + (document.getElementById('isovalue').value / 100) * (dataRange[1] - dataRange[0]);\n            marchingCube.setContourValue(isovalue);\n            \n            // 应用不透明度更改\n            const opacity = document.getElementById('opacity').value / 100;\n            actor.getProperty().setOpacity(opacity);\n            \n            // 重新渲染场景\n            renderWindow.render();\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Rotator Isosurface Visualization with vtk.js</title>\n  <style>\n    body {\n      margin: 0;\n      background-color: #2e2e2e; /* Dark gray background */\n      overflow: hidden;\n    }\n    #vtkContainer {\n      width: 100vw;\n      height: 100vh;\n    }\n    #controls {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      background: rgba(0, 0, 0, 0.5);\n      color: white;\n      padding: 10px;\n      border-radius: 5px;\n    }\n  </style>\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n<body>\n  <div id=\"vtkContainer\"></div>\n  <div id=\"controls\">\n    <label>Isosurface Value:\n      <input type=\"range\" id=\"isoSlider\" min=\"0\" max=\"100\" value=\"50\">\n    </label><br>\n    <label>Color Scheme:\n      <select id=\"colorScheme\">\n        <option value=\"rainbow\">Rainbow</option>\n        <!-- Add more color schemes if needed -->\n      </select>\n    </label><br>\n    <label>Opacity:\n      <input type=\"range\" id=\"opacitySlider\" min=\"0\" max=\"1\" step=\"0.01\" value=\"1\">\n    </label>\n  </div>\n\n  <script>\n    // Initialize VTK.js\n    const { vtkRenderWindow, vtkRenderer, vtkRenderWindowInteractor } = vtk;\n\n    // Create a render window and renderer\n    const renderWindow = vtkRenderWindow.newInstance();\n    const renderer = vtkRenderer.newInstance();\n    renderWindow.addRenderer(renderer);\n\n    // Create an interactor\n    const interactor = vtkRenderWindowInteractor.newInstance();\n    interactor.setRenderWindow(renderWindow);\n\n    // Set up the container\n    const container = document.getElementById('vtkContainer');\n    renderWindow.setContainer(container);\n    renderWindow.setSize(container.clientWidth, container.clientHeight);\n\n    // Load the dataset from the specified URL\n    const reader = vtk.HttpDataSetReader.newInstance({ fetchOptions: { mode: 'cors' } });\n    reader.setUrl('http://127.0.0.1:5000/dataset/rotor_simplified.vti');\n    reader.loadData().then(() => {\n      const data = reader.getOutputData();\n\n      // Calculate velocityMagnitude scalar field (assuming it's already present)\n      // If not, you may need to compute it using vtkImageGradient or other filters\n\n      // Create isosurface using Marching Cubes\n      const isoFilter = vtk.ImageMarchingCubes.newInstance();\n      isoFilter.setInputData(data);\n      isoFilter.setNumberOfContours(1);\n      isoFilter.setValue(0, 50); // Default isosurface value\n\n      // Create mapper for isosurface\n      const isoMapper = vtk.Mapper.newInstance();\n      isoMapper.setInputConnection(isoFilter.getOutputPort());\n\n      // Create actor for isosurface\n      const isoActor = vtk.Actor.newInstance();\n      isoActor.setMapper(isoMapper);\n\n      // Apply rainbow color mapping\n      const colorTransferFunction = vtk.ColorTransferFunction.newInstance();\n      colorTransferFunction.addRGBPoint(0, 0, 0, 1);   // Blue\n      colorTransferFunction.addRGBPoint(1, 0, 1, 0);   // Green\n      colorTransferFunction.addRGBPoint(2, 1, 1, 0);   // Yellow\n      colorTransferFunction.addRGBPoint(3, 1, 0, 0);   // Red\n\n      isoMapper.setScalarRange(data.getPointData().getScalars().getRange());\n      isoMapper.setLookupTable(colorTransferFunction);\n\n      // Set opacity\n      isoActor.getProperty().setOpacity(document.getElementById('opacitySlider').value);\n\n      // Add actor to renderer\n      renderer.addActor(isoActor);\n\n      // Axis indicator (simple axes helper)\n      const axes = vtk.Axes.newInstance();\n      axes.setOrigin([0, 0, 0]);\n      axes.setAxisLabels(['X', 'Y', 'Z']);\n      axes.setAxisLength(100);\n      axes.setLabelOffset(10);\n      axes.setShaftType(0); // Cylinder\n      axes.setTipLength(0.1);\n      axes.setTipRadius(0.05);\n      axes.setAxisWidth(2);\n      axes.setLabelColor([1, 1, 1]);\n      axes.setLabelTextSize(12);\n      axes.setTickLength(5);\n\n      const axesMapper = vtk.Mapper.newInstance();\n      axesMapper.setInputData(axes.getPolyData());\n\n      const axesActor = vtk.Actor.newInstance();\n      axesActor.setMapper(axesMapper);\n      axesActor.getProperty().setColor([1, 1, 1]);\n\n      renderer.addActor(axesActor);\n\n      // Set up lighting\n      renderer.setLighting(true);\n      renderer.setBackground([0.1, 0.1, 0.1]); // Dark gray background\n\n      // Render the scene\n      renderWindow.render();\n\n      // Update isosurface value based on slider\n      document.getElementById('isoSlider').addEventListener('input', () => {\n        const value = parseFloat(document.getElementById('isoSlider').value);\n        isoFilter.setValue(0, value);\n        renderWindow.render();\n      });\n\n      // Update color scheme based on selector\n      document.getElementById('colorScheme').addEventListener('change', () => {\n        const scheme = document.getElementById('colorScheme').value;\n        if (scheme === 'rainbow') {\n          colorTransferFunction.removeAllPoints();\n          colorTransferFunction.addRGBPoint(0, 0, 0, 1);   // Blue\n          colorTransferFunction.addRGBPoint(1, 0, 1, 0);   // Green\n          colorTransferFunction.addRGBPoint(2, 1, 1, 0);   // Yellow\n          colorTransferFunction.addRGBPoint(3, 1, 0, 0);   // Red\n        }\n        isoMapper.setLookupTable(colorTransferFunction);\n        renderWindow.render();\n      });\n\n      // Update opacity based on slider\n      document.getElementById('opacitySlider').addEventListener('input', () => {\n        const opacity = parseFloat(document.getElementById('opacitySlider').value);\n        isoActor.getProperty().setOpacity(opacity);\n        renderWindow.render();\n      });\n    });\n\n    // Handle window resize\n    window.addEventListener('resize', () => {\n      renderWindow.setSize(container.clientWidth, container.clientHeight);\n      renderWindow.render();\n    });\n  </script>\n</body>\n</html>",
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": "Create rotor isosurface visualization with vtk.js\n\nData:\n- Load from: http://127.0.0.1:5000/dataset/rotor_simplified.vti\n- Calculate velocityMagnitude scalar field\n\nVisualization:\n- Marching Cubes isosurfaces\n- Rainbow color mapping\n- Axis indicator\n\nControls:\n- Isosurface value slider\n- Color scheme selector\n- Opacity control\n\nRendering:\n- Dark gray background\n- Surface mode\n- Standard lighting",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-turbo",
        "evaluator": "qwen3-32b",
        "score": null,
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1748098586",
        "eval_user": "test",
        "eval_time": "2025-05-24 22:56:26",
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "path": "IO-Filter-Rendering\\cutter\\isabel\\description.txt",
        "name": "description.txt",
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude\n\nLoad from http://127.0.0.1:5000/dataset/isabel.vti\n\nProcessing:\n- Calculate velocity magnitude from \"Velocity\" field\n- Set as active scalar \"velocityMagnitude\"\n\nVisualization:\n- Blue to red color mapping\n- Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4)\n- XYZ axes widget\n- Data spacing: (2.5, 2.5, 5.0)\n- Line width: 2.0\n\nLoad vtk.js via CDN link: https://unpkg.com/vtk.js\nNo GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>vtk.js Sliced Data with Velocity Magnitude</title>\n  <!-- Load vtk.js from CDN -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <style>\n    body, html {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n    }\n    #container {\n      width: 100%;\n      height: 100%;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <script>\n    // Wait for DOM and vtk.js to be ready\n    window.addEventListener('DOMContentLoaded', () => {\n      const vtk = window.vtk;\n\n      // Create a render window\n      const renderer = vtk.Rendering.Core.vtkRenderer.newInstance();\n      const renderWindow = vtk.Rendering.Core.vtkRenderWindow.newInstance();\n      renderWindow.addRenderer(renderer);\n      const glwindow = vtk.Rendering.GL.vtkRenderWindowGL2PS newInstance();\n      glwindow.setContainer(document.getElementById('container'));\n      glwindow.setSize(800, 600);\n      glwindow.setRenderWindow(renderWindow);\n\n      // Create a render window interactor\n      const interactor = vtk.Rendering.Core.vtkRenderWindowInteractor.newInstance();\n      interactor.setRenderWindow(glwindow);\n\n      // Fetch the dataset from the provided URL\n      const reader = vtk.IO.XML.vtkXMLImageDataReader.newInstance();\n      reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti');\n      reader.parseAsArrayBuffer().then(() => {\n        const data = reader.getOutputData();\n\n        // Calculate velocity magnitude if \"Velocity\" field is present\n        if (data.getPointData().getVectors()) {\n          const velocityArray = data.getPointData().getVectors(); // Assuming \"Velocity\" is the vector array name\n          const numTuples = velocityArray.getNumberOfTuples();\n          const velocityMagnitudeArray = vtk.Common.DataModel.vtkDataArray.newInstance({\n            name: 'velocityMagnitude',\n            numberOfComponents: 1,\n            values: new Float32Array(numTuples),\n          });\n\n          for (let i = 0; i < numTuples; i++) {\n            const [vx, vy, vz] = velocityArray.getTuple(i);\n            const mag = Math.sqrt(vx * vx + vy * vy + vz * vz);\n            velocityMagnitudeArray.setValue(i, mag);\n          }\n\n          data.getPointData().addArray(velocityMagnitudeArray);\n          data.getPointData().setActiveScalars('velocityMagnitude');\n        } else {\n          console.warn('No \"Velocity\" field found in the dataset.');\n        }\n\n        // Set data spacing\n        data.setSpacing([2.5, 2.5, 5.0]);\n\n        // Create mapper and actor\n        const mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n        mapper.setInputData(data);\n        mapper.setScalarModeToUsePointFieldData();\n        mapper.selectColorArray('velocityMagnitude');\n        mapper.setColorModeToMapScalars();\n        mapper.setScalarVisibility(true);\n\n        // Set color mapping from blue to red using vtkColorTransferFunction\n        const lut = vtk.Common.DataModel.vtkColorTransferFunction.newInstance();\n        lut.addRGBPoint(0.0, 0.0, 0.0, 1.0); // Blue\n        lut.addRGBPoint(1.0, 1.0, 0.0, 0.0); // Red\n        mapper.setLookupTable(lut);\n\n        const actor = vtk.Rendering.Core.vtkActor.newInstance();\n        actor.setMapper(mapper);\n\n        // Configure Phong shading properties\n        const property = actor.getProperty();\n        property.setAmbient(0.3);\n        property.setDiffuse(0.7);\n        property.setSpecular(0.4);\n        property.setLineWidth(2.0); // Set line width\n\n        // Add actor to the renderer\n        renderer.addActor(actor);\n\n        // Add XYZ axes widget\n        const widget = vtk.Interaction.Widgets.vtkAxesWidget.newInstance();\n        widget.setInteractor(interactor);\n        widget.setEnabled(1);\n\n        // Initialize camera and render\n        renderer.resetCamera();\n        renderWindow.render();\n\n        // Start interaction\n        interactor.initialize();\n        interactor.start();\n      });\n    });\n  </script>\n</body>\n</html>\n```",
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude\n\nLoad from http://127.0.0.1:5000/dataset/isabel.vti\n\nProcessing:\n- Calculate velocity magnitude from \"Velocity\" field\n- Set as active scalar \"velocityMagnitude\"\n\nVisualization:\n- Blue to red color mapping\n- Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4)\n- XYZ axes widget\n- Data spacing: (2.5, 2.5, 5.0)\n- Line width: 2.0\n\nLoad vtk.js via CDN link: https://unpkg.com/vtk.js\nNo GUI controls required",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-32b",
        "evaluator": "qwen3-32b",
        "score": "0.65",
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1748099769",
        "eval_user": "test",
        "eval_time": "2025-05-24 23:16:09",
        "evaluator_evaluation": null,
        "options": null,
        "evaluatorEvaluation": "<Score>0.65</Score>\n<Explanation>The generated code is readable and has a good structure, but it lacks several key features from the ground truth. It does not implement slicing (vtkImageSlice or vtkCutter), nor does it include a slice plane or orientation marker widget. The camera positioning is also less detailed compared to the ground truth. While the color mapping and data loading are implemented correctly, these missing elements affect the completeness of the visualization task.</Explanation>"
    },
    {
        "path": "IO-Rendering\\colors and representation\\airfoil_oneslice\\description.txt",
        "name": "description.txt",
        "prompt": "Generate HTML with vtk.js to visualize volume rendering\n\nLoad from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp\nScalar Mapping:\nActivates the p scalar array for color encoding\nVisualization:\nRenders the colors and representation\npositions the camera to focus on the dataset bounds",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Volume Rendering with vtk.js</title>\n  <!-- Load the vtk.js library from a CDN -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <style>\n    body, html {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n    }\n    #vtkContainer {\n      width: 100vw;\n      height: 100vh;\n    }\n  </style>\n</head>\n<body>\n  <!-- Div container for the vtk render window -->\n  <div id=\"vtkContainer\"></div>\n\n  <script>\n    // Entry point of the application\n    (async function () {\n      // Import required modules from vtk.js\n      const vtk = window.vtk;\n      const vtkActor = vtk.Rendering.Core.vtkActor;\n      const vtkMapper = vtk.Rendering.Core.vtkMapper;\n      const vtkRenderWindow = vtk.Rendering.Core.vtkRenderWindow;\n      const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n      const vtkRenderWindowInteractor = vtk.Rendering.Core.vtkRenderWindowInteractor;\n      const vtkHttpDataSetReader = vtk.IO.HTTP.vtkHttpDataSetReader;\n      const vtkColorTransferFunction = vtk.Common.DataModel.vtkColorTransferFunction;\n\n      // Create the render window and renderer\n      const renderWindow = vtkRenderWindow.newInstance();\n      const renderer = vtkRenderer.newInstance();\n      renderWindow.addRenderer(renderer);\n\n      // Create an interactor to handle user interaction\n      const interactor = vtkRenderWindowInteractor.newInstance();\n      interactor.setRenderWindow(renderWindow);\n\n      // Create a reader to load the VTP file from the local server\n      const reader = vtkHttpDataSetReader.newInstance({ url: 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp' });\n\n      // Wait for the data to be read\n      await reader.loadData();\n\n      // Create a mapper and set the input connection from the reader\n      const mapper = vtkMapper.newInstance();\n      mapper.setInputConnection(reader.getOutputPort());\n\n      // Set scalar visibility to true to use scalar values for color mapping\n      mapper.setScalarVisibility(true);\n      // Specify the scalar array name \"p\" for color encoding\n      mapper.setColorArrayName('p');\n      // Use scalar mode to map by point data\n      mapper.setScalarModeToUsePointData();\n\n      // Create a color transfer function for scalar mapping\n      const colorTransferFunction = vtkColorTransferFunction.newInstance();\n      // Add color stops for the scalar range (you can customize these as needed)\n      colorTransferFunction.addRGBPoint(0.0, 0.0, 0.0, 1.0); // Black at low scalar value\n      colorTransferFunction.addRGBPoint(1.0, 1.0, 0.0, 0.0); // Red at high scalar value\n\n      // Assign the color transfer function to the mapper\n      mapper.setLookupTable(colorTransferFunction);\n\n      // Create an actor and set the mapper\n      const actor = vtkActor.newInstance();\n      actor.setMapper(mapper);\n\n      // Add the actor to the renderer\n      renderer.addActor(actor);\n\n      // Get the bounds of the dataset to position the camera correctly\n      const bounds = reader.getOutputData().getBounds();\n      console.log(\"Dataset Bounds:\", bounds);\n\n      // Position the camera to focus on the dataset\n      const center = [\n        (bounds[0] + bounds[1]) / 2,\n        (bounds[2] + bounds[3]) / 2,\n        (bounds[4] + bounds[5]) / 2\n      ];\n\n      // Set camera position to view the dataset from a default angle\n      const camera = renderer.getActiveCamera();\n      camera.setPosition(center[0], center[1], center[2] + 50); // Adjust z-position for better view\n      camera.setFocalPoint(center[0], center[1], center[2]);\n      camera.setClippingRange(0.1, 1000);\n\n      // Render the scene\n      renderWindow.render();\n\n      // Start the interactor to enable mouse and keyboard controls\n      interactor.initialize();\n      interactor.start();\n    })();\n  </script>\n</body>\n</html>\n```",
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": "Generate HTML with vtk.js to visualize volume rendering\n\nLoad from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp\nScalar Mapping:\nActivates the p scalar array for color encoding\nVisualization:\nRenders the colors and representation\npositions the camera to focus on the dataset bounds",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-32b",
        "evaluator": "qwen3-32b",
        "score": "0.8",
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1748099876",
        "eval_user": "test",
        "eval_time": "2025-05-24 23:17:56",
        "evaluator_evaluation": null,
        "options": null,
        "evaluatorEvaluation": "<Score>0.8</Score>\n<Explanation>The generated code is mostly readable and correct, but there are a few issues compared to the ground truth:\n\n1. **Correctness**:\n   - The code successfully loads a VTP file from the local server and sets up rendering using `vtkHttpDataSetReader`, `vtkMapper`, and `vtkActor`.\n   - It uses scalar visibility and color mapping with a custom color transfer function, which matches the ground truth's intention of visualizing scalar data.\n   - Camera positioning and centering based on dataset bounds is also handled correctly.\n\n2. **Missing Elements**:\n   - The ground truth includes a full-screen render window using `vtkFullScreenRenderWindow`, while the generated code manually creates `vtkRenderWindow` and `vtkRenderer`. This is not incorrect but less convenient for full-screen use.\n   - The ground truth adds an orientation marker (axes widget), which is missing in the generated code.\n\n3. **Readability**:\n   - The code is well-structured, uses modern JavaScript syntax (e.g., async/await), and includes clear comments, making it highly readable.\n   - However, some modules like `vtkColorTransferFunction` are imported from `Common.DataModel`, whereas in the ground truth, they are typically from `Rendering.Core`.\n\n4. **Minor Inconsistencies**:\n   - The camera z-position offset (`+50`) in the generated code is significantly different from the ground truth (`+5`). While this doesn't make it incorrect, it changes the view angle.\n\nOverall, the generated code is 80% aligned with the ground truth in terms of functionality and structure but lacks a few features and has minor deviations in module usage and camera setup.</Explanation>"
    },
    {
        "path": "IO-Rendering\\colors and representation\\airfoil_oneslice\\description.txt",
        "name": "description.txt",
        "prompt": "Generate HTML with vtk.js to visualize volume rendering\n\nLoad from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp\nScalar Mapping:\nActivates the p scalar array for color encoding\nVisualization:\nRenders the colors and representation\npositions the camera to focus on the dataset bounds",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>VTK.js Volume Rendering Example</title>\n  <!-- 引入 VTK.js 的核心库 -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <style>\n    /* 设置渲染窗口为全屏显示 */\n    body, html {\n      margin: 0;\n      height: 100%;\n    }\n    #container {\n      width: 100%;\n      height: 100%;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <script>\n    // 使用vtk模块加载器来异步导入所需组件\n    const vtk = window.vtk;\n\n    (async () => {\n      // 1. 创建数据集读取器，用于从指定URL加载VTP文件\n      const reader = vtk.io.http.HttpDataSetReader.newInstance();\n      reader.setUrl(\"https://example.com/path/to/airfoil_oneslice.vtp\"); // 替换为实际的VTP文件地址\n\n      // 2. 等待数据加载完成\n      await reader.loadData();\n\n      // 3. 创建Mapper对象，将数据集映射为图形表示\n      const mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n      mapper.setInputConnection(reader.getOutputPort());\n\n      // 4. 创建Actor对象，用于定义如何在场景中渲染数据\n      const actor = vtk.Rendering.Core.vtkActor.newInstance();\n      actor.setMapper(mapper);\n\n      // 5. 创建颜色映射（Color Map）并将其应用于Mapper\n      // 这里使用简单的线性映射（可以根据需求自定义）\n      const colorTransferFunction = vtk.Common.DataModel.vtkColorTransferFunction.newInstance();\n      colorTransferFunction.addRGBPoint(0.0, 0.0, 0.0, 1.0);   // 黑色\n      colorTransferFunction.addRGBPoint(1.0, 1.0, 0.0, 0.0);   // 红色\n      mapper.setColorMap(colorTransferFunction);\n\n      // 6. 创建Renderer对象，用于管理渲染场景\n      const renderer = vtk.Rendering.Core.vtkRenderer.newInstance();\n\n      // 将Actor添加到渲染器中\n      renderer.addActor(actor);\n\n      // 设置背景颜色\n      renderer.setBackground(0.1, 0.2, 0.4);\n\n      // 7. 创建RenderWindow对象，并设置容器\n      const renderWindow = vtk.Rendering.Core.vtkRenderWindow.newInstance();\n      renderWindow.addRenderer(renderer);\n      const widget = document.getElementById('container');\n      renderWindow.setContainer(widget);\n\n      // 8. 初始化渲染并自动调整相机视角以聚焦于数据边界\n      renderWindow.render(); // 初次渲染\n\n      // 自动调整相机位置以聚焦于数据集边界\n      renderer.resetCamera();\n      renderWindow.render(); // 再次渲染以应用相机调整\n    })();\n  </script>\n</body>\n</html>\n```",
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": "\n    用户需求分析：\n    1. 主要目标：三维体渲染可视化 - 使用VTK.js从指定URL加载数据集，并对体积数据进行颜色映射和渲染，设置相机位置以聚焦数据集边界\n    2. 数据来源：airfoil_oneslice.vtp (VTP文件)\n    3. 关键API：vtkHttpDataSetReader, vtkMapper, vtkActor, vtkRenderer, vtkRenderWindow\n    \n    ",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-32b",
        "evaluator": "qwen3-32b",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1748100257",
        "eval_user": "test",
        "eval_time": "2025-05-24 23:24:17",
        "evaluator_evaluation": null,
        "options": null,
        "evaluatorEvaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly readable and structurally correct for a basic VTK.js visualization setup. It includes essential components like reader, mapper, actor, renderer, and render window with proper data flow. However, there are some issues: 1) The code uses the incorrect class vtk.Common.DataModel.vtkColorTransferFunction instead of the correct vtk.Rendering.Core.vtkColorTransferFunction; 2) It's missing the fullScreenRenderWindow functionality that provides better interactivity in the ground truth version; 3) It lacks the coordinate axis indicator (vtkAxesActor) which was present in the ground truth; 4) The camera positioning logic is simplified compared to the more detailed implementation in the ground truth. These omissions make it less complete as a scientific visualization example.</Explanation>"
    }
]