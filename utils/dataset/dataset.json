[
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 使用vtk命名空间引用必要的类\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkDataSetReader = vtk.IO.Core.vtkDataSetReader;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkRenderWindow = vtk.Rendering.Core.vtkRenderWindow;\n        const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPhongMaterial = vtk.Rendering.Core.vtkPhongMaterial;\n        const vtkAxesActor = vtk.Widgets.Core.vtkAxesActor;\n\n        // 创建渲染器和渲染窗口\n        const renderer = vtkRenderer.newInstance();\n        const renderWindow = vtkRenderWindow.newInstance();\n        renderWindow.addView(renderer);\n\n        // 创建Actor和Mapper\n        const actor = vtkActor.newInstance();\n        const mapper = vtkMapper.newInstance();\n\n        // 加载数据\n        const reader = vtkDataSetReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp', { loadData: true })\n            .then(() => {\n                mapper.setInputData(reader.getOutputData());\n                actor.setMapper(mapper);\n\n                // 设置颜色映射（蓝色到红色）\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(0, 0, 0, 1); // 蓝色\n                colorTransferFunction.addRGBPoint(1, 1, 0, 0); // 红色\n                mapper.setColorTransferFunction(colorTransferFunction);\n\n                // 设置Phong光照效果\n                const material = vtkPhongMaterial.newInstance();\n                material.setAmbient(0.3);\n                material.setDiffuse(0.7);\n                material.setSpecular(0.4);\n                material.setSpecularPower(30);\n                actor.setMaterial(material);\n\n                // 添加XYZ轴小部件\n                const axesActor = vtkAxesActor.newInstance();\n                axesActor.setTotalLength(100, 100, 100);\n                axesActor.setTickVisibility(true);\n                renderer.addActor(axesActor);\n\n                // 设置线宽\n                actor.getProperty().setLineWidth(2.0);\n\n                // 调整相机视角\n                renderer.resetCamera();\n                renderer.getActiveCamera().setViewUp(0, 1, 0);\n                renderer.getActiveCamera().setPosition(0, 0, 500);\n                renderer.getActiveCamera().setFocalPoint(0, 0, 0);\n                renderer.getActiveCamera().computeViewPlaneNormal();\n\n                // 渲染\n                renderWindow.render();\n            });\n\n        // 将渲染器添加到页面\n        const container = document.getElementById('renderer');\n        renderWindow.attachToFrame(container);\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-r1-distill-qwen-32b",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.4",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1746975171",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.4</Score>\n<Explanation>The generated code is somewhat readable but has several issues. It uses vtkDataSetReader instead of vtkXMLPolyDataReader, which might not handle the .vtp file correctly. It also lacks the cutting plane functionality and the orientation widget from the ground truth. The color transfer function is simpler and less accurate. The camera setup is different, and the styling is not as comprehensive. These differences reduce the correctness and functionality of the visualization.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary VTK.js modules\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n\n        // Initialize the full-screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Load the airfoil cross-section data from the provided URL\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // Create a mapper and actor for the data\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(reader.getOutputPort());\n\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // Set up the color transfer function for blue to red color mapping\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(0.0, 0.0, 0.0, 1.0); // Blue\n                colorTransferFunction.addRGBPoint(1.0, 1.0, 0.0, 0.0); // Red\n                mapper.setLookupTable(colorTransferFunction);\n\n                // Configure Phong shading with the specified parameters\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                actor.getProperty().setLineWidth(2.0);\n\n                // Add the actor to the renderer\n                renderer.addActor(actor);\n\n                // Add an XYZ axes widget for orientation\n                const axes = vtkAxesActor.newInstance();\n                const widget = vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT);\n                widget.setViewportSize(0.15);\n\n                // Render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747024738",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.7</Score>\n<Explanation>\nThe generated code is mostly readable and covers the main functionalities of the ground truth code. However, it lacks some important features and has some inaccuracies:\n1. The HTML structure is similar but simpler, which is acceptable.\n2. The JavaScript code imports necessary modules but misses some key classes (e.g., vtkXMLPolyDataReader, vtkCutter).\n3. The color transfer function is simplified and doesn't use the actual data range.\n4. Some actor properties and camera settings are missing or simplified.\n5. The orientation widget is added but with slightly different positioning.\nOverall, the code is functional but less accurate and slightly less readable than the ground truth.\n</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary VTK.js modules\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n\n        // Set up the full-screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Load the airfoil cross-section data from the specified URL\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // Create a mapper and actor for the airfoil data\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(reader.getOutputData());\n\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // Set up the color transfer function for blue to red color mapping\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(0.0, 0.0, 0.0, 1.0); // Blue\n                colorTransferFunction.addRGBPoint(1.0, 1.0, 0.0, 0.0); // Red\n                mapper.setLookupTable(colorTransferFunction);\n\n                // Configure Phong shading with the specified parameters\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                actor.getProperty().setLineWidth(2.0);\n\n                // Add the actor to the renderer\n                renderer.addActor(actor);\n\n                // Add XYZ axes widget to the scene\n                const axes = vtkAxesActor.newInstance();\n                const widget = vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: fullScreenRenderer.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT);\n                widget.setViewportSize(0.15);\n\n                // Render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.6",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747025291",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.6</Score>\n<Explanation>The generated code is somewhat readable and partially correct. It includes essential components like the VTK.js setup, data loading, and visualization. However, it lacks important features such as the plane cutting functionality, proper camera positioning, and a more detailed color transfer function. These omissions make the visualization less accurate and less informative compared to the ground truth. Additionally, the HTML structure and styling are simpler, which may affect the overall user experience.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude  Load from http://127.0.0.1:5000/dataset/isabel.vti  Processing: - Calculate velocity magnitude from \"Velocity\" field - Set as active scalar \"velocityMagnitude\"  Visualization: - Blue to red color mapping - Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Data spacing: (2.5, 2.5, 5.0) - Line width: 2.0  Load vtk.js via CDN link: https://unpkg.com/vtk.js No GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Isabel Velocity Magnitude Visualization</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n\n    <script>\n        // Import necessary VTK.js classes\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n        const vtkRenderWindow = vtk.Rendering.Core.vtkRenderWindow;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // Initialize the full-screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance();\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Load the dataset from the provided URL\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti', { loadData: true }).then(() => {\n            // Calculate velocity magnitude from the \"Velocity\" field\n            const calculator = vtkCalculator.newInstance();\n            calculator.setFormulaSimple(\n                vtk.Common.DataModel.vtkDataSet.FieldAssociations.POINT, // Field association\n                ['Velocity'], // Input arrays\n                'velocityMagnitude', // Output array name\n                (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) // Formula to calculate magnitude\n            );\n            calculator.setInputConnection(reader.getOutputPort());\n\n            // Set the calculated velocity magnitude as the active scalar\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputConnection(calculator.getOutputPort());\n            mapper.setScalarModeToUsePointFieldData();\n            mapper.setColorByArrayName('velocityMagnitude');\n\n            // Create a color transfer function for blue to red mapping\n            const colorTransferFunction = vtkColorTransferFunction.newInstance();\n            colorTransferFunction.addRGBPoint(0, 0, 0, 1); // Blue at minimum\n            colorTransferFunction.addRGBPoint(1, 1, 0, 0); // Red at maximum\n            mapper.setLookupTable(colorTransferFunction);\n\n            // Create an actor and set its properties for surface rendering\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n            actor.getProperty().setAmbient(0.3); // Ambient lighting\n            actor.getProperty().setDiffuse(0.7); // Diffuse lighting\n            actor.getProperty().setSpecular(0.4); // Specular lighting\n            actor.getProperty().setLineWidth(2.0); // Line width\n\n            // Add the actor to the renderer\n            renderer.addActor(actor);\n\n            // Add XYZ axes widget\n            const axes = vtkAxesActor.newInstance();\n            renderer.addActor(axes);\n\n            // Set data spacing\n            const imageData = reader.getOutputData();\n            imageData.setSpacing(2.5, 2.5, 5.0);\n\n            // Reset the camera and render the scene\n            renderer.resetCamera();\n            renderWindow.render();\n        });\n    </script>\n</body>\n\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747030256",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.7</Score>\n<Explanation>The generated code is readable and achieves the goal of visualizing the Isabel dataset's velocity magnitude. However, it lacks some features present in the ground truth, such as detailed camera setup, orientation widget customization, and a more sophisticated color mapping. Additionally, the color transfer function uses fewer control points, which may result in less accurate visualization of the data range. The code is concise and functional but could benefit from including more detailed setup for better visualization quality and user interaction.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude  Load from http://127.0.0.1:5000/dataset/isabel.vti  Processing: - Calculate velocity magnitude from \"Velocity\" field - Set as active scalar \"velocityMagnitude\"  Visualization: - Blue to red color mapping - Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Data spacing: (2.5, 2.5, 5.0) - Line width: 2.0  Load vtk.js via CDN link: https://unpkg.com/vtk.js No GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>3D Sliced Data Visualization</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n\n    <script>\n        // vtk.js visualization setup\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance();\n        const renderer = fullScreenRenderWindow.getRenderer();\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n        // Load VTI dataset from specified URL\n        const httpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader.newInstance();\n        httpDataSetReader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti', { loadData: true });\n\n        // Calculate velocity magnitude\n        const calculator = vtk.Filters.General.vtkCalculator.newInstance();\n        calculator.setFormula('mag(Velocity)');\n        calculator.setInputConnection(httpDataSetReader.getOutputPort());\n        calculator.addResultArrayName('velocityMagnitude', vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes.SCALARS);\n\n        // Create mapper and actor for visualization\n        const mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n        mapper.setInputConnection(calculator.getOutputPort());\n\n        const actor = vtk.Rendering.Core.vtkActor.newInstance();\n        actor.setMapper(mapper);\n\n        // Set up color mapping (blue to red)\n        const colorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();\n        colorTransferFunction.addRGBPoint(0, 0, 0, 1); // Blue\n        colorTransferFunction.addRGBPoint(1, 1, 0, 0); // Red\n        mapper.setColorTransferFunction(colorTransferFunction);\n\n        // Set Phong shading properties\n        actor.getProperty().setAmbient(0.3);\n        actor.getProperty().setDiffuse(0.7);\n        actor.getProperty().setSpecular(0.4);\n        actor.getProperty().setShading(true);\n\n        // Add axes widget\n        const axesWidget = vtk.Interaction.Widgets.vtkAxesWidget.newInstance();\n        axesWidget.setRenderer(renderer);\n        axesWidget.setEnabled(true);\n\n        // Set data spacing and line width\n        const data = calculator.getOutputData();\n        data.setSpacing([2.5, 2.5, 5.0]);\n        actor.getProperty().setLineWidth(2.0);\n\n        // Add actor to renderer and render\n        renderer.addActor(actor);\n        renderer.resetCamera();\n        renderWindow.render();\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-r1-distill-qwen-32b",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.6",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747031008",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.6</Score>\n<Explanation>The generated code is partially correct but lacks some important features and has potential issues. It uses the correct approach for loading data and calculating velocity magnitude but uses vtkHttpDataSetReader instead of vtkXMLImageDataReader, which might not handle the XML structure properly. The visualization setup is simpler and might not handle the image data as efficiently. The color mapping is less detailed, and some important setup like data spacing and camera positioning are missing, which could affect the visualization's accuracy and user experience. The code is readable but not as correct as the ground truth.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude\n\nLoad from http://127.0.0.1:5000/dataset/isabel.vti\n\nProcessing:\n- Calculate velocity magnitude from \"Velocity\" field\n- Set as active scalar \"velocityMagnitude\"\n\nVisualization:\n- Blue to red color mapping\n- Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4)\n- XYZ axes widget\n- Data spacing: (2.5, 2.5, 5.0)\n- Line width: 2.0\n\nLoad vtk.js via CDN link: https://unpkg.com/vtk.js\nNo GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Velocity Magnitude Visualization</title>\n</head>\n<body>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary VTK.js classes\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n\n        // Initialize render window\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderWindow.getRenderer();\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n        // Set up data reader\n        const reader = vtkDataSetReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti', { loadData: true });\n\n        // Add calculator to compute velocity magnitude\n        reader.then(() => {\n            const data = reader.getOutputData();\n            \n            // Calculate velocity magnitude\n            const calculator = vtkCalculator.newInstance();\n            calculator.setFormula(\n                vtkDataSetAttributes.AttributeTypes.POINT,\n                ['Velocity'],\n                'velocityMagnitude',\n                (v) => Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])\n            );\n            calculator.setInputData(data);\n            \n            // Create mapper and actor\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputConnection(calculator.getOutputPort());\n            mapper.setColorByArrayName('velocityMagnitude');\n            \n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n            \n            // Set up color mapping\n            const colorTransferFunction = vtkColorTransferFunction.newInstance();\n            colorTransferFunction.addRGBPoint(0, 0, 0, 1);    // Blue for low values\n            colorTransferFunction.addRGBPoint(100, 1, 0, 0);  // Red for high values\n            actor.getProperty().setRGBTransferFunction(colorTransferFunction);\n            \n            // Set Phong shading properties\n            actor.getProperty().setInterpolationToPhong();\n            actor.getProperty().setAmbient(0.3);\n            actor.getProperty().setDiffuse(0.7);\n            actor.getProperty().setSpecular(0.4);\n            \n            // Add actor to renderer\n            renderer.addActor(actor);\n            \n            // Add axes actor\n            const axes = vtkAxesActor.newInstance();\n            axes.setScale(2.5, 2.5, 5.0); // Match data spacing\n            renderer.addActor(axes);\n            \n            // Set up camera and render\n            renderer.resetCamera();\n            renderWindow.render();\n        });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-r1-distill-qwen-32b",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.75",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747032346",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.75</Score>\n<Explanation>The generated code is mostly correct and readable, but it lacks some important features and details present in the ground truth. For example, it uses a simpler color transfer function and does not include the orientation marker widget. Additionally, the camera setup is less detailed, and the axes actor scaling does not match the data spacing. However, the core functionality of visualizing the velocity magnitude is correctly implemented.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude\n\nLoad from http://127.0.0.1:5000/dataset/isabel.vti\n\nProcessing:\n- Calculate velocity magnitude from \"Velocity\" field\n- Set as active scalar \"velocityMagnitude\"\n\nVisualization:\n- Blue to red color mapping\n- Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4)\n- XYZ axes widget\n- Data spacing: (2.5, 2.5, 5.0)\n- Line width: 2.0\n\nLoad vtk.js via CDN link: https://unpkg.com/vtk.js\nNo GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js Velocity Magnitude Visualization</title>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary vtk.js modules\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n\n        // Initialize the render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n            rootContainer: document.getElementById('renderer'),\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Load the dataset from the specified URL\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti', { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n\n                // Calculate velocity magnitude from the \"Velocity\" field\n                const calculator = vtkCalculator.newInstance();\n                calculator.setFormulaSimple(\n                    vtk.Common.DataModel.vtkDataSetAttributes.AttributeTypes.POINT,\n                    ['Velocity'],\n                    'velocityMagnitude',\n                    (velocity) => Math.sqrt(velocity[0] ** 2 + velocity[1] ** 2 + velocity[2] ** 2)\n                );\n                calculator.setInputData(data);\n                const output = calculator.getOutputData();\n\n                // Set \"velocityMagnitude\" as the active scalar\n                output.getPointData().setActiveScalars('velocityMagnitude');\n\n                // Create a mapper and set the input data\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(output);\n\n                // Create a color transfer function for blue to red mapping\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(0, 0, 0, 1); // Blue\n                colorTransferFunction.addRGBPoint(1, 1, 0, 0); // Red\n\n                // Create an actor and set its properties\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setColorTransferFunction(colorTransferFunction);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                actor.getProperty().setLineWidth(2.0);\n\n                // Add the actor to the renderer\n                renderer.addActor(actor);\n\n                // Add XYZ axes widget\n                const axes = vtkAxesActor.newInstance();\n                renderer.addActor(axes);\n\n                // Set data spacing\n                output.setSpacing(2.5, 2.5, 5.0);\n\n                // Reset the camera and render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error('Error loading data:', error);\n            });\n    </script>\n</body>\n\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747039477",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.7</Score>\n<Explanation>The generated code is correct but lacks some features present in the ground truth, such as the orientation widget and detailed camera setup. It is readable but could be improved by including these components for a more comprehensive visualization.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude\n\nLoad from http://127.0.0.1:5000/dataset/isabel.vti\n\nProcessing:\n- Calculate velocity magnitude from \"Velocity\" field\n- Set as active scalar \"velocityMagnitude\"\n\nVisualization:\n- Blue to red color mapping\n- Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4)\n- XYZ axes widget\n- Data spacing: (2.5, 2.5, 5.0)\n- Line width: 2.0\n\nLoad vtk.js via CDN link: https://unpkg.com/vtk.js\nNo GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Velocity Magnitude Visualization</title>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Visualization initialization\n        const renderer = vtk.Rendering.Core.vtkRenderer.newInstance();\n        const renderWindow = vtk.Rendering.Core.vtkRenderWindow.newInstance();\n        renderWindow.addView(renderer);\n        \n        // Create axes widget\n        const axesWidget = vtk.Interaction.Widgets.vtkAxesWidget.newInstance();\n        axesWidget.setAxesScale(50);\n        axesWidget.setRenderer(renderer);\n        axesWidget.setRenderWindow(renderWindow);\n        axesWidget.setEnabled(true);\n        \n        // Load data from server\n        const reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti', { loadData: true });\n\n        // Calculate velocity magnitude\n        const calculator = vtk.Filters.General.vtkCalculator.newInstance();\n        calculator.setFormula('mag(Velocity)', vtk.DataArray.VTK_FLOAT);\n        calculator.setInputArray('Velocity', vtk.DataArray.VTK_VEC3);\n        calculator.setOutputArrayName('velocityMagnitude');\n\n        // Create color transfer function\n        const colorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();\n        colorTransferFunction.addRGBPoint(0, 0, 0, 1);  // Blue\n        colorTransferFunction.addRGBPoint(1, 1, 0, 0);  // Red\n\n        // Create mapper and actor\n        const mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n        const actor = vtk.Rendering.Core.vtkActor.newInstance();\n        \n        // Set up actor properties\n        actor.getProperty().setShading(true);\n        actor.getProperty().setAmbient(0.3);\n        actor.getProperty().setDiffuse(0.7);\n        actor.getProperty().setSpecular(0.4);\n        actor.getProperty().setLineWidth(2.0);\n\n        // Connect pipeline\n        reader.addOutput(calculator);\n        mapper.setInputConnection(calculator.getOutputPort());\n        actor.setMapper(mapper);\n\n        // Add actor to renderer\n        renderer.addActor(actor);\n        renderer.setBackground(0, 0, 0);  // Black background\n\n        // Set up color mapping\n        mapper.setLookupTable(colorTransferFunction);\n        mapper.setColorModeToMapScalars();\n        mapper.setScalarRange(0, 1);\n\n        // Set data spacing\n        reader.getOutputData().setSpacing(2.5, 2.5, 5.0);\n\n        // Add to DOM\n        document.body.appendChild(renderWindow.getContainer());\n\n        // Render\n        renderWindow.render();\n        renderer.getActiveCamera().azimuth(30);\n        renderer.getActiveCamera().elevation(30);\n        renderer.resetCamera();\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-r1-distill-qwen-32b",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": true
        },
        "eval_id": "1747040398",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.7</Score>\n<Explanation>The generated code is functional and achieves the main goal of visualizing the dataset. However, it lacks some features present in the ground truth, such as the orientation marker widget and slicing functionality. Additionally, the camera setup is simplified. The code is readable but could benefit from more detailed comments for better understanding.</Explanation>",
        "options": {
            "error_type_list": [],
            "generated_code": "",
            "loop_time": 0,
            "error_log": ""
        }
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude\n\nLoad from http://127.0.0.1:5000/dataset/isabel.vti\n\nProcessing:\n- Calculate velocity magnitude from \"Velocity\" field\n- Set as active scalar \"velocityMagnitude\"\n\nVisualization:\n- Blue to red color mapping\n- Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4)\n- XYZ axes widget\n- Data spacing: (2.5, 2.5, 5.0)\n- Line width: 2.0\n\nLoad vtk.js via CDN link: https://unpkg.com/vtk.js\nNo GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js Velocity Magnitude Visualization</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary VTK.js classes\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkCalculator = vtk.Filters.General.vtkCalculator;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n\n        // Initialize the render window and renderer\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Load the dataset from the specified URL\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti', { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n\n                // Calculate velocity magnitude from the \"Velocity\" field\n                const calculator = vtkCalculator.newInstance();\n                calculator.setInputData(data);\n                calculator.setFormula({\n                    getArrays: (inputDataSets) => {\n                        const velocityArray = inputDataSets[0].getPointData().getArray('Velocity');\n                        return [velocityArray];\n                    },\n                    getFormula: (arrays) => {\n                        const velocity = arrays[0];\n                        return `sqrt(${velocity}[0] * ${velocity}[0] + ${velocity}[1] * ${velocity}[1] + ${velocity}[2] * ${velocity}[2])`;\n                    },\n                });\n                calculator.setResultArrayName('velocityMagnitude');\n                calculator.update();\n\n                // Set the calculated velocity magnitude as the active scalar\n                const outputData = calculator.getOutputData();\n                outputData.getPointData().setActiveScalars('velocityMagnitude');\n\n                // Create a mapper and set the input data\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(outputData);\n\n                // Create a color transfer function for blue to red color mapping\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const range = outputData.getPointData().getArray('velocityMagnitude').getRange();\n                colorTransferFunction.addRGBPoint(range[0], 0, 0, 1); // Blue\n                colorTransferFunction.addRGBPoint(range[1], 1, 0, 0); // Red\n                mapper.setLookupTable(colorTransferFunction);\n\n                // Create an actor and set the mapper\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // Configure Phong shading properties\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                actor.getProperty().setLineWidth(2.0);\n\n                // Add the actor to the renderer\n                renderer.addActor(actor);\n\n                // Add XYZ axes widget\n                const axes = vtkAxesActor.newInstance();\n                const axesWidget = vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: fullScreenRenderer.getInteractor(),\n                });\n                axesWidget.setEnabled(true);\n                axesWidget.setViewportCorner(\n                    vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n\n                // Set data spacing\n                outputData.setSpacing(2.5, 2.5, 5.0);\n\n                // Reset the camera and render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error('Error loading dataset:', error);\n            });\n    </script>\n</body>\n\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.9",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747040892",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.9</Score>\n<Explanation>The generated code is correct and achieves the intended visualization. It uses proper VTK.js classes and methods for loading the dataset, calculating velocity magnitude, and setting up the visualization. The code is well-structured and readable. The only minor difference from the ground truth is the use of a simpler color transfer function and the absence of some debugging console outputs, but these do not affect the correctness of the visualization.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering\n\nLoad from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp\nRender scalar field \"p\"\n\nUse vtkFullScreenRenderWindow\nLoad vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\..\\..\\vtkjs-benchmark-datasets\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Airfoil Pressure Field Volume Rendering</title>\n</head>\n<body>\n<script src=\"https://unpkg.com/vtk.js\"></script>\n<script>\n// 核心类库引入\nconst vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\nconst vtkVolume = vtk.Rendering.Core.vtkVolume;\nconst vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\nconst vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\nconst vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\nconst vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n// 初始化全屏渲染窗口\nconst fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n    background: [0.2, 0.2, 0.2],  // 深灰色背景提升对比度\n});\nconst renderer = fullScreenRenderWindow.getRenderer();\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n// 创建HTTP数据读取器\nconst reader = vtkHttpDataSetReader.newInstance({\n    fetchGzip: true  // 启用gzip压缩传输\n});\n\n// 配置数据源路径（用户指定的VTP文件）\nconst dataURL = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n\nreader.setUrl(dataURL, { loadData: true }).then(() => {\n    // 数据加载完成后的处理\n    const dataset = reader.getOutputData();\n    \n    // 配置体渲染映射器\n    const mapper = vtkVolumeMapper.newInstance();\n    mapper.setInputData(dataset);\n    mapper.setSampleDistance(0.5);  // 优化渲染质量与性能平衡\n    \n    // 创建不透明度传递函数（重点显示压力变化区域）\n    const opacityTransferFunction = vtkPiecewiseFunction.newInstance();\n    const scalarRange = dataset.getPointData().getScalars('p').getRange();\n    opacityTransferFunction.addPoint(scalarRange[0], 0.0);  // 最小值完全透明\n    opacityTransferFunction.addPoint(scalarRange[1]*0.3, 0.0); // 低值区透明\n    opacityTransferFunction.addPoint(scalarRange[1]*0.6, 0.4); // 中值区半透明\n    opacityTransferFunction.addPoint(scalarRange[1], 0.9); // 高值区不透明\n\n    // 创建颜色传递函数（彩虹色系可视化压力分布）\n    const colorTransferFunction = vtkColorTransferFunction.newInstance();\n    colorTransferFunction.addRGBPoint(scalarRange[0], 0.0, 0.0, 1.0);  // 蓝色低值\n    colorTransferFunction.addRGBPoint(scalarRange[1]*0.5, 0.0, 1.0, 0.0);  // 绿色中值\n    colorTransferFunction.addRGBPoint(scalarRange[1], 1.0, 0.0, 0.0);  // 红色高值\n\n    // 配置体渲染属性\n    const volumeActor = vtkVolume.newInstance();\n    const property = volumeActor.getProperty();\n    property.setRGBTransferFunction(0, colorTransferFunction);\n    property.setScalarOpacity(0, opacityTransferFunction);\n    property.setInterpolationTypeToLinear();  // 线性插值平滑显示\n    property.setUseGradientOpacity(0, true);  // 启用梯度不透明度增强边界\n\n    // 连接组件并启动渲染\n    volumeActor.setMapper(mapper);\n    renderer.addVolume(volumeActor);\n    renderer.resetCamera();  // 自动调整摄像机视角\n    renderWindow.render();  // 执行渲染操作\n\n    // 添加窗口大小自适应（可选增强功能）\n    window.addEventListener('resize', () => {\n        fullScreenRenderWindow.resize();\n        renderWindow.render();\n    });\n}).catch(error => {\n    console.error('数据加载失败:', error);\n});\n</script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-r1",
        "evaluator": "deepseek-r1-distill-qwen-32b",
        "score": "0.85",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747127781",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n<Score>0.85</Score>\n<Explanation>The generated code is mostly correct and readable. It implements a volume rendering approach instead of the surface LIC method used in the ground truth. The code correctly sets up the visualization pipeline, including data loading, transfer functions, and rendering. However, it lacks some elements present in the ground truth, such as the orientation marker and vector field visualization. Despite these differences, the code is well-structured and achieves its intended visualization purpose effectively.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize sliced data with velocity magnitude  Load from http://127.0.0.1:5000/dataset/isabel.vti  Processing: - Calculate velocity magnitude from \"Velocity\" field - Set as active scalar \"velocityMagnitude\"  Visualization: - Blue to red color mapping - Surface rendering with Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Data spacing: (2.5, 2.5, 5.0) - Line width: 2.0  Load vtk.js via CDN link: https://unpkg.com/vtk.js No GUI controls required",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Isabel数据集切割渲染</title>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 渲染容器 -->\n    <div id=\"renderer\"></div>\n    <!-- 加载VTK.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入所需的VTK.js类\n        // 全屏渲染窗口类，用于创建和管理渲染环境\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        // 演员类，表示3D场景中的可视化对象\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        // 映射器类，将数据映射到图形表示\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        // XML图像数据读取器，用于加载VTI格式的数据\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n        // 平面类，用于定义切割平面\n        const vtkPlane = vtk.Common.DataModel.vtkPlane;\n        // 切割过滤器，用于根据平面切割数据\n        const vtkCutter = vtk.Filters.Core.vtkCutter;\n        // 颜色传输函数，用于定义数据值到颜色的映射\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        // 查找表，用于颜色映射（此处未使用）\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n\n        // 初始化渲染窗口，设置背景颜色为深灰色\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        // 获取渲染窗口实例，用于控制渲染过程\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        // 获取渲染器实例，用于管理场景中的演员\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建XML图像数据读取器实例\n        const reader = vtkXMLImageDataReader.newInstance();\n\n        // 设置数据文件URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti').then(() => {\n            // 数据URL设置成功后，加载数据\n            reader.loadData().then(() => {\n                // 获取加载的图像数据\n                const imageData = reader.getOutputData(0);\n\n                // 从数据中获取速度矢量场\n                const velocityArray = imageData.getPointData().getArrayByName('Velocity');\n                // 获取数据点的总数\n                const numPoints = imageData.getNumberOfPoints();\n                // 创建新数组存储速度大小\n                const magnitudeData = new Float64Array(numPoints);\n\n                // 计算每个点的速度大小（速度矢量的模）\n                for (let i = 0; i < numPoints; i++) {\n                    // 获取速度的三个分量\n                    const vx = velocityArray.getData()[3 * i + 0]; // x分量\n                    const vy = velocityArray.getData()[3 * i + 1]; // y分量\n                    const vz = velocityArray.getData()[3 * i + 2]; // z分量\n                    // 计算速度大小（欧几里得范数）\n                    magnitudeData[i] = Math.sqrt(vx * vx + vy * vy + vz * vz);\n                }\n\n                // 创建VTK数据数组类\n                const vtkDataArray = vtk.Common.Core.vtkDataArray;\n                // 创建速度大小的VTK数组\n                const magnitudeVtkArray = vtkDataArray.newInstance({\n                    numberOfComponents: 1, // 标量数据，只有一个分量\n                    values: magnitudeData, // 数据值\n                    name: 'velocityMagnitude', // 数组名称\n                });\n                // 将速度大小数组添加到数据集\n                imageData.getPointData().addArray(magnitudeVtkArray);\n                // 输出数据集信息用于调试\n                console.log(imageData.toJSON())\n\n                // 设置速度大小为活动标量，用于后续渲染\n                imageData.getPointData().setActiveScalars('velocityMagnitude');\n                // 设置数据间距，影响数据的物理尺寸\n                // 设置数据间距，根据数据集实际信息调整\n                // 原始数据范围为0-499，维度为200×200×100\n                imageData.setSpacing(2.5, 2.5, 5.0);\n\n                // 输出数据边界信息\n                console.log('数据边界:', imageData.getBounds());\n                // 输出数据维度信息\n                console.log('数据维度:', imageData.getDimensions());\n                // 输出数据间距信息\n                console.log('数据间距:', imageData.getSpacing());\n\n                // 获取速度大小的数据范围\n                const newRange = magnitudeVtkArray.getRange();\n                console.log('速度大小范围:', newRange);\n                // 解构赋值获取最小值和最大值\n                const [minV, maxV] = newRange;\n\n                // 输出活动标量名称\n                console.log('活动标量名称:', imageData.getPointData().getScalars().getName());\n\n                // 获取数据边界\n                const bounds = imageData.getBounds();\n                // 计算数据中心点\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // x中心\n                    (bounds[2] + bounds[3]) / 2, // y中心\n                    (bounds[4] + bounds[5]) / 2, // z中心\n                ];\n\n                // 使用vtkImageSlice替代vtkCutter\n                const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;\n                const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;\n\n                const imageMapper = vtkImageMapper.newInstance();\n                imageMapper.setInputData(imageData);\n                imageMapper.setSlice(Math.floor(imageData.getDimensions()[2] / 2)); // 在Z轴中间位置切片\n                imageMapper.setSlicingMode(2); // 2表示Z轴切片 (0:X, 1:Y, 2:Z)\n\n                // 创建颜色传输函数，定义数据值到颜色的映射\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                // 添加颜色控制点，从蓝色到红色的渐变\n                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 0.5);  // 最小值：深蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);  // 25%：蓝色\n                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);  // 50%：白色\n                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);  // 75%：橙色\n                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);  // 最大值：红色\n\n                // 创建不透明度传输函数\n                const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(minV, 1.0);\n                opacityFunction.addPoint(maxV, 1.0);\n\n                const imageSlice = vtkImageSlice.newInstance();\n                imageSlice.setMapper(imageMapper);\n                imageSlice.getProperty().setRGBTransferFunction(0, colorTransferFunction);\n                imageSlice.getProperty().setPiecewiseFunction(0, opacityFunction);  // 设置不透明度函数\n                imageSlice.getProperty().setScalarOpacity(0, opacityFunction);      // 设置标量不透明度\n                imageSlice.getProperty().setInterpolationTypeToLinear();\n\n                // 将演员添加到渲染器\n                renderer.addActor(imageSlice);\n\n                // 配置相机视角\n                const camera = renderer.getActiveCamera();\n                // 设置相机焦点为数据中心\n                camera.setFocalPoint(...center);\n                // 设置相机位置，从右上方观察\n                camera.setPosition(\n                    center[0] + 300,\n                    center[1] + 200,\n                    center[2] + 200\n                );\n                // 设置相机上方向为z轴正方向\n                camera.setViewUp(0, 0, 1);\n                // 重置相机，自动调整视角以显示所有对象\n                // 重置相机裁剪范围，确保所有对象都在视野内\n                renderer.resetCameraClippingRange();\n                // 执行渲染\n                renderWindow.render();\n                renderer.resetCamera();\n                // 再次渲染，应用相机调整\n                renderWindow.render();\n\n                // 添加坐标轴指示器，帮助理解3D空间方向\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                // 创建方向标记小部件\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes, // 使用坐标轴作为方向标记\n                    interactor: renderWindow.getInteractor(), // 设置交互器\n                });\n                // 启用方向标记小部件\n                widget.setEnabled(true);\n                // 设置小部件在视口中的位置（右下角）\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                // 设置小部件在视口中的大小\n                widget.setViewportSize(0.15);\n                // 设置小部件的最小像素大小\n                widget.setMinPixelSize(100);\n                // 设置小部件的最大像素大小\n                widget.setMaxPixelSize(300);\n\n                // 获取交互器，用于处理用户输入\n                const interactor = renderWindow.getInteractor();\n                // 启动交互，允许用户旋转、缩放等操作\n                interactor.start();\n            });\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>VTK.js 3D Velocity Magnitude Visualization</title>\n    <!-- 使用CDN加载vtk.js核心库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n<body>\n    <!-- 全屏渲染容器 -->\n    <div id=\"container\"></div>\n\n<script>\n// 从vtk命名空间解构所需模块\nconst {\n    vtkHttpDataSetReader,\n    vtkCalculator,\n    vtkColorTransferFunction,\n    vtkMapper,\n    vtkActor,\n    vtkOrientationWidget,\n    vtkRenderer,\n    vtkRenderWindow,\n} = vtk;\n\n// 初始化全屏渲染窗口\nconst fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n    background: [0, 0, 0],\n    container: document.getElementById('container')\n});\nconst renderWindow = fullScreenRenderWindow.getRenderWindow();\nconst renderer = fullScreenRenderWindow.getRenderer();\n\n// 创建HTTP数据读取器（用户指定数据源）\nconst reader = vtk.IO.Core.vtkHttpDataSetReader.newInstance({\n    fetchGzip: true  // 启用gzip压缩传输\n});\nreader.setUrl('http://127.0.0.1:5000/dataset/isabel.vti');\n\n// 创建计算器处理速度模值（核心数据处理）\nconst calculator = vtk.Filters.General.vtkCalculator.newInstance();\ncalculator.setFormula({\n    getArrays: (inputDataSets) => [{\n        name: 'Velocity',\n        dataType: 'Float32Array',\n        numberOfComponents: 3,\n    }],\n    // 计算速度模值公式：sqrt(vx^2 + vy^2 + vz^2)\n    formula: (weights, arrays) => {\n        const velocity = arrays.Velocity;\n        const result = new Float32Array(velocity.length/3);\n        for (let i = 0; i < velocity.length; i += 3) {\n            result[i/3] = Math.sqrt(\n                velocity[i] ** 2 +\n                velocity[i+1] ** 2 +\n                velocity[i+2] ** 2\n            );\n        }\n        return [{\n            name: 'velocityMagnitude',\n            dataType: 'Float32Array',\n            values: result,\n            numberOfComponents: 1,\n        }];\n    },\n});\n\n// 管线连接：reader -> calculator\ncalculator.setInputConnection(reader.getOutputPort());\n\n// 创建颜色传输函数（蓝到红渐变）\nconst colorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();\ncolorTransferFunction.addRGBPoint(0.0, 0.0, 0.0, 1.0);  // 蓝色起点\ncolorTransferFunction.addRGBPoint(100.0, 1.0, 0.0, 0.0); // 红色终点\n\n// 配置映射器（关键可视化参数）\nconst mapper = vtk.Rendering.Core.vtkMapper.newInstance();\nmapper.setInputConnection(calculator.getOutputPort());\nmapper.setScalarVisibility(true);\nmapper.setScalarMode(vtk.Rendering.Core.vtkMapper.ScalarMode.USE_POINT_FIELD_DATA);\nmapper.setColorMode(vtk.Rendering.Core.vtkMapper.ColorMode.DIRECT_SCALARS);\nmapper.setLookupTable(colorTransferFunction);\nmapper.setScalarRange(0, 100); // 根据实际数据范围调整\nmapper.setInterpolateScalarsBeforeMapping(true);\n\n// 配置Actor（表面渲染参数）\nconst actor = vtk.Rendering.Core.vtkActor.newInstance();\nactor.setMapper(mapper);\n// Phong着色参数设置\nactor.getProperty().setAmbient(0.3);    // 环境光强度\nactor.getProperty().setDiffuse(0.7);    // 漫反射强度\nactor.getProperty().setSpecular(0.4);   // 镜面反射强度\nactor.getProperty().setSpecularPower(100); // 高光锐度\nactor.getProperty().setEdgeVisibility(true);\nactor.getProperty().setLineWidth(2.0); // 线宽设置\n\n// 添加坐标轴部件\nconst orientationWidget = vtk.Interaction.Widgets.vtkOrientationWidget.newInstance();\norientationWidget.setPlaceFactor(1.0);\norientationWidget.setRenderer(renderer);\norientationWidget.setEnabled(true);\n\n// 设置数据空间参数\nreader.update().then(() => {\n    const data = reader.getOutputData();\n    data.setSpacing(2.5, 2.5, 5.0); // 设置数据间距 (2.5, 2.5, 5.0)\n    \n    // 触发渲染流程\n    renderer.addActor(actor);\n    renderer.resetCamera();\n    renderWindow.render();\n    \n    // 更新坐标轴部件尺寸\n    orientationWidget.updateRepresentation();\n});\n\n// 窗口调整时自动适配\nwindow.addEventListener('resize', () => renderWindow.render());\n</script>\n</body>\n</html>\n\n<!-- \n实现要点说明：\n1. 数据加载流程：\n   - 使用vtkHttpDataSetReader加载远程VTI数据\n   - 设置fetchGzip=true提升传输效率\n\n2. 速度模值计算：\n   - 通过vtkCalculator执行矢量模值计算\n   - 公式采用sqrt(vx²+vy²+vz²)实现精确计算\n   - 计算结果存储为velocityMagnitude标量场\n\n3. 可视化管道配置：\n   - 颜色映射使用蓝到红的线性渐变\n   - 启用Phong着色模型并配置光照参数\n   - 设置数据间距(2.5, 2.5, 5.0)反映实际物理尺寸\n\n4. 交互功能：\n   - 集成vtkOrientationWidget显示坐标轴\n   - 自动适配窗口大小变化\n\n5. 性能优化：\n   - 使用Float32Array提升计算效率\n   - 启用标量插值保证渲染质量\n   - 设置合理的标量范围提升颜色映射精度\n\n此实现严格遵循用户需求，未包含任何GUI控件，所有参数均硬编码实现。\n-->",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-r1",
        "evaluator": "deepseek-r1",
        "score": "0.6",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747310153",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "\n\n```\n<Score>0.6</Score>\n<Explanation>\nThe generated code demonstrates reasonable VTK.js structure but has significant functional deviations:\n1. **Missing Slicing Logic**: Uses regular actor instead of vtkImageSlice/vtkCutter for data slicing, rendering full 3D data instead of a 2D slice\n2. **Static Scalar Range**: Hardcodes scalar range (0-100) instead of dynamically calculating from data like the ground truth\n3. **Simplified Color Mapping**: Uses 2-point color transfer function vs the ground truth's 5-point nuanced gradient\n4. **Camera Configuration**: Lacks proper camera positioning (focal point, view up vector) and resetCamera() calls\n5. **Data Loading**: Uses vtkHttpDataSetReader instead of vtkXMLImageDataReader which may cause format compatibility issues\n\nReadability is good with clear comments, but core functionality differs from requirements. The absence of slicing implementation and static scalar range severely impact visualization correctness.\n</Explanation>\n```",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747365658",
        "eval_user": "test",
        "eval_time": "2025-05-16 11:20:58",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747366118",
        "eval_user": "test",
        "eval_time": "2025-05-16 11:28:38",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747367717",
        "eval_user": "test",
        "eval_time": "2025-05-16 11:55:17",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Volume Rendering with vtk.js</title>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary VTK.js classes\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolumeActor = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n\n        // Initialize the full-screen render window\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0], // Set background color to black\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // Set the data path and initialize the reader\n        const dataPath = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp'; // User-specified data path\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        // Load data from the specified path and render the results\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0); // Get the loaded data\n\n                // Create the volume mapper and set its properties\n                const mapper = vtkVolumeMapper.newInstance();\n                mapper.setInputData(data); // Set the input data\n                mapper.setSampleDistance(0.7); // Adjust sampling distance for better quality\n                mapper.setVolumetricScatteringBlending(0); // Disable volumetric scattering blending\n                mapper.setLocalAmbientOcclusion(0); // Disable local ambient occlusion\n                mapper.setLAOKernelSize(10); // Set kernel size for local ambient occlusion\n                mapper.setLAOKernelRadius(5); // Set kernel radius for local ambient occlusion\n                mapper.setComputeNormalFromOpacity(true); // Compute normals from opacity\n\n                // Create the volume actor and set its properties\n                const actor = vtkVolumeActor.newInstance();\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.1); // Add points to the opacity function\n                ofun.addPoint(255.0, 1.0);\n                actor.getProperty().setScalarOpacity(0, ofun); // Set scalar opacity\n                actor.getProperty().setInterpolationTypeToLinear(); // Set interpolation type to linear\n                actor.getProperty().setUseGradientOpacity(0, true); // Enable gradient opacity\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2); // Set minimum gradient opacity value\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0); // Set minimum gradient opacity\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20); // Set maximum gradient opacity value\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0); // Set maximum gradient opacity\n                actor.getProperty().setScalarOpacityUnitDistance(0, 2.955); // Set scalar opacity unit distance\n                actor.getProperty().setShade(true); // Enable shading\n                actor.getProperty().setAmbient(0.3); // Set ambient lighting\n                actor.getProperty().setDiffuse(1); // Set diffuse lighting\n                actor.getProperty().setSpecular(1); // Set specular lighting\n\n                // Set the mapper to the actor and add the actor to the renderer\n                actor.setMapper(mapper);\n                renderer.addActor(actor);\n\n                // Reset the camera and render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error('Error loading data:', error); // Handle any errors during data loading\n            });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": "0.5",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747368209",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.5</Score>\n<Explanation>The generated code has some readability issues and contains inaccuracies. While it correctly uses vtk.js for volume rendering, it does not match the original goal of surface rendering with Surface LIC. The code uses a volume renderer instead of a surface mapper, and some properties like 'setUseGradientOpacity' and 'setGradientOpacity...' are not valid for vtkVolumeActor. Additionally, the structure is less organized compared to the ground truth, making it harder to follow. The code also lacks proper comments and error handling in some areas.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Volume Rendering with vtk.js</title>\n</head>\n<body>\n    <!-- The div where the vtk.js renderer will be placed -->\n    <div id=\"renderer\"></div>\n    \n    <!-- Load vtk.js from CDN -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary vtk.js classes\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n\n        // Initialize the full-screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Create a mapper and actor for volume rendering\n        const mapper = vtkMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        // Set the data path and initialize the reader\n        const dataPath = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        // Load the dataset and render the scalar field \"p\"\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n\n                // Set the scalar field to \"p\" for rendering\n                const pointData = data.getPointData();\n                const scalarArray = pointData.getArrayByName(\"p\");\n                if (scalarArray) {\n                    pointData.setScalars(scalarArray);\n                } else {\n                    console.error(\"Scalar field 'p' not found in the dataset.\");\n                    return;\n                }\n\n                // Configure the mapper with the dataset\n                mapper.setInputData(data);\n\n                // Add the actor to the renderer\n                actor.setMapper(mapper);\n                renderer.addActor(actor);\n\n                // Reset the camera and render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error(\"Error loading dataset:\", error);\n            });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": "0.6",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747377813",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.6</Score>\n<Explanation>The generated code is partially correct but lacks several key elements from the ground truth. It uses a different reader (vtkHttpDataSetReader instead of vtkXMLPolyDataReader) and does not handle vector fields or color mapping as in the original. The code also omits important visualization features like surface rendering, lighting settings, and the orientation widget. While it renders a basic scalar field, it doesn't replicate the full functionality or visual quality of the ground truth code.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>VTK.js Volume Rendering Example</title>\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n    }\n  </style>\n</head>\n<body>\n  <!-- Load vtk.js from CDN -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <script>\n    // Import necessary VTK.js modules\n    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n    const vtkMapper = vtk.Rendering.Core.vtkMapper;\n    const vtkActor = vtk.Rendering.Core.vtkActor;\n    const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n\n    // Create a full-screen render window with black background\n    const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n      background: [0, 0, 0],\n    });\n\n    // Get the renderer and render window for further configuration\n    const renderer = fullScreenRenderWindow.getRenderer();\n    const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n    // Define the remote dataset URL (as per user's requirement)\n    const dataUrl = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n\n    // Create a reader to load the .vtp file via HTTP\n    const reader = vtkXMLPolyDataReader.newInstance();\n    \n    // Fetch the remote dataset using fetch API and pass it to the reader\n    fetch(dataUrl)\n      .then(response => response.arrayBuffer())\n      .then(buffer => {\n        // Parse the XML PolyData (.vtp) content\n        reader.parseAsArrayBuffer(buffer);\n\n        // Get the output polydata from the reader\n        const polydata = reader.getOutputData(0);\n\n        // Create a mapper and set the input data\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polydata);\n\n        // Set scalar field to \"p\" as requested by the user\n        mapper.setScalarModeToUsePointFieldData();\n        mapper.selectColorArray('p'); // Use \"p\" as the scalar field for coloring\n        mapper.setInterpolateScalarsBeforeMapping(true);\n        mapper.update(); // Update mapper after setting scalar info\n\n        // Create an actor and assign the mapper\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n\n        // Add the actor to the scene\n        renderer.addActor(actor);\n\n        // Reset camera to fit the geometry\n        renderer.resetCamera();\n\n        // Trigger initial render\n        renderWindow.render();\n      })\n      .catch(error => {\n        console.error('Error loading or parsing the .vtp file:', error);\n      });\n\n    // Optional: Handle window resize to keep rendering responsive\n    window.addEventListener('resize', () => {\n      fullScreenRenderWindow.resize();\n    });\n  </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747384004",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly correct and readable, but it lacks some key features from the ground truth. It correctly loads a VTP file and renders it with vtk.js, and uses modern practices like fetch API for loading data. However, it doesn't include important elements like the <div id=\"renderer\"> container, which is necessary for the full-screen render window to work properly. It also misses the camera configuration, scalar range logging, and the orientation axes widget that were present in the ground truth. Additionally, it doesn't handle the case where the data might not have the 'p' array, which could lead to errors.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": " <!DOCTYPE html>\n<html lang=\\\"en\\\">\n<head>\n    <meta charset=\\\"UTF-8\\\">\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\n    <title>VTK.js Volume Rendering - Airfoil</title>\n    <style>\n        body, html {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n    <script src=\\\"https://unpkg.com/vtk.js\\\"></script>\n    <script>\n        // Define the VTK.js components we need\n        // For rendering setup\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        \n        // For data representation\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        \n        // For data loading\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        \n        // For color mapping\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        \n        // Create the rendering window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1] // Dark gray background for better visualization\n        });\n        \n        // Get the renderer and render window references\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n        \n        // Create mapper and actor for visualization\n        const mapper = vtkMapper.newInstance();\n        const actor = vtkActor.newInstance();\n        \n        // Set up the actor with the mapper\n        actor.setMapper(mapper);\n        \n        // URL to the VTP file\n        const dataURL = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n        \n        // Create reader for VTP files\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        \n        // Load the data\n        reader.setUrl(dataURL)\n            .then(() => {\n                // Get the data from the reader\n                const polyData = reader.getOutputData();\n                \n                // Check if the data was loaded correctly\n                if (!polyData) {\n                    console.error('Failed to load polydata');\n                    return;\n                }\n                \n                // Check if the scalar field \\\"p\\\" exists\n                if (!polyData.getPointData().getArrayByName('p')) {\n                    console.error('Scalar field \\\"p\\\" not found in the dataset');\n                    return;\n                }\n                \n                // Activate the \\\"p\\\" scalar field for coloring\n                polyData.getPointData().setActiveScalars('p');\n                \n                // Set the polydata as input to the mapper\n                mapper.setInputData(polyData);\n                \n                // Set scalar visibility to true to use the \\\"p\\\" field for coloring\n                mapper.setScalarVisibility(true);\n                \n                // Set scalar mode to use point data (since \\\"p\\\" is point data)\n                mapper.setScalarModeToUsePointData();\n                \n                // Create a color lookup table for better visualization\n                const lookupTable = vtkColorTransferFunction.newInstance();\n                \n                // Get the range of the \\\"p\\\" values to create an appropriate color mapping\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                \n                // Set up a color map from blue to red for pressure values\n                lookupTable.addRGBPoint(dataRange[0], 0.0, 0.0, 1.0);  // Blue for low pressure\n                lookupTable.addRGBPoint((dataRange[0] + dataRange[1]) / 2, 0.0, 1.0, 0.0);  // Green for medium pressure\n                lookupTable.addRGBPoint(dataRange[1], 1.0, 0.0, 0.0);  // Red for high pressure\n                \n                // Set the lookup table to the mapper\n                mapper.setLookupTable(lookupTable);\n                \n                // Add the actor to the renderer\n                renderer.addActor(actor);\n                \n                // Reset the camera to ensure the data is visible\n                renderer.resetCamera();\n                \n                // Update the render window\n                renderWindow.render();\n                \n                console.log('Rendering complete. Data range for \\\"p\\\":', dataRange);\n            })\n            .catch((error) => {\n                console.error('Error loading the data:', error);\n                // Display error message on the screen\n                const errorDiv = document.createElement('div');\n                errorDiv.style.position = 'absolute';\n                errorDiv.style.top = '50%';\n                errorDiv.style.left = '50%';\n                errorDiv.style.transform = 'translate(-50%, -50%)';\n                errorDiv.style.color = 'white';\n                errorDiv.style.fontSize = '20px';\n                errorDiv.style.textAlign = 'center';\n                errorDiv.innerHTML = `Error loading data from ${dataURL}.<br>Please make sure the server is running and the file exists.`;\n                document.body.appendChild(errorDiv);\n            });\n            \n        // Add a window resize handler to maintain proper rendering when the browser window changes size\n        window.addEventListener('resize', () => {\n            fullScreenRenderer.resize();\n            renderWindow.render();\n        });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "claude-3.7-sonnet",
        "evaluator": "qwen3-turbo",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747402288",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly correct and readable, but there are some discrepancies compared to the ground truth. It uses vtkHttpDataSetReader instead of vtkXMLPolyDataReader, which may not be appropriate for VTP files. The code also lacks some features like camera setup and axes visualization present in the ground truth. Additionally, the structure is slightly different, with some parts omitted or reorganized. However, the core functionality of loading and rendering the dataset is implemented correctly.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "gemini-2.5",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747404815",
        "eval_user": "test",
        "eval_time": "2025-05-16 22:13:35",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "gemini-2.5",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747405757",
        "eval_user": "test",
        "eval_time": "2025-05-16 22:29:17",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js Volume Rendering Example</title>\n</head>\n<body>\n    <!-- Container for rendering the volume -->\n    <div id=\"renderer\"></div>\n\n    <!-- Load vtk.js from CDN -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Import necessary vtk.js modules for volume rendering\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkScalarBarActor = vtk.Rendering.Core.vtkScalarBarActor;\n\n        // Create a fullscreen render window instance\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1]  // Dark background for better contrast\n        });\n        const renderer = fullScreenRenderWindow.getRenderer();\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n        // Define the URL for loading the dataset\n        const dataPath = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        // Load the dataset asynchronously\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n                \n                // Create a color transfer function for rendering the scalar field \"p\"\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(0, 0, 0, 1);  // Blue for low values\n                colorTransferFunction.addRGBPoint(255, 1, 0, 0); // Red for high values\n\n                // Create an opacity transfer function for the scalar field \"p\"\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(0, 0.0);  // Transparency for low values\n                opacityFunction.addPoint(255, 1.0); // Full opacity for high values\n\n                // Create the volume mapper and associate the dataset with it\n                const volumeMapper = vtkVolumeMapper.newInstance();\n                volumeMapper.setInputData(data);\n\n                // Create the volume actor (used for volume rendering)\n                const volumeActor = vtkVolume.newInstance();\n                volumeActor.setMapper(volumeMapper);\n\n                // Apply the color and opacity functions to the volume actor's property\n                volumeActor.getProperty().setColor(colorTransferFunction);\n                volumeActor.getProperty().setScalarOpacity(opacityFunction);\n\n                // Add the volume actor to the renderer\n                renderer.addActor(volumeActor);\n\n                // Optional: Add a scalar bar to show the mapping between scalar values and colors\n                const scalarBar = vtkScalarBarActor.newInstance();\n                scalarBar.setOrientationToHorizontal();\n                scalarBar.setTitle(\"Scalar Field: p\");\n                scalarBar.setNumberOfLabels(5);\n                renderer.addActor(scalarBar);\n\n                // Adjust the camera to fit the view of the data\n                renderer.resetCamera();\n\n                // Render the scene\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error(\"Error loading the dataset:\", error);\n            });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "chatGPT-4o-mini",
        "evaluator": "qwen3-turbo",
        "score": "0.6",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747406479",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.6</Score>\n<Explanation>The generated code is partially correct but has several issues that reduce its readability and accuracy. First, it uses a volume rendering approach instead of surface rendering, which is inconsistent with the ground truth's use of a surface mapper. Second, it references 'vtkHttpDataSetReader' which is not suitable for loading VTP files (it's meant for VTK XML file formats), while the ground truth uses 'vtkXMLPolyDataReader'. Third, the code lacks proper camera setup and does not replicate the same visual output as the ground truth. However, the structure and some elements like the render window setup are similar and readable.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747541442",
        "eval_user": "test",
        "eval_time": "2025-05-18 12:10:42",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747542233",
        "eval_user": "test",
        "eval_time": "2025-05-18 12:23:53",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747542755",
        "eval_user": "test",
        "eval_time": "2025-05-18 12:32:35",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747542820",
        "eval_user": "test",
        "eval_time": "2025-05-18 12:33:40",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747545240",
        "eval_user": "test",
        "eval_time": "2025-05-18 13:14:00",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747573923",
        "eval_user": "test",
        "eval_time": "2025-05-18 21:12:03",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747575254",
        "eval_user": "test",
        "eval_time": "2025-05-18 21:34:14",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747626048",
        "eval_user": "test",
        "eval_time": "2025-05-19 11:40:48",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747641922",
        "eval_user": "test",
        "eval_time": "2025-05-19 16:05:22",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-section Visualization</title>\n    <style>\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n\n    <!-- 引入vtk.js库 -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // vtk命名空间下的常用类引入（适用于浏览器全局环境）\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n        const vtkRenderWindow = vtk.Rendering.Core.vtkRenderWindow;\n        const vtkRenderWindowInteractor = vtk.Rendering.Core.vtkRenderWindowInteractor;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n        const vtkAnnotatedCubeActor = vtk.Rendering.Core.vtkAnnotatedCubeActor;\n        const vtkInteractorStyleTrackballCamera = vtk.Interaction.Style.vtkInteractorStyleTrackballCamera;\n\n        // 创建渲染器、渲染窗口和交互器\n        const renderer = vtkRenderer.newInstance();\n        const renderWindow = vtkRenderWindow.newInstance();\n        renderWindow.addRenderer(renderer);\n\n        const interactor = vtkRenderWindowInteractor.newInstance();\n        interactor.setRenderWindow(renderWindow);\n\n        // 设置交互方式为轨道相机\n        const style = vtkInteractorStyleTrackballCamera.newInstance();\n        interactor.setStyle(style);\n\n        // 加载远程VTP文件\n        const reader = vtkXMLPolyDataReader.newInstance();\n        fetch('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp')\n            .then(res => res.arrayBuffer())\n            .then((arrayBuffer) => {\n                const data = arrayBuffer;\n                reader.parse(data);\n                \n                // 获取多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 创建颜色映射函数：从蓝色到红色\n                const colorMap = vtkColorTransferFunction.newInstance();\n                colorMap.addRGBPoint(0, 0, 0, 1);   // 蓝色\n                colorMap.addRGBPoint(1, 1, 0, 0);   // 红色\n\n                // 创建Mapper并设置颜色映射\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n                mapper.setColorModeToMapScalars(); // 启用标量映射\n                mapper.setScalarModeToUsePointFieldData(); // 使用点数据作为标量\n                mapper.setLookupTable(colorMap);\n\n                // 创建Actor并应用Phong着色参数\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setAmbient(0.3);     // 环境光系数\n                actor.getProperty().setDiffuse(0.7);     // 漫反射系数\n                actor.getProperty().setSpecular(0.4);    // 镜面反射系数\n                actor.getProperty().setLineWidth(2.0);   // 设置线宽\n\n                // 添加Actor到渲染器中\n                renderer.addActor(actor);\n\n                // 添加XYZ坐标轴控件（Axes Actor）\n                const axes = vtkAxesActor.newInstance();\n                axes.setTotalLength(1.0, 1.0, 1.0); // 设置三轴长度\n                renderer.addActor(axes);\n\n                // 设置背景颜色\n                renderer.setBackground(0.1, 0.2, 0.3);\n\n                // 初始化渲染窗口\n                renderWindow.render();\n\n                // 启动交互\n                interactor.initialize();\n                interactor.start();\n            })\n            .catch((err) => {\n                console.error('无法加载或解析VTP文件:', err);\n            });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747646101",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly correct and readable, but it lacks some key features from the ground truth. It does not include a cutting plane as described in the original code, which is an important part of the visualization. Additionally, the camera setup and orientation marker (like the vtkOrientationMarkerWidget) are missing, which were present in the ground truth. The code also uses a fixed height for the renderer, whereas the ground truth uses a full-screen approach. These omissions reduce its correctness relative to the original intent.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        /* Container for the 3D renderer */\n        #renderer {\n            width: 100%;\n            height: 600px;\n            background-color: #333;\n        }\n    </style>\n</head>\n<body>\n    <!-- Container div for the vtk.js render window -->\n    <div id=\"renderer\"></div>\n\n    <!-- Load vtk.js from CDN -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Import necessary modules from vtk.js\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPhongRepresentation = vtk.Rendering.Core.vtkPhongRepresentation;\n        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;\n        const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;\n\n        // Create a full-screen render window and interactor\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0.0, 0.0, 0.0], // black background\n            rootContainer: document.body,\n            rendererSelector: '#renderer'\n        });\n\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Step 1: Load VTP file using vtkXMLPolyDataReader\n        const reader = vtkXMLPolyDataReader.newInstance();\n        fetch('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp')\n            .then(res => res.arrayBuffer())\n            .then(data => {\n                reader.parseAsArrayBuffer(data);\n\n                // Step 2: Create mapper and set input data\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(reader.getOutputData(0));\n\n                // Step 3: Set up color mapping (blue to red)\n                const lut = vtkColorTransferFunction.newInstance();\n                lut.addRGBPoint(0.0, 0.0, 0.0, 1.0); // Blue\n                lut.addRGBPoint(1.0, 1.0, 0.0, 0.0); // Red\n                mapper.setLookupTable(lut);\n                mapper.setColorModeToMapScalars(); // Use scalar values to map colors\n                mapper.setScalarVisibility(true);   // Enable scalar coloring\n\n                // Step 4: Create actor and apply Phong shading parameters\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setInterpolationToPhong(); // Enable Phong shading\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n\n                // Step 5: Customize line width (if the dataset is wireframe or has lines)\n                actor.getProperty().setLineWidth(2.0);\n\n                // Step 6: Add actor to the scene\n                renderer.addActor(actor);\n\n                // Step 7: Add XYZ axes widget for orientation reference\n                const axesActor = vtkAxesActor.newInstance();\n                const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                    actor: axesActor,\n                    interactor: fullScreenRenderer.getInteractor()\n                });\n                orientationWidget.setInteractor(fullScreenRenderer.getInteractor());\n                orientationWidget.setEnabled(true);\n                orientationWidget.setViewportCorner(0, 0); // Bottom left corner\n                orientationWidget.setViewportSize(0.15);   // Size of the widget\n\n                // Step 8: Reset camera and render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            })\n            .catch(err => console.error('Error loading VTP file:', err));\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "deepseek-v3",
        "score": "0.6",
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747646594",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "```\n<Score>0.6</Score>\n<Explanation>The generated code is readable and follows a similar structure to the ground truth. However, it lacks some critical functionalities present in the ground truth, such as the cutting plane and the correct handling of the color transfer function based on the dataset's scalar range. Additionally, the generated code does not set the camera position and focal point, which are essential for proper visualization. The background color and container height are also arbitrarily set, which deviates from the ground truth's design. These omissions and deviations reduce the correctness and completeness of the generated code.</Explanation>\n```",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "chatGPT-4o-mini",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747650063",
        "eval_user": "test",
        "eval_time": "2025-05-19 18:21:03",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Uses vtkCutter and vtkPlane to cut the airfoil data to display its internal structure. - Performs color mapping on the cut surface based on the scalar value 'p' (possibly representing pressure) at the data points. - Sets the camera perspective and renders the scene. - Displays an orientation marker (axes) in the bottom-right corner.",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "chatGPT-4o-mini",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747655640",
        "eval_user": "test",
        "eval_time": "2025-05-19 19:54:00",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/deepwater.vti Render scalar field \"v02\" Color mapping of \"v02\" scalar field: Blue → White → Red gradient based on data values Transparency effects showing internal structures Lighting & Shading：Physically-based lighting",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Cutter Example</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <!-- <script src=\"https://unpkg.com/vtk.js\"></script> -->\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n\n        // Load dataset\n        const reader = vtkXMLImageDataReader.newInstance();\n\n\n        // set url and load the data\n        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {\n            reader.loadData().then(() => {\n                //prepare dataset\n                const imageData = reader.getOutputData(0);\n                //console.log(imageData.toJSON())\n                //set active scalar\n\n                imageData.getPointData().setActiveScalars('v02');\n                imageData.setSpacing(0.02, 0.02, 0.02);\n                console.log(imageData.getPointData().getScalars().getName());\n\n\n                console.log(imageData.getBounds());  // [dimX, dimY, dimZ]\n                console.log(imageData.getDimensions());\n                console.log(imageData.getSpacing());\n                console.log(imageData.getPointData().getScalars().getRange());\n\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                //console.log(data.toJSON())\n                mapper.setMaximumSamplesPerRay(4000);  // or even higher, up to your hardware limits\n                mapper.setInputData(imageData);\n                mapper.setSampleDistance(0.01);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolume.newInstance();\n\n                const cfun = vtkColorTransferFunction.newInstance();\n                cfun.addRGBPoint(0.0, 0.0, 0.0, 1.0);   // Blue\n                cfun.addRGBPoint(0.5, 1.0, 1.0, 1.0);   // White (optional midpoint)\n                cfun.addRGBPoint(1.0, 1.0, 0.0, 0.0);   // Red\n                actor.getProperty().setRGBTransferFunction(0, cfun);\n\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.0);  // fully transparent\n                ofun.addPoint(0.1, 0.05);\n                ofun.addPoint(0.5, 0.2);\n                ofun.addPoint(1.0, 1.0);  // fully opaque\n\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 0.1);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z\n                camera.setViewUp(0, 1, 0);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Volume Rendering with vtk.js</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderWindowContainer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderWindowContainer\"></div>\n    <script>\n        // Load the vtk.js library and set up the visualization pipeline\n        const { vtkFullScreenRenderWindow, vtkHttpDataSetReader, vtkVolume, vtkVolumeMapper, vtkColorTransferFunction, vtkPiecewiseFunction, vtkRenderer } = vtk;\n\n        // Create a full-screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            rootContainer: document.getElementById('renderWindowContainer'),\n            background: [0, 0, 0],\n        });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Load the dataset from the specified URL\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {\n            // Create a volume mapper\n            const mapper = vtkVolumeMapper.newInstance();\n            mapper.setInputConnection(reader.getOutputPort());\n\n            // Create a volume and set the mapper\n            const volume = vtkVolume.newInstance();\n            volume.setMapper(mapper);\n\n            // Create a color transfer function for the scalar field \"v02\"\n            const colorTransferFunction = vtkColorTransferFunction.newInstance();\n            colorTransferFunction.addRGBPoint(0, 0, 0, 1); // Blue\n            colorTransferFunction.addRGBPoint(0.5, 1, 1, 1); // White\n            colorTransferFunction.addRGBPoint(1, 1, 0, 0); // Red\n\n            // Create a piecewise function for opacity (transparency)\n            const piecewiseFunction = vtkPiecewiseFunction.newInstance();\n            piecewiseFunction.addPoint(0, 0.0); // Fully transparent\n            piecewiseFunction.addPoint(0.5, 0.5); // Semi-transparent\n            piecewiseFunction.addPoint(1, 1.0); // Fully opaque\n\n            // Set the color and opacity functions to the volume property\n            const volumeProperty = volume.getProperty();\n            volumeProperty.setRGBTransferFunction(0, colorTransferFunction);\n            volumeProperty.setScalarOpacity(0, piecewiseFunction);\n            volumeProperty.setInterpolationTypeToLinear();\n            volumeProperty.setShade(true);\n            volumeProperty.setAmbient(0.2);\n            volumeProperty.setDiffuse(0.7);\n            volumeProperty.setSpecular(0.3);\n            volumeProperty.setSpecularPower(8.0);\n\n            // Add the volume to the renderer\n            renderer.addVolume(volume);\n\n            // Reset the camera and render the scene\n            renderer.resetCamera();\n            renderWindow.render();\n        });\n    </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1747902893",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly correct and readable, but there are some differences from the ground truth. The code uses a different reader (vtkHttpDataSetReader instead of vtkXMLImageDataReader) which may not be appropriate for .vti files. It also lacks some advanced volume rendering settings like sample distance, scattering blending, and LAO parameters present in the ground truth. Additionally, it doesn't include the detailed scalar opacity gradient controls and the dataset preparation steps like setting spacing and active scalars. However, the overall structure and key concepts are correctly implemented.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/deepwater.vti Render scalar field \"v02\" Color mapping of \"v02\" scalar field: Blue → White → Red gradient based on data values Transparency effects showing internal structures Lighting & Shading：Physically-based lighting",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Cutter Example</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <!-- <script src=\"https://unpkg.com/vtk.js\"></script> -->\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n\n        // Load dataset\n        const reader = vtkXMLImageDataReader.newInstance();\n\n\n        // set url and load the data\n        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {\n            reader.loadData().then(() => {\n                //prepare dataset\n                const imageData = reader.getOutputData(0);\n                //console.log(imageData.toJSON())\n                //set active scalar\n\n                imageData.getPointData().setActiveScalars('v02');\n                imageData.setSpacing(0.02, 0.02, 0.02);\n                console.log(imageData.getPointData().getScalars().getName());\n\n\n                console.log(imageData.getBounds());  // [dimX, dimY, dimZ]\n                console.log(imageData.getDimensions());\n                console.log(imageData.getSpacing());\n                console.log(imageData.getPointData().getScalars().getRange());\n\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                //console.log(data.toJSON())\n                mapper.setMaximumSamplesPerRay(4000);  // or even higher, up to your hardware limits\n                mapper.setInputData(imageData);\n                mapper.setSampleDistance(0.01);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolume.newInstance();\n\n                const cfun = vtkColorTransferFunction.newInstance();\n                cfun.addRGBPoint(0.0, 0.0, 0.0, 1.0);   // Blue\n                cfun.addRGBPoint(0.5, 1.0, 1.0, 1.0);   // White (optional midpoint)\n                cfun.addRGBPoint(1.0, 1.0, 0.0, 0.0);   // Red\n                actor.getProperty().setRGBTransferFunction(0, cfun);\n\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.0);  // fully transparent\n                ofun.addPoint(0.1, 0.05);\n                ofun.addPoint(0.5, 0.2);\n                ofun.addPoint(1.0, 1.0);  // fully opaque\n\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 0.1);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z\n                camera.setViewUp(0, 1, 0);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n\n    </script>\n</body>\n\n</html>",
        "generated_code": null,
        "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
        "final_prompt": null,
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "deepseek-v3",
        "evaluator": "qwen3-turbo",
        "score": null,
        "workflow": {
            "inquiryExpansion": true,
            "rag": true,
            "iterativeLoop": false
        },
        "eval_id": "1747906446",
        "eval_user": "test",
        "eval_time": "2025-05-22 17:34:06",
        "eval_status": "failed",
        "manual_evaluation": null,
        "evaluator_evaluation": null,
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/deepwater.vti Render scalar field \"v02\" Color mapping of \"v02\" scalar field: Blue → White → Red gradient based on data values Transparency effects showing internal structures Lighting & Shading：Physically-based lighting",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Cutter Example</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <!-- <script src=\"https://unpkg.com/vtk.js\"></script> -->\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n\n        // Load dataset\n        const reader = vtkXMLImageDataReader.newInstance();\n\n\n        // set url and load the data\n        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {\n            reader.loadData().then(() => {\n                //prepare dataset\n                const imageData = reader.getOutputData(0);\n                //console.log(imageData.toJSON())\n                //set active scalar\n\n                imageData.getPointData().setActiveScalars('v02');\n                imageData.setSpacing(0.02, 0.02, 0.02);\n                console.log(imageData.getPointData().getScalars().getName());\n\n\n                console.log(imageData.getBounds());  // [dimX, dimY, dimZ]\n                console.log(imageData.getDimensions());\n                console.log(imageData.getSpacing());\n                console.log(imageData.getPointData().getScalars().getRange());\n\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                //console.log(data.toJSON())\n                mapper.setMaximumSamplesPerRay(4000);  // or even higher, up to your hardware limits\n                mapper.setInputData(imageData);\n                mapper.setSampleDistance(0.01);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolume.newInstance();\n\n                const cfun = vtkColorTransferFunction.newInstance();\n                cfun.addRGBPoint(0.0, 0.0, 0.0, 1.0);   // Blue\n                cfun.addRGBPoint(0.5, 1.0, 1.0, 1.0);   // White (optional midpoint)\n                cfun.addRGBPoint(1.0, 1.0, 0.0, 0.0);   // Red\n                actor.getProperty().setRGBTransferFunction(0, cfun);\n\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.0);  // fully transparent\n                ofun.addPoint(0.1, 0.05);\n                ofun.addPoint(0.5, 0.2);\n                ofun.addPoint(1.0, 1.0);  // fully opaque\n\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 0.1);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z\n                camera.setViewUp(0, 1, 0);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n\n    </script>\n</body>\n\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>vtk.js Volume Rendering</title>\n  <!-- Include vtk.js from CDN -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n<body>\n  <!-- Container for the vtk.js render area -->\n  <div id=\"container\"></div>\n\n  <script>\n    // Import required vtk.js modules\n    const { vtkFullScreenRenderWindow, vtkXMLImageDataReader, vtkColorTransferFunction, vtkVolumeMapper, vtkVolumeProperty, vtkVolume, vtkPiecewiseFunction } = window.vtk;\n\n    // Create a full-screen render window and renderer\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance();\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // Fetch and load the VTI file from the given URL\n    fetch('http://127.0.0.1:5000/dataset/deepwater.vti')\n      .then(res => res.arrayBuffer())\n      .then(data => {\n        // Parse the XML Image Data (VTI)\n        const reader = vtkXMLImageDataReader.newInstance();\n        reader.parseAsArrayBuffer(data);\n\n        const imageData = reader.getOutputData();\n\n        // Set up volume mapper\n        const mapper = vtkVolumeMapper.newInstance();\n        mapper.setInputData(imageData);\n        mapper.setSampleDistance(0.7); // Adjust for quality/performance\n\n        // Create color transfer function: Blue → White → Red gradient\n        const ctf = vtkColorTransferFunction.newInstance();\n        ctf.addRGBPoint(-1.0, 0.0, 0.0, 1.0); // Blue\n        ctf.addRGBPoint(0.0, 1.0, 1.0, 1.0);  // White\n        ctf.addRGBPoint(1.0, 1.0, 0.0, 0.0);  // Red\n\n        // Create opacity transfer function to enhance internal structure visibility\n        const ofun = vtkPiecewiseFunction.newInstance();\n        ofun.addPoint(0.0, 0.0);     // Transparent at low values\n        ofun.addPoint(0.5, 0.3);     // Semi-transparent in mid-values\n        ofun.addPoint(1.0, 0.8);     // Mostly opaque at high values\n\n        // Configure volume property with lighting & shading\n        const volumeProperty = vtkVolumeProperty.newInstance();\n        volumeProperty.setColor(ctf);\n        volumeProperty.setScalarOpacity(ofun);\n        volumeProperty.setInterpolationTypeToLinear(); // Smooth interpolation\n        volumeProperty.setShade(true);                 // Enable shading\n        volumeProperty.setUseSeparableApproximation(false); // Better quality\n        volumeProperty.setEnablePBR(true);             // Physically-Based Rendering (PBR)\n\n        // Create volume actor and set mapper + property\n        const volume = vtkVolume.newInstance();\n        volume.setMapper(mapper);\n        volume.addProperty(volumeProperty);\n\n        // Add volume to scene\n        renderer.addVolume(volume);\n\n        // Reset camera and render\n        renderer.resetCamera();\n        renderWindow.render();\n      })\n      .catch(err => {\n        console.error('Failed to load or parse VTI file:', err);\n      });\n\n    // Optional: Handle window resize\n    window.addEventListener('resize', () => fullScreenRenderer.resize());\n  </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-plus",
        "evaluator": "qwen3-turbo",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1747911745",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.7</Score>\n<Explanation>The generated code is readable and mostly correct, but there are some discrepancies compared to the ground truth. The structure is similar, and it correctly uses vtk.js for volume rendering. However, it lacks some specific configurations like setting the active scalar, adjusting sample distance, and detailed gradient opacity settings that were present in the ground truth. Additionally, the camera setup and some advanced properties (e.g., LAO settings) are missing, which could affect the visual output. Overall, it's a good implementation but not fully aligned with the original example.</Explanation>",
        "options": null
    },
    {
        "prompt": "Generate HTML with vtk.js to visualize airfoil cross-section  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp  Visualization: - Blue to red color mapping - Phong shading (Ambient 0.3, Diffuse 0.7, Specular 0.4) - XYZ axes widget - Line width: 2.0",
        "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Airfoil Cross-Section Visualization</title>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"renderer\"></div>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // 导入VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                const polyData = reader.getOutputData(0);\n                \n                // 获取数据范围和边界\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2\n                ];\n                \n                // 添加切割平面相关代码\n                const vtkPlane = vtk.Common.DataModel.vtkPlane;\n                const vtkCutter = vtk.Filters.Core.vtkCutter;\n                \n                // 创建切割平面\n                const plane = vtkPlane.newInstance();\n                plane.setOrigin(center[0], center[1], center[2]);\n                plane.setNormal(1, 0, 0); // 沿Z轴切割\n                \n                // 创建切割过滤器\n                const cutter = vtkCutter.newInstance();\n                cutter.setCutFunction(plane);\n                cutter.setInputData(polyData);\n                \n                // 修改映射器输入为切割过滤器输出\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputConnection(cutter.getOutputPort());\n                mapper.setScalarVisibility(true);\n                mapper.setColorByArrayName('p');\n                mapper.setScalarModeToUsePointData();\n                \n                // 创建颜色传输函数\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                const pRange = polyData.getPointData().getArrayByName('p').getRange();\n                colorTransferFunction.addRGBPoint(pRange[0], 0.0, 0.0, 0.5);\n                colorTransferFunction.addRGBPoint((pRange[0]+pRange[1])/2, 0.0, 0.5, 1.0);\n                colorTransferFunction.addRGBPoint(pRange[1], 1.0, 0.0, 0.0);\n                \n                mapper.setLookupTable(colorTransferFunction);\n                mapper.setScalarRange(pRange[0], pRange[1]);\n                \n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(false);\n                actor.getProperty().setLineWidth(2.0);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.4);\n                \n                renderer.addActor(actor);\n                \n                // 设置相机\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1] - 2, center[2] + 1);\n                camera.setViewUp(0, 0, 1);\n                \n                // 添加方向指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                \n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n    </script>\n</body>\n</html>",
        "generated_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Airfoil Cross-Section Visualization</title>\n\n  <!-- Include vtk.js library -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n\n  <!-- CSS for layout -->\n  <style>\n    body {\n      margin: 0;\n      overflow: hidden;\n    }\n    #container {\n      width: 100vw;\n      height: 100vh;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <script type=\"module\">\n    import vtkFullScreenRenderWindow from 'vtk.js/Sources/Rendering/Misc/FullScreenRenderWindow';\n    import vtkXMLPolyDataReader from 'vtk.js/Sources/IO/XML/XMLPolyDataReader';\n    import vtkMapper from 'vtk.js/Sources/Rendering/Core/Mapper';\n    import vtkActor from 'vtk.js/Sources/Rendering/Core/Actor';\n    import vtkColorTransferFunction from 'vtk.js/Sources/Rendering/Core/ColorTransferFunction';\n    import vtkProperty from 'vtk.js/Sources/Rendering/Core/Property';\n    import vtkAxesWidget from 'vtk.js/Sources/Interaction/Widgets/AxesWidget';\n\n    // Create a full-screen render window\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n      background: [0.2, 0.2, 0.2],\n    });\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // Load the VTP file using XMLPolyDataReader\n    const reader = vtkXMLPolyDataReader.newInstance();\n    reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp');\n\n    // Set up mapper and actor for visualization\n    const mapper = vtkMapper.newInstance();\n    const actor = vtkActor.newInstance();\n\n    // Set up color mapping (blue to red)\n    const ctf = vtkColorTransferFunction.newInstance();\n    ctf.addRGBPoint(0.0, 0.0, 0.0, 1.0); // Blue\n    ctf.addRGBPoint(1.0, 1.0, 0.0, 0.0); // Red\n\n    // Connect the pipeline: reader -> mapper -> actor -> renderer\n    reader.onOutputData(() => {\n      mapper.setInputData(reader.getOutputData());\n      actor.setMapper(mapper);\n\n      // Configure Phong shading with Ambient, Diffuse, Specular values\n      const property = actor.getProperty();\n      property.setAmbient(0.3);\n      property.setDiffuse(0.7);\n      property.setSpecular(0.4);\n      property.setEdgeVisibility(true); // Enable edge visibility\n      property.setLineWidth(2.0); // Set line width to 2.0\n\n      // Apply color transfer function to the mapper\n      mapper.setColorByArrayName(\"YourScalarArrayName\"); // Replace with actual scalar array name in dataset\n      mapper.setScalarModeToUsePointFieldData();\n      mapper.setLookupTable(ctf);\n\n      // Add actor to the renderer\n      renderer.addActor(actor);\n      renderer.resetCamera();\n      renderWindow.render();\n    });\n\n    // Add XYZ axes widget\n    const axesWidget = vtkAxesWidget.newInstance();\n    axesWidget.setInteractor(renderWindow.getInteractor());\n    axesWidget.setEnabled(1);\n\n    // Start interaction\n    fullScreenRenderer.getInteractor().start();\n  </script>\n</body>\n</html>",
        "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
        "generator": "qwen3-32b",
        "evaluator": "qwen3-32b",
        "score": "0.7",
        "workflow": {
            "inquiryExpansion": false,
            "rag": false,
            "iterativeLoop": false
        },
        "eval_id": "1747966995",
        "eval_user": "test",
        "manual_evaluation": null,
        "evaluator_evaluation": "<Score>0.7</Score>\n<Explanation>The generated code is readable and implements a basic visualization pipeline using vtk.js, but it lacks several key features from the ground truth that are essential for the correct functionality of the airfoil cross-section visualization. The most significant omissions include:\n\n1. **Cutting Plane Functionality**: The ground truth includes `vtkCutter` and `vtkPlane` to create a cross-sectional view, which is completely missing in the generated code.\n\n2. **Color Mapping Accuracy**: While the generated code defines a color transfer function, it uses hardcoded RGB points (`0.0, 0.0, 1.0` and `1.0, 0.0, 0.0`) without dynamically calculating the scalar range from the dataset. The ground truth correctly derives the scalar range from the data.\n\n3. **Camera Positioning**: The ground truth sets up the camera based on the geometry's bounds, while the generated code does not configure the camera explicitly, potentially leading to suboptimal or arbitrary camera placement.\n\n4. **Scalar Array Name**: The generated code uses a placeholder `\"YourScalarArrayName\"` instead of retrieving the actual scalar array name (e.g., `'p'`) from the dataset, which may cause runtime errors if not corrected.\n\n5. **Edge Visibility Setting**: The ground truth disables edge visibility (`setEdgeVisibility(false)`), whereas the generated code enables it, which might result in visual artifacts.\n\nThe code is well-structured and readable, but these functional differences reduce its correctness score.</Explanation>",
        "options": null
    }
]