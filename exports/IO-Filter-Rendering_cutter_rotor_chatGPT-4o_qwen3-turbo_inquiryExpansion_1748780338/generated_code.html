<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Rotor Pressure Slice</title>
    <style>
        html,
        body,
        #container {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <!-- 引入 vtk.js -->
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        // 引入 vtk.js 所需模块
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
        const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
        const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;
        const vtkAxesActor = vtk.Rendering.Core.vtkAxesActor;
        const vtkOrientationMarkerWidget = vtk.Rendering.Misc.vtkOrientationMarkerWidget;

        // 渲染窗口初始化
        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            rootContainer: document.getElementById('container'),
            background: [0.1, 0.1, 0.1], // 深色背景
        });
        const renderer = fullScreenRenderWindow.getRenderer();
        const renderWindow = fullScreenRenderWindow.getRenderWindow();

        // 创建数据读取器
        const reader = vtkXMLImageDataReader.newInstance();

        // 从本地服务器加载 .vti 文件
        fetch('http://127.0.0.1:5000/dataset/rotor_simplified.vti')
            .then(res => res.arrayBuffer())
            .then(data => {
                // 解析 VTI 数据
                reader.parseAsArrayBuffer(data);
                const imageData = reader.getOutputData();

                // 设置活动标量为 Pressure
                imageData.getPointData().setActiveScalars("Pressure");

                // 计算 Y 方向 80% 的切片位置
                const bounds = imageData.getBounds();     // [xmin, xmax, ymin, ymax, zmin, zmax]
                const yMin = bounds[2];
                const yMax = bounds[3];
                const sliceY = yMin + (yMax - yMin) * 0.8;

                // 创建切片 mapper
                const mapper = vtkImageMapper.newInstance();
                mapper.setInputData(imageData);
                mapper.setSlicingMode(1);  // Y轴方向切片（0: X, 1: Y, 2: Z）
                mapper.setSlice(sliceY);

                // 图像 slice actor
                const actor = vtkImageSlice.newInstance();
                actor.setMapper(mapper);

                // 获取 "Pressure" 的标量范围
                const pressureArray = imageData.getPointData().getScalars();
                const [min, max] = pressureArray.getRange();
                const mid = (min + max) / 2;

                // 创建颜色映射：Blue → White → Red
                const ctfun = vtkColorTransferFunction.newInstance();
                ctfun.addRGBPoint(min, 0.0, 0.0, 1.0);   // Blue
                ctfun.addRGBPoint(mid, 1.0, 1.0, 1.0);   // White
                ctfun.addRGBPoint(max, 1.0, 0.0, 0.0);   // Red

                // 设置不透明度映射（全不透明）
                const ofun = vtkPiecewiseFunction.newInstance();
                ofun.addPoint(min, 1.0);
                ofun.addPoint(max, 1.0);

                // 应用映射到 actor 渲染属性
                actor.getProperty().setRGBTransferFunction(0, ctfun);
                actor.getProperty().setPiecewiseFunction(0, ofun);
                actor.getProperty().setInterpolationTypeToLinear();

                // 添加 actor 到渲染器
                renderer.addActor(actor);

                // 添加空间方向参考（坐标轴）
                const axes = vtkAxesActor.newInstance();
                const orientationMarker = vtkOrientationMarkerWidget.newInstance({
                    actor: axes,
                    interactor: renderWindow.getInteractor()
                });
                orientationMarker.setEnabled(true);
                orientationMarker.setViewportCorner(
                    vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
                );
                orientationMarker.setViewportSize(0.15);
                orientationMarker.setMinPixelSize(100);
                orientationMarker.setMaxPixelSize(300);

                // 重置相机视角并渲染
                renderer.resetCamera();
                renderWindow.render();
            })
            .catch(console.error);
    </script>
</body>

</html>