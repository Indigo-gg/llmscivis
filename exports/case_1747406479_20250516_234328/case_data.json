{
  "evalId": "1747406479",
  "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
  "groundTruth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
  "generatedCode": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js Volume Rendering Example</title>\n</head>\n<body>\n    <!-- Container for rendering the volume -->\n    <div id=\"renderer\"></div>\n\n    <!-- Load vtk.js from CDN -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // Import necessary vtk.js modules for volume rendering\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkScalarBarActor = vtk.Rendering.Core.vtkScalarBarActor;\n\n        // Create a fullscreen render window instance\n        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1]  // Dark background for better contrast\n        });\n        const renderer = fullScreenRenderWindow.getRenderer();\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n        // Define the URL for loading the dataset\n        const dataPath = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        // Load the dataset asynchronously\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n                \n                // Create a color transfer function for rendering the scalar field \"p\"\n                const colorTransferFunction = vtkColorTransferFunction.newInstance();\n                colorTransferFunction.addRGBPoint(0, 0, 0, 1);  // Blue for low values\n                colorTransferFunction.addRGBPoint(255, 1, 0, 0); // Red for high values\n\n                // Create an opacity transfer function for the scalar field \"p\"\n                const opacityFunction = vtkPiecewiseFunction.newInstance();\n                opacityFunction.addPoint(0, 0.0);  // Transparency for low values\n                opacityFunction.addPoint(255, 1.0); // Full opacity for high values\n\n                // Create the volume mapper and associate the dataset with it\n                const volumeMapper = vtkVolumeMapper.newInstance();\n                volumeMapper.setInputData(data);\n\n                // Create the volume actor (used for volume rendering)\n                const volumeActor = vtkVolume.newInstance();\n                volumeActor.setMapper(volumeMapper);\n\n                // Apply the color and opacity functions to the volume actor's property\n                volumeActor.getProperty().setColor(colorTransferFunction);\n                volumeActor.getProperty().setScalarOpacity(opacityFunction);\n\n                // Add the volume actor to the renderer\n                renderer.addActor(volumeActor);\n\n                // Optional: Add a scalar bar to show the mapping between scalar values and colors\n                const scalarBar = vtkScalarBarActor.newInstance();\n                scalarBar.setOrientationToHorizontal();\n                scalarBar.setTitle(\"Scalar Field: p\");\n                scalarBar.setNumberOfLabels(5);\n                renderer.addActor(scalarBar);\n\n                // Adjust the camera to fit the view of the data\n                renderer.resetCamera();\n\n                // Render the scene\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error(\"Error loading the dataset:\", error);\n            });\n    </script>\n</body>\n</html>",
  "evaluatorEvaluation": "<Score>0.6</Score>\n<Explanation>The generated code is partially correct but has several issues that reduce its readability and accuracy. First, it uses a volume rendering approach instead of surface rendering, which is inconsistent with the ground truth's use of a surface mapper. Second, it references 'vtkHttpDataSetReader' which is not suitable for loading VTP files (it's meant for VTK XML file formats), while the ground truth uses 'vtkXMLPolyDataReader'. Third, the code lacks proper camera setup and does not replicate the same visual output as the ground truth. However, the structure and some elements like the render window setup are similar and readable.</Explanation>",
  "score": "0.6",
  "consoleOutput": [
    {
      "type": "error",
      "message": "Error loading the dataset: {\"xhr\":{},\"e\":{\"isTrusted\":true}}",
      "timestamp": "2025-05-16T15:29:39.184Z"
    }
  ],
  "exportTime": "2025-05-16T15:43:28.512Z"
}