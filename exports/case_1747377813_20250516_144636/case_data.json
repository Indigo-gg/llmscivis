{
  "evalId": "1747377813",
  "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
  "groundTruth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('..\\\\..\\\\..\\\\vtkjs-benchmark-datasets\\\\airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 输出数据信息以便调试\n                console.log('数据边界:', polyData.getBounds());\n                console.log('数据点数:', polyData.getNumberOfPoints());\n                console.log('数据单元数:', polyData.getNumberOfCells());\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n\n                // 选择U作为向量场用于LIC\n                if (scalarNames.includes('U')) {\n                    polyData.getPointData().setActiveVectors('U');\n                }\n\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建颜色映射表\n                const lookupTable = vtkLookupTable.newInstance();\n                lookupTable.setHueRange(0.667, 0.0);  // 从蓝色到红色\n                lookupTable.setSaturationRange(0.8, 0.8);\n                lookupTable.setValueRange(0.6, 1.0);\n                lookupTable.setNumberOfColors(256);\n                lookupTable.build();\n\n                // 设置映射器的颜色映射\n                mapper.setLookupTable(lookupTable);\n                mapper.setScalarRange(dataRange[0], dataRange[1]);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n\n                // 设置演员属性以模拟LIC效果\n                actor.getProperty().setRepresentationToSurface();\n                actor.getProperty().setEdgeVisibility(true);\n                actor.getProperty().setEdgeColor(0.0, 0.0, 0.0);\n                actor.getProperty().setLineWidth(0.5);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(0.7);\n                actor.getProperty().setSpecular(0.2);\n                actor.getProperty().setSpecularPower(10);\n\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
  "generatedCode": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Volume Rendering with vtk.js</title>\n</head>\n<body>\n    <!-- The div where the vtk.js renderer will be placed -->\n    <div id=\"renderer\"></div>\n    \n    <!-- Load vtk.js from CDN -->\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <script>\n        // Import necessary vtk.js classes\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n\n        // Initialize the full-screen render window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({ background: [0, 0, 0] });\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n\n        // Create a mapper and actor for volume rendering\n        const mapper = vtkMapper.newInstance();\n        const actor = vtkActor.newInstance();\n\n        // Set the data path and initialize the reader\n        const dataPath = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n\n        // Load the dataset and render the scalar field \"p\"\n        reader.setUrl(dataPath, { loadData: true })\n            .then(() => {\n                const data = reader.getOutputData(0);\n\n                // Set the scalar field to \"p\" for rendering\n                const pointData = data.getPointData();\n                const scalarArray = pointData.getArrayByName(\"p\");\n                if (scalarArray) {\n                    pointData.setScalars(scalarArray);\n                } else {\n                    console.error(\"Scalar field 'p' not found in the dataset.\");\n                    return;\n                }\n\n                // Configure the mapper with the dataset\n                mapper.setInputData(data);\n\n                // Add the actor to the renderer\n                actor.setMapper(mapper);\n                renderer.addActor(actor);\n\n                // Reset the camera and render the scene\n                renderer.resetCamera();\n                renderWindow.render();\n            })\n            .catch((error) => {\n                console.error(\"Error loading dataset:\", error);\n            });\n    </script>\n</body>\n</html>",
  "evaluatorEvaluation": "<Score>0.6</Score>\n<Explanation>The generated code is partially correct but lacks several key elements from the ground truth. It uses a different reader (vtkHttpDataSetReader instead of vtkXMLPolyDataReader) and does not handle vector fields or color mapping as in the original. The code also omits important visualization features like surface rendering, lighting settings, and the orientation widget. While it renders a basic scalar field, it doesn't replicate the full functionality or visual quality of the ground truth code.</Explanation>",
  "score": "0.6",
  "consoleOutput": [
    {
      "type": "error",
      "message": "Error loading dataset: {\"xhr\":{},\"e\":{\"isTrusted\":true}}",
      "timestamp": "2025-05-16T06:44:32.502Z"
    }
  ],
  "exportTime": "2025-05-16T06:46:36.220Z"
}