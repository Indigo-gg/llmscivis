<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Airfoil Visualization</title>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #container {
      width: 100%;
      height: 100%;
      position: relative;
    }
  </style>
</head>

<body>
  <div id="container"></div>

  <script src="https://unpkg.com/vtk.js"></script>
  <script>
    // Import required vtk.js modules
    const { vtkFullScreenRenderWindow } = vtk.Rendering.Misc;
    const { vtkActor } = vtk.Rendering.Core;
    const { vtkMapper } = vtk.Rendering.Core;
    const { vtkXMLPolyDataReader } = vtk.IO.XML;
    const { vtkColorTransferFunction } = vtk.Rendering.Core;
    const { vtkPiecewiseFunction } = vtk.Common.DataModel;

    // Create full screen render window
    const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById('container'),
      background: [0.1, 0.1, 0.1]
    });
    const renderWindow = fullScreenRenderWindow.getRenderWindow();
    const renderer = fullScreenRenderWindow.getRenderer();

    // Create reader to load the data
    const reader = vtkXMLPolyDataReader.newInstance();

    // Create mapper and actor for visualization
    // Note: For polydata (.vtp files), we use standard mapper/actor
    // rather than volume mapper/actor which are for volumetric data
    const mapper = vtkMapper.newInstance();
    const actor = vtkActor.newInstance();

    // Set up the visualization pipeline
    actor.setMapper(mapper);
    renderer.addActor(actor);

    // Load the data from the specified URL
    fetch('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(arrayBuffer => {
        // Parse the VTP data
        reader.parseAsArrayBuffer(arrayBuffer);

        // Connect the reader to the mapper
        mapper.setInputConnection(reader.getOutputPort());

        // Get the polydata
        const polyData = reader.getOutputData();

        // Activate the 'p' scalar array for color encoding
        if (polyData.getPointData().hasArray('p')) {
          // Set 'p' as the active scalar for coloring
          polyData.getPointData().setActiveScalars('p');

          // Get the range of the 'p' scalar for proper color mapping
          const pArray = polyData.getPointData().getArray('p');
          const range = pArray.getRange();

          // Set scalar range for the mapper
          mapper.setScalarRange(range);

          // Create a color transfer function for better visualization
          const ctfun = vtkColorTransferFunction.newInstance();
          // Blue to white to red color scheme
          ctfun.addRGBPoint(range[0], 0.0, 0.0, 1.0);      // Blue for minimum
          ctfun.addRGBPoint((range[0] + range[1]) / 2, 1.0, 1.0, 1.0);  // White for middle
          ctfun.addRGBPoint(range[1], 1.0, 0.0, 0.0);      // Red for maximum

          // Apply the color transfer function
          mapper.setLookupTable(ctfun);

          console.log('Successfully activated "p" scalar array with range:', range);
        } else {
          console.warn('The dataset does not contain a scalar array named "p"');
          // Try to find available arrays
          const pointData = polyData.getPointData();
          const numArrays = pointData.getNumberOfArrays();
          console.log('Available arrays:');
          for (let i = 0; i < numArrays; i++) {
            console.log(`- ${pointData.getArrayName(i)}`);
          }
        }

        // Enhance visual appearance
        actor.getProperty().setRepresentation(2); // 0: points, 1: wireframe, 2: surface
        actor.getProperty().setInterpolation(1);  // 0: flat, 1: gouraud, 2: phong
        actor.getProperty().setSpecular(0.3);
        actor.getProperty().setSpecularPower(20);

        // Position the camera to focus on the dataset bounds
        renderer.resetCamera();

        // Adjust camera for better view
        const camera = renderer.getActiveCamera();
        camera.elevation(-30);
        camera.azimuth(30);
        renderer.resetCameraClippingRange();

        // Render the scene
        renderWindow.render();
      })
      .catch(error => {
        console.error('Error loading or processing the data:', error);
      });
  </script>
</body>

</html>