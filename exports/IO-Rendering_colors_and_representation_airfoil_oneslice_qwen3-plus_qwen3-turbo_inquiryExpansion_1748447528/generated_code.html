<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>VTK.js Volume Rendering Example</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #renderer {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>

<body>
  <!-- 容器用于渲染 -->
  <div id="renderer"></div>

  <!-- 引入 vtk.js 库 -->
  <script src="https://unpkg.com/vtk.js"></script>

  <script>
    // 用户需求：使用 VTK.js 实现体积渲染（Volume Rendering）
    // 数据来源为远程 URL，标量字段为 "p"，并需要设置相机视角聚焦在数据集范围内

    // 从 vtk 命名空间导入所需的类
    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
    const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;
    const vtkMapper = vtk.Rendering.Core.vtkMapper;
    const vtkActor = vtk.Rendering.Core.vtkActor;
    const vtkRenderer = vtk.Rendering.Core.vtkRenderer;
    const vtkInteractorStyleTrackballCamera = vtk.Interaction.Style.vtkInteractorStyleTrackballCamera;

    // 初始化全屏渲染窗口和交互器
    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
      background: [0, 0, 0], // 黑色背景
      rootContainer: document.body,
      rendererSelector: '#renderer'
    });

    const renderWindow = fullScreenRenderer.getRenderWindow();
    const renderer = fullScreenRenderer.getRenderer();

    // 创建交互器并绑定 Trackball 相机控制
    const interactor = renderWindow.getInteractor();
    const style = vtkInteractorStyleTrackballCamera.newInstance();
    interactor.setInteractorStyle(style);

    // 设置数据源：加载远程的 .vtp 文件（VTK XML PolyData 格式）
    const reader = vtkXMLPolyDataReader.newInstance();
    const url = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';

    // 使用 fetch 加载远程文件
    fetch(url)
      .then(res => res.arrayBuffer())
      .then(data => {
        reader.parseAsArrayBuffer(data);

        // 获取解析后的 polydata 数据
        const polydata = reader.getOutputData(0);

        // 创建 Mapper 并激活标量数组 "p"
        const mapper = vtkMapper.newInstance();
        mapper.setInputData(polydata);
        mapper.setScalarModeToUsePointData(); // 使用点数据作为标量
        mapper.selectColorArray('p'); // 激活名为 "p" 的标量字段
        mapper.setScalarVisibility(true); // 启用颜色映射

        // 计算数据范围以自动调整相机视角
        const bounds = polydata.getBounds();
        const center = [
          (bounds[0] + bounds[1]) / 2,
          (bounds[2] + bounds[3]) / 2,
          (bounds[4] + bounds[5]) / 2
        ];

        // 设置相机位置，使其聚焦在整个数据集上
        const camera = renderer.getActiveCamera();
        const distance = Math.max(
          bounds[1] - bounds[0],
          bounds[3] - bounds[2],
          bounds[5] - bounds[4]
        ) * 1.5; // 放大一点确保全部可见

        camera.setPosition(center[0], center[1], center[2] + distance);
        camera.setFocalPoint(...center);
        camera.setViewUp(0, 1, 0);
        renderer.resetCamera();

        // 创建 Actor 并绑定 Mapper
        const actor = vtkActor.newInstance();
        actor.setMapper(mapper);

        // 将 Actor 添加到场景中
        renderer.addActor(actor);

        // 渲染画面
        renderWindow.render();
      })
      .catch(err => {
        console.error('无法加载或解析远程数据:', err);
      });
  </script>
</body>

</html>


---

### 💡 说明与用户需求对应关系：

| 用户需求 | 实现方式 |
|----------|----------|
| **加载远程 `.vtp` 数据** | 使用 `vtkXMLPolyDataReader` 解析远程 `.vtp` 文件内容 |
| **标量字段为 `p`** | 使用 `mapper.selectColorArray('p')` 来指定标量字段 |
| **颜色编码（Scalar Mapping）** | 启用 `mapper.setScalarVisibility(true)` 自动应用默认的颜色映射 |
| **设置相机视角聚焦数据集范围** | 根据数据的边界计算中心点，并将相机放置在 Z 轴方向一定距离外，确保整个模型可见 |

---

### 🧩 补充说明：
- 此代码假设远程 `.vtp` 文件已正确配置 CORS，允许跨域访问。
- 若需更复杂的颜色映射（如自定义 `ColorTransferFunction`），可以扩展此示例添加相关模块。
- 默认情况下，`vtkMapper` 使用内置的颜色表进行标量映射。如果需要自定义颜色映射，请进一步引入 `vtkColorTransferFunction` 和 `setLookupTable()`。

如有更多定制化需求（如光照、透明度、等值面等），可继续扩展该模板。