{
  "path": "IO-Rendering\\colors and representation\\airfoil_oneslice\\description.txt",
  "name": "description.txt",
  "prompt": "Generate HTML with vtk.js to visualize volume rendering\n\nLoad from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp\nScalar Mapping:\nActivates the p scalar array for color encoding\nVisualization:\nRenders the colors and representation\npositions the camera to focus on the dataset bounds",
  "ground_truth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
  "generated_code": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>VTK.js Volume Rendering Example</title>\n  <!-- 引入 VTK.js 的核心库 -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <style>\n    /* 设置渲染窗口为全屏显示 */\n    body, html {\n      margin: 0;\n      height: 100%;\n    }\n    #container {\n      width: 100%;\n      height: 100%;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <script>\n    // 使用vtk模块加载器来异步导入所需组件\n    const vtk = window.vtk;\n\n    (async () => {\n      // 1. 创建数据集读取器，用于从指定URL加载VTP文件\n      const reader = vtk.io.http.HttpDataSetReader.newInstance();\n      reader.setUrl(\"https://example.com/path/to/airfoil_oneslice.vtp\"); // 替换为实际的VTP文件地址\n\n      // 2. 等待数据加载完成\n      await reader.loadData();\n\n      // 3. 创建Mapper对象，将数据集映射为图形表示\n      const mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n      mapper.setInputConnection(reader.getOutputPort());\n\n      // 4. 创建Actor对象，用于定义如何在场景中渲染数据\n      const actor = vtk.Rendering.Core.vtkActor.newInstance();\n      actor.setMapper(mapper);\n\n      // 5. 创建颜色映射（Color Map）并将其应用于Mapper\n      // 这里使用简单的线性映射（可以根据需求自定义）\n      const colorTransferFunction = vtk.Common.DataModel.vtkColorTransferFunction.newInstance();\n      colorTransferFunction.addRGBPoint(0.0, 0.0, 0.0, 1.0);   // 黑色\n      colorTransferFunction.addRGBPoint(1.0, 1.0, 0.0, 0.0);   // 红色\n      mapper.setColorMap(colorTransferFunction);\n\n      // 6. 创建Renderer对象，用于管理渲染场景\n      const renderer = vtk.Rendering.Core.vtkRenderer.newInstance();\n\n      // 将Actor添加到渲染器中\n      renderer.addActor(actor);\n\n      // 设置背景颜色\n      renderer.setBackground(0.1, 0.2, 0.4);\n\n      // 7. 创建RenderWindow对象，并设置容器\n      const renderWindow = vtk.Rendering.Core.vtkRenderWindow.newInstance();\n      renderWindow.addRenderer(renderer);\n      const widget = document.getElementById('container');\n      renderWindow.setContainer(widget);\n\n      // 8. 初始化渲染并自动调整相机视角以聚焦于数据边界\n      renderWindow.render(); // 初次渲染\n\n      // 自动调整相机位置以聚焦于数据集边界\n      renderer.resetCamera();\n      renderWindow.render(); // 再次渲染以应用相机调整\n    })();\n  </script>\n</body>\n</html>\n```",
  "generator_prompt": "Please use vtkjs to generate visualization code. The code should be in the form of a complete code wrapped only in HTML tags. Please add your thinking process as comments in the code to make it easier to understand the code logic.\n\nIn the code, use `<script src=\"https://unpkg.com/vtk.js\"></script>` as the library for visualization to implement the visualization function.\nPlease follow the following rules:\n1. The content of the answer is HTML code with vtkjs script(start from <!DOCTYPE html>), and if there is any explanation, it should be given in the form of comments.\n2. If the sample code is relevant to the user's requirements, implement the user's requirements based on the sample code.\n3. The answer should be based on the provided sample information, and do not fabricate functions that do not exist. \nPlease implement the code strictly according to the specific requirements of the user in the `<QUESTION></QUESTION>` tag. Ensure that the code logic is clear and straightforward, and generate the visualization-related code completely in accordance with the syntax specifications of vtkjs. \n<QUESTION>__QUESTION__</QUESTION>\n\n",
  "final_prompt": "\n    用户需求分析：\n    1. 主要目标：三维体渲染可视化 - 使用VTK.js从指定URL加载数据集，并对体积数据进行颜色映射和渲染，设置相机位置以聚焦数据集边界\n    2. 数据来源：airfoil_oneslice.vtp (VTP文件)\n    3. 关键API：vtkHttpDataSetReader, vtkMapper, vtkActor, vtkRenderer, vtkRenderWindow\n    \n    ",
  "evaluator_prompt": "# Role: An expert for vtk.js and web-based scientific visualization\n# Ground truth: [GROUND_TRUTH]\n# Generated code: [GENERATED_CODE]\nThe ground truth code is provided by [Ground truth], please give a score for [Generated code] according to its readability and correctness. The score is between 0 to 1, and explain reasons for giving this score.\n### Response Format\n```\n<Score>[SCORE]</Score>\n<Explanation>[EXPLANATION]</Explanation>\n### Response Example\n<Score>0.8</Score>\n<Explanation>The generated code is readable and correct.</Explanation> ",
  "generator": "qwen3-32b",
  "evaluator": "qwen3-32b",
  "score": "0.7",
  "workflow": {
    "inquiryExpansion": true,
    "rag": false,
    "iterativeLoop": false
  },
  "eval_id": "1748100257",
  "eval_user": "test",
  "eval_time": "2025-05-24 23:24:17",
  "evaluator_evaluation": null,
  "options": null,
  "evaluatorEvaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly readable and structurally correct for a basic VTK.js visualization setup. It includes essential components like reader, mapper, actor, renderer, and render window with proper data flow. However, there are some issues: 1) The code uses the incorrect class vtk.Common.DataModel.vtkColorTransferFunction instead of the correct vtk.Rendering.Core.vtkColorTransferFunction; 2) It's missing the fullScreenRenderWindow functionality that provides better interactivity in the ground truth version; 3) It lacks the coordinate axis indicator (vtkAxesActor) which was present in the ground truth; 4) The camera positioning logic is simplified compared to the more detailed implementation in the ground truth. These omissions make it less complete as a scientific visualization example.</Explanation>"
}