{
  "evalId": "1747402288",
  "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
  "groundTruth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
  "generatedCode": " <!DOCTYPE html>\n<html lang=\\\"en\\\">\n<head>\n    <meta charset=\\\"UTF-8\\\">\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\n    <title>VTK.js Volume Rendering - Airfoil</title>\n    <style>\n        body, html {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n    <script src=\\\"https://unpkg.com/vtk.js\\\"></script>\n    <script>\n        // Define the VTK.js components we need\n        // For rendering setup\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        \n        // For data representation\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        \n        // For data loading\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;\n        \n        // For color mapping\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        \n        // Create the rendering window\n        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1] // Dark gray background for better visualization\n        });\n        \n        // Get the renderer and render window references\n        const renderer = fullScreenRenderer.getRenderer();\n        const renderWindow = fullScreenRenderer.getRenderWindow();\n        \n        // Create mapper and actor for visualization\n        const mapper = vtkMapper.newInstance();\n        const actor = vtkActor.newInstance();\n        \n        // Set up the actor with the mapper\n        actor.setMapper(mapper);\n        \n        // URL to the VTP file\n        const dataURL = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n        \n        // Create reader for VTP files\n        const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });\n        \n        // Load the data\n        reader.setUrl(dataURL)\n            .then(() => {\n                // Get the data from the reader\n                const polyData = reader.getOutputData();\n                \n                // Check if the data was loaded correctly\n                if (!polyData) {\n                    console.error('Failed to load polydata');\n                    return;\n                }\n                \n                // Check if the scalar field \\\"p\\\" exists\n                if (!polyData.getPointData().getArrayByName('p')) {\n                    console.error('Scalar field \\\"p\\\" not found in the dataset');\n                    return;\n                }\n                \n                // Activate the \\\"p\\\" scalar field for coloring\n                polyData.getPointData().setActiveScalars('p');\n                \n                // Set the polydata as input to the mapper\n                mapper.setInputData(polyData);\n                \n                // Set scalar visibility to true to use the \\\"p\\\" field for coloring\n                mapper.setScalarVisibility(true);\n                \n                // Set scalar mode to use point data (since \\\"p\\\" is point data)\n                mapper.setScalarModeToUsePointData();\n                \n                // Create a color lookup table for better visualization\n                const lookupTable = vtkColorTransferFunction.newInstance();\n                \n                // Get the range of the \\\"p\\\" values to create an appropriate color mapping\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                \n                // Set up a color map from blue to red for pressure values\n                lookupTable.addRGBPoint(dataRange[0], 0.0, 0.0, 1.0);  // Blue for low pressure\n                lookupTable.addRGBPoint((dataRange[0] + dataRange[1]) / 2, 0.0, 1.0, 0.0);  // Green for medium pressure\n                lookupTable.addRGBPoint(dataRange[1], 1.0, 0.0, 0.0);  // Red for high pressure\n                \n                // Set the lookup table to the mapper\n                mapper.setLookupTable(lookupTable);\n                \n                // Add the actor to the renderer\n                renderer.addActor(actor);\n                \n                // Reset the camera to ensure the data is visible\n                renderer.resetCamera();\n                \n                // Update the render window\n                renderWindow.render();\n                \n                console.log('Rendering complete. Data range for \\\"p\\\":', dataRange);\n            })\n            .catch((error) => {\n                console.error('Error loading the data:', error);\n                // Display error message on the screen\n                const errorDiv = document.createElement('div');\n                errorDiv.style.position = 'absolute';\n                errorDiv.style.top = '50%';\n                errorDiv.style.left = '50%';\n                errorDiv.style.transform = 'translate(-50%, -50%)';\n                errorDiv.style.color = 'white';\n                errorDiv.style.fontSize = '20px';\n                errorDiv.style.textAlign = 'center';\n                errorDiv.innerHTML = `Error loading data from ${dataURL}.<br>Please make sure the server is running and the file exists.`;\n                document.body.appendChild(errorDiv);\n            });\n            \n        // Add a window resize handler to maintain proper rendering when the browser window changes size\n        window.addEventListener('resize', () => {\n            fullScreenRenderer.resize();\n            renderWindow.render();\n        });\n    </script>\n</body>\n</html>",
  "evaluatorEvaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly correct and readable, but there are some discrepancies compared to the ground truth. It uses vtkHttpDataSetReader instead of vtkXMLPolyDataReader, which may not be appropriate for VTP files. The code also lacks some features like camera setup and axes visualization present in the ground truth. Additionally, the structure is slightly different, with some parts omitted or reorganized. However, the core functionality of loading and rendering the dataset is implemented correctly.</Explanation>",
  "score": "0.7",
  "consoleOutput": [
    {
      "type": "error",
      "message": "Error: Uncaught ReferenceError: vtk is not defined (at http://localhost:5174/:4:43)",
      "timestamp": "2025-05-16T14:12:41.389Z"
    }
  ],
  "exportTime": "2025-05-16T14:12:48.990Z"
}