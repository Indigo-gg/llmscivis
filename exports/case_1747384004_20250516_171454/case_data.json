{
  "evalId": "1747384004",
  "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp Render scalar field \"p\"  Use vtkFullScreenRenderWindow Load vtk.js from CDN",
  "groundTruth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Airfoil Rendering with Surface LIC</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        body,\n        html {\n            margin: 0;\n            padding: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n        }\n\n        #renderer {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <script>\n        // 导入所需的VTK.js类\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkLookupTable = vtk.Common.Core.vtkLookupTable;\n        // 移除不存在的SurfaceLICMapper引用\n        // const vtkSurfaceLICMapper = vtk.Rendering.Core.vtkSurfaceLICMapper;\n\n        // 初始化渲染窗口\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0.1, 0.1, 0.1],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n        // 创建PolyData读取器\n        const reader = vtkXMLPolyDataReader.newInstance();\n\n        // 设置URL并加载数据\n        reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {\n            reader.loadData().then(() => {\n                // 获取加载的多边形数据\n                const polyData = reader.getOutputData(0);\n\n                // 获取数据中的标量数组\n                const pointData = polyData.getPointData();\n                const arrays = pointData.getArrays();\n                const scalarNames = [];\n                arrays.forEach((array, name) => {\n                    scalarNames.push(name);\n                });\n                console.log('可用标量:', scalarNames);\n\n                // 选择p作为颜色标量\n                polyData.getPointData().setActiveScalars('p');\n                // 获取标量范围\n                const dataRange = polyData.getPointData().getScalars().getRange();\n                console.log('数据范围:', dataRange);\n\n                // 使用普通的Mapper代替SurfaceLICMapper\n                const mapper = vtkMapper.newInstance();\n                mapper.setInputData(polyData);\n\n                // 创建演员\n                const actor = vtkActor.newInstance();\n                actor.setMapper(mapper);\n                // 将演员添加到渲染器\n                renderer.addActor(actor);\n\n                // 计算数据边界和中心点\n                const bounds = polyData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2, // X中心\n                    (bounds[2] + bounds[3]) / 2, // Y中心\n                    (bounds[4] + bounds[5]) / 2, // Z中心\n                ];\n\n                // 配置相机视角 - 根据图片调整为合适的视角\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 5);\n                camera.setViewUp(0, 1, 0);\n\n                // 重置相机和裁剪范围\n                renderer.resetCamera();\n                renderer.resetCameraClippingRange();\n\n                // 渲染场景\n                renderWindow.render();\n\n                // 添加坐标轴指示器\n                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();\n                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({\n                    actor: axes,\n                    interactor: renderWindow.getInteractor(),\n                });\n                widget.setEnabled(true);\n                widget.setViewportCorner(\n                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT\n                );\n                widget.setViewportSize(0.15);\n                widget.setMinPixelSize(100);\n                widget.setMaxPixelSize(300);\n            });\n        }).catch(error => {\n            console.error('加载数据集时出错:', error);\n        });\n    </script>\n</body>\n\n</html>",
  "generatedCode": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>VTK.js Volume Rendering Example</title>\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n    }\n  </style>\n</head>\n<body>\n  <!-- Load vtk.js from CDN -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n  <script>\n    // Import necessary VTK.js modules\n    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;\n    const vtkMapper = vtk.Rendering.Core.vtkMapper;\n    const vtkActor = vtk.Rendering.Core.vtkActor;\n    const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n\n    // Create a full-screen render window with black background\n    const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n      background: [0, 0, 0],\n    });\n\n    // Get the renderer and render window for further configuration\n    const renderer = fullScreenRenderWindow.getRenderer();\n    const renderWindow = fullScreenRenderWindow.getRenderWindow();\n\n    // Define the remote dataset URL (as per user's requirement)\n    const dataUrl = 'http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp';\n\n    // Create a reader to load the .vtp file via HTTP\n    const reader = vtkXMLPolyDataReader.newInstance();\n    \n    // Fetch the remote dataset using fetch API and pass it to the reader\n    fetch(dataUrl)\n      .then(response => response.arrayBuffer())\n      .then(buffer => {\n        // Parse the XML PolyData (.vtp) content\n        reader.parseAsArrayBuffer(buffer);\n\n        // Get the output polydata from the reader\n        const polydata = reader.getOutputData(0);\n\n        // Create a mapper and set the input data\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polydata);\n\n        // Set scalar field to \"p\" as requested by the user\n        mapper.setScalarModeToUsePointFieldData();\n        mapper.selectColorArray('p'); // Use \"p\" as the scalar field for coloring\n        mapper.setInterpolateScalarsBeforeMapping(true);\n        mapper.update(); // Update mapper after setting scalar info\n\n        // Create an actor and assign the mapper\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n\n        // Add the actor to the scene\n        renderer.addActor(actor);\n\n        // Reset camera to fit the geometry\n        renderer.resetCamera();\n\n        // Trigger initial render\n        renderWindow.render();\n      })\n      .catch(error => {\n        console.error('Error loading or parsing the .vtp file:', error);\n      });\n\n    // Optional: Handle window resize to keep rendering responsive\n    window.addEventListener('resize', () => {\n      fullScreenRenderWindow.resize();\n    });\n  </script>\n</body>\n</html>",
  "evaluatorEvaluation": "<Score>0.7</Score>\n<Explanation>The generated code is mostly correct and readable, but it lacks some key features from the ground truth. It correctly loads a VTP file and renders it with vtk.js, and uses modern practices like fetch API for loading data. However, it doesn't include important elements like the <div id=\"renderer\"> container, which is necessary for the full-screen render window to work properly. It also misses the camera configuration, scalar range logging, and the orientation axes widget that were present in the ground truth. Additionally, it doesn't handle the case where the data might not have the 'p' array, which could lead to errors.</Explanation>",
  "score": "0.7",
  "consoleOutput": [
    {
      "type": "error",
      "message": "Error loading or parsing the .vtp file: {}",
      "timestamp": "2025-05-16T08:52:35.032Z"
    }
  ],
  "exportTime": "2025-05-16T09:14:53.603Z"
}