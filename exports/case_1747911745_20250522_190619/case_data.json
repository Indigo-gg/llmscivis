{
  "evalId": "1747911745",
  "prompt": "Generate HTML with vtk.js to visualize volume rendering  Load from http://127.0.0.1:5000/dataset/deepwater.vti Render scalar field \"v02\" Color mapping of \"v02\" scalar field: Blue → White → Red gradient based on data values Transparency effects showing internal structures Lighting & Shading：Physically-based lighting",
  "groundTruth": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VTK.js Cutter Example</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n    <!-- <script src=\"https://unpkg.com/vtk.js\"></script> -->\n    <script>\n        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n        const vtkVolume = vtk.Rendering.Core.vtkVolume;\n        const vtkVolumeMapper = vtk.Rendering.Core.vtkVolumeMapper;\n\n        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n        const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;\n        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;\n\n        //init the render window\n        const fullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({\n            background: [0, 0, 0],\n        });\n        const renderWindow = fullScreenRenderWindow.getRenderWindow();\n        const renderer = fullScreenRenderWindow.getRenderer();\n\n\n        // Load dataset\n        const reader = vtkXMLImageDataReader.newInstance();\n\n\n        // set url and load the data\n        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {\n            reader.loadData().then(() => {\n                //prepare dataset\n                const imageData = reader.getOutputData(0);\n                //console.log(imageData.toJSON())\n                //set active scalar\n\n                imageData.getPointData().setActiveScalars('v02');\n                imageData.setSpacing(0.02, 0.02, 0.02);\n                console.log(imageData.getPointData().getScalars().getName());\n\n\n                console.log(imageData.getBounds());  // [dimX, dimY, dimZ]\n                console.log(imageData.getDimensions());\n                console.log(imageData.getSpacing());\n                console.log(imageData.getPointData().getScalars().getRange());\n\n                //create the mapper and set its property\n                const mapper = vtkVolumeMapper.newInstance();\n                //console.log(data.toJSON())\n                mapper.setMaximumSamplesPerRay(4000);  // or even higher, up to your hardware limits\n                mapper.setInputData(imageData);\n                mapper.setSampleDistance(0.01);\n                mapper.setVolumetricScatteringBlending(0);\n                mapper.setLocalAmbientOcclusion(0);\n                mapper.setLAOKernelSize(10);\n                mapper.setLAOKernelRadius(5);\n                mapper.setComputeNormalFromOpacity(true);\n\n                //create actor and set its properties, including gradient opacity, scalar opacity, shade, ambient, diffuse, specular etc.\n                const actor = vtkVolume.newInstance();\n\n                const cfun = vtkColorTransferFunction.newInstance();\n                cfun.addRGBPoint(0.0, 0.0, 0.0, 1.0);   // Blue\n                cfun.addRGBPoint(0.5, 1.0, 1.0, 1.0);   // White (optional midpoint)\n                cfun.addRGBPoint(1.0, 1.0, 0.0, 0.0);   // Red\n                actor.getProperty().setRGBTransferFunction(0, cfun);\n\n                const ofun = vtkPiecewiseFunction.newInstance();\n                ofun.addPoint(0.0, 0.0);  // fully transparent\n                ofun.addPoint(0.1, 0.05);\n                ofun.addPoint(0.5, 0.2);\n                ofun.addPoint(1.0, 1.0);  // fully opaque\n\n                actor.getProperty().setScalarOpacity(0, ofun);\n                actor.getProperty().setInterpolationTypeToLinear();\n                actor.getProperty().setUseGradientOpacity(0, true);\n                actor.getProperty().setGradientOpacityMinimumValue(0, 2);\n                actor.getProperty().setGradientOpacityMinimumOpacity(0, 0.0);\n                actor.getProperty().setGradientOpacityMaximumValue(0, 20);\n                actor.getProperty().setGradientOpacityMaximumOpacity(0, 1.0);\n                actor.getProperty().setScalarOpacityUnitDistance(0, 0.1);\n                actor.getProperty().setShade(true);\n                actor.getProperty().setAmbient(0.3);\n                actor.getProperty().setDiffuse(1);\n                actor.getProperty().setSpecular(1);\n\n                //assign mapper to actor and assign mapper to render\n                actor.setMapper(mapper);\n                renderer.addVolume(actor);\n\n                const bounds = imageData.getBounds();\n                const center = [\n                    (bounds[0] + bounds[1]) / 2,\n                    (bounds[2] + bounds[3]) / 2,\n                    (bounds[4] + bounds[5]) / 2,\n                ];\n\n                const camera = renderer.getActiveCamera();\n                camera.setFocalPoint(...center);\n                camera.setPosition(center[0], center[1], center[2] + 10); // Look along +Z\n                camera.setViewUp(0, 1, 0);\n                renderer.resetCameraClippingRange();\n                renderWindow.render();\n                renderer.resetCamera();\n                renderWindow.render();\n            });\n        });\n\n    </script>\n</body>\n\n</html>",
  "generatedCode": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>vtk.js Volume Rendering</title>\n  <!-- Include vtk.js from CDN -->\n  <script src=\"https://unpkg.com/vtk.js\"></script>\n</head>\n<body>\n  <!-- Container for the vtk.js render area -->\n  <div id=\"container\"></div>\n\n  <script>\n    // Import required vtk.js modules\n    const { vtkFullScreenRenderWindow, vtkXMLImageDataReader, vtkColorTransferFunction, vtkVolumeMapper, vtkVolumeProperty, vtkVolume, vtkPiecewiseFunction } = window.vtk;\n\n    // Create a full-screen render window and renderer\n    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance();\n    const renderer = fullScreenRenderer.getRenderer();\n    const renderWindow = fullScreenRenderer.getRenderWindow();\n\n    // Fetch and load the VTI file from the given URL\n    fetch('http://127.0.0.1:5000/dataset/deepwater.vti')\n      .then(res => res.arrayBuffer())\n      .then(data => {\n        // Parse the XML Image Data (VTI)\n        const reader = vtkXMLImageDataReader.newInstance();\n        reader.parseAsArrayBuffer(data);\n\n        const imageData = reader.getOutputData();\n\n        // Set up volume mapper\n        const mapper = vtkVolumeMapper.newInstance();\n        mapper.setInputData(imageData);\n        mapper.setSampleDistance(0.7); // Adjust for quality/performance\n\n        // Create color transfer function: Blue → White → Red gradient\n        const ctf = vtkColorTransferFunction.newInstance();\n        ctf.addRGBPoint(-1.0, 0.0, 0.0, 1.0); // Blue\n        ctf.addRGBPoint(0.0, 1.0, 1.0, 1.0);  // White\n        ctf.addRGBPoint(1.0, 1.0, 0.0, 0.0);  // Red\n\n        // Create opacity transfer function to enhance internal structure visibility\n        const ofun = vtkPiecewiseFunction.newInstance();\n        ofun.addPoint(0.0, 0.0);     // Transparent at low values\n        ofun.addPoint(0.5, 0.3);     // Semi-transparent in mid-values\n        ofun.addPoint(1.0, 0.8);     // Mostly opaque at high values\n\n        // Configure volume property with lighting & shading\n        const volumeProperty = vtkVolumeProperty.newInstance();\n        volumeProperty.setColor(ctf);\n        volumeProperty.setScalarOpacity(ofun);\n        volumeProperty.setInterpolationTypeToLinear(); // Smooth interpolation\n        volumeProperty.setShade(true);                 // Enable shading\n        volumeProperty.setUseSeparableApproximation(false); // Better quality\n        volumeProperty.setEnablePBR(true);             // Physically-Based Rendering (PBR)\n\n        // Create volume actor and set mapper + property\n        const volume = vtkVolume.newInstance();\n        volume.setMapper(mapper);\n        volume.addProperty(volumeProperty);\n\n        // Add volume to scene\n        renderer.addVolume(volume);\n\n        // Reset camera and render\n        renderer.resetCamera();\n        renderWindow.render();\n      })\n      .catch(err => {\n        console.error('Failed to load or parse VTI file:', err);\n      });\n\n    // Optional: Handle window resize\n    window.addEventListener('resize', () => fullScreenRenderer.resize());\n  </script>\n</body>\n</html>",
  "evaluatorEvaluation": "<Score>0.7</Score>\n<Explanation>The generated code is readable and mostly correct, but there are some discrepancies compared to the ground truth. The structure is similar, and it correctly uses vtk.js for volume rendering. However, it lacks some specific configurations like setting the active scalar, adjusting sample distance, and detailed gradient opacity settings that were present in the ground truth. Additionally, the camera setup and some advanced properties (e.g., LAO settings) are missing, which could affect the visual output. Overall, it's a good implementation but not fully aligned with the original example.</Explanation>",
  "score": "0.7",
  "consoleOutput": [
    {
      "type": "error",
      "message": "Error: Uncaught TypeError: Cannot read properties of undefined (reading 'newInstance') (at http://localhost:5174/:6:58)",
      "timestamp": "2025-05-22T11:06:17.520Z"
    }
  ],
  "exportTime": "2025-05-22T11:06:19.840Z"
}