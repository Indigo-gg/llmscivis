<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>VTK.js Rotor Data Visualization</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #vtk-container {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <!-- 容器用于放置VTK渲染窗口 -->
  <div id="vtk-container"></div>

  <!-- 引入 VTK.js 库 -->
  <script src="https://unpkg.com/vtk.js"></script>

  <script>
    // 用户需求分析：
    // 1. 加载VTI文件（来自指定URL）
    // 2. 使用Y轴切片（setSlicingMode, setSlice）
    // 3. 显示Pressure标量场，使用颜色映射和不透明度控制
    // 4. 添加XYZ方向的朝向标记

    // 导入所需的VTK模块
    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
    // const vtkHttpDataSetReader = vtk.IO.Core.vtkHttpDataSetReader;
    const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
    const vtkImageMapper = vtk.Rendering.Core.vtkImageMapper;
    const vtkImageSlice = vtk.Rendering.Core.vtkImageSlice;
    const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
    const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;
    const vtkOrientationMarkerWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget;
    const vtkAnnotatedCubeActor = vtk.Rendering.Core.vtkAnnotatedCubeActor;

    // 初始化全屏渲染窗口
    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
      background: [0.1, 0.1, 0.1],
    });

    const renderer = fullScreenRenderer.getRenderer();
    const renderWindow = fullScreenRenderer.getRenderWindow();

    // 创建图像切片对象
    const imageSlice = vtkImageSlice.newInstance();
    const mapper = vtkImageMapper.newInstance();

    // 设置数据读取器（加载远程VTI文件）
    const reader = vtkXMLImageDataReader.newInstance();
    // const reader = vtkHttpDataSetReader.newInstance({ fetchGzip: true });
    reader.setUrl('./datasets/rotor_simplified.vti').then(() => {
      reader.loadData().then(() => {

      const imageData = reader.getOutputData(0);
      imageData.getPointData().setActiveScalars('Pressure');


      // 设置mapper的数据源为读取的图像数据
      mapper.setInputData(imageData);
      mapper.setSlicingMode(1); // Y轴切片
      mapper.setSlice(Math.floor(imageData.getDimensions()[1] * 0.8)); // 80% 深度

      // 设置图像切片的映射器
      imageSlice.setMapper(mapper);

      // 创建颜色映射函数：蓝 -> 白 -> 红
      const pressureArray = imageData.getPointData().getArrayByName('Pressure');
      const [pMin, pMax] = pressureArray.getRange();
      const colorMap = vtkColorTransferFunction.newInstance();
      colorMap.addRGBPoint(pMin, 0.0, 0.0, 0.8); // 蓝色
      colorMap.addRGBPoint((pMin + pMax) / 2, 1.0, 1.0, 1.0);     // 白色
      colorMap.addRGBPoint(pMax, 0.8, 0.0, 0.0);  // 红色

      // 设置不透明度为完全不透明
      const opacityFunction = vtkPiecewiseFunction.newInstance();
      opacityFunction.addPoint(0, 1.0);
      opacityFunction.addPoint(1000, 1.0);

      // 将颜色和不透明度应用到图像属性
      const prop = imageSlice.getProperty();
      prop.setRGBTransferFunction(0, colorMap);
      prop.setScalarOpacity(0, opacityFunction);
      // prop.setColor(colorMap);
      // prop.setOpacity(opacityFunction);
      prop.setUseLookupTableScalarRange(true);

      // 将图像添加到渲染器中
      renderer.addActor(imageSlice);

      // 添加朝向标记（XYZ坐标轴）
      // const axes = vtkAxesActor.newInstance();

      // const cubeActor = vtkAnnotatedCubeActor.newInstance();
      // cubeActor.setDefaultStyle({
      //   fontSize: 18,
      //   faceRotation: 0,
      //   xFaceText: 'X',
      //   yFaceText: 'Y',
      //   zFaceText: 'Z',
      //   xyFaceColor: [255, 0, 0],
      //   yzFaceColor: [0, 255, 0],
      //   zxFaceColor: [0, 0, 255],
      // });
      // const interactor = renderWindow.getInteractor();
      // const orientationWidget = vtkOrientationMarkerWidget.newInstance({
      //   actor: cubeActor,
      //   interactor:null,
      // });
      // const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();
      // const orientationWidget = vtkOrientationMarkerWidget.newInstance({
      //   actor: axes,
      //   interactor: renderWindow.getInteractor(),
      // });



      // orientationWidget.setInteractor(renderWindow.getInteractor());

      // orientationWidget.setViewportCorner(0, 0, 0.2, 0.2); // 左下角显示


      // 初始渲染
      renderer.resetCamera();
      renderWindow.render();
          });
      });

    // 监听窗口大小变化以更新渲染器尺寸
    // window.addEventListener('resize', () => {
    //   fullScreenRenderer.setSize(window.innerWidth, window.innerHeight);
    // });

  </script>
</body>

</html>