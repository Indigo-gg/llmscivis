<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VTK.js Volume Rendering Example</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    #rendererContainer {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <!-- Container for rendering -->
  <div id="rendererContainer"></div>

  <!-- Load vtk.js from CDN -->
  <script src="https://unpkg.com/vtk.js"></script>

  <script>
    // Import necessary VTK.js modules
    const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
    const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;
    const vtkMapper = vtk.Rendering.Core.vtkMapper;
    const vtkVolume = vtk.Rendering.Core.vtkVolume;
    const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
    const vtkPiecewiseFunction = vtk.Common.DataModel.vtkPiecewiseFunction;
    const vtkInteractorStyleTrackballCamera = vtk.Interaction.Style.vtkInteractorStyleTrackballCamera;

    // Create a full screen render window
    const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
      background: [0.2, 0.3, 0.4],  // Background color
      rootContainer: document.body,
      containerStyle: { height: '100vh' },
      createOwnInteractor: true,
    });

    const renderer = fullScreenRenderer.getRenderer();
    const renderWindow = fullScreenRenderer.getRenderWindow();

    // Initialize interactor with Trackball Camera style
    const interactor = renderWindow.getInteractor();
    const style = vtkInteractorStyleTrackballCamera.newInstance();
    interactor.setInteractorStyle(style);

    // Step 1: Load the remote .vtp file using vtkXMLPolyDataReader
    const reader = vtkXMLPolyDataReader.newInstance();
    reader.setUrl('http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp').then(() => {
      reader.loadData().then(() => {
        const polyData = reader.getOutputData(0);  // Get output as PolyData

        // Step 2: Set up scalar mapping using "p" array
        const pointData = polyData.getPointData();
        const pArray = pointData.getArrayByName('p');

        if (!pArray) {
          console.error("Scalar array 'p' not found in the dataset.");
          return;
        }

        // Set active scalar to 'p'
        pointData.setActiveScalars('p');
        polyData.setPointData(pointData);

        // Step 3: Create mapper and volume (vtkVolume used for volume rendering)
        const mapper = vtkMapper.newInstance();
        mapper.setInputData(polyData);
        mapper.setScalarModeToUsePointData();  // Use point data for coloring
        mapper.setColorByArrayName('p');       // Color by 'p' scalar array
        mapper.setScalarVisibility(true);      // Enable scalar-based coloring

        // Step 4: Create color transfer function for scalar mapping
        const ctf = vtkColorTransferFunction.newInstance();
        const range = pArray.getRange();       // Get min and max of scalar values
        ctf.addRGBPoint(range[0], 0, 0, 1);    // Blue at minimum
        ctf.addRGBPoint(range[1], 1, 0, 0);    // Red at maximum

        // Step 5: Create opacity transfer function
        const ofun = vtkPiecewiseFunction.newInstance();
        ofun.addPoint(range[0], 0.0);         // Fully transparent at min
        ofun.addPoint(range[1], 1.0);         // Opaque at max

        // Step 6: Apply color and opacity functions to mapper
        mapper.setLookupTable(ctf);
        mapper.setUseLookupTableScalarRange(true);

        // Step 7: Create volume actor (used for volume rendering even though input is PolyData)
        const volume = vtkVolume.newInstance();
        volume.setMapper(mapper);
        volume.getProperty().setOpacity(ofun);
        volume.getProperty().setColor(ctf);

        // Step 8: Add volume to renderer
        renderer.addVolume(volume);

        // Step 9: Position camera to focus on the dataset bounds
        renderer.resetCamera();

        // Step 10: Trigger initial render
        renderWindow.render();
      });
    });
  </script>
</body>
</html>


---

### üß† **Explanation & Comments**

#### ‚úÖ **User Requirement Mapping**
- **Volume Rendering**  
  Even though the input is `PolyData`, we use `vtkVolume` and `vtkMapper` to simulate volume rendering effects based on scalar values.

- **Remote Data Loading**  
  The code uses `vtkXMLPolyDataReader` to load `.vtp` files from the URL `http://127.0.0.1:5000/dataset/airfoil_oneslice.vtp`.

- **Scalar Mapping with `p` Array**  
  We check for the presence of the scalar array named `"p"` and activate it for coloring via `mapper.setColorByArrayName('p')`. A `vtkColorTransferFunction` maps scalar values to RGB colors.

- **Opacity Function**  
  A `vtkPiecewiseFunction` controls how scalar values are mapped to opacity (transparency).

- **Camera Setup**  
  After loading the data, `renderer.resetCamera()` ensures that the camera focuses on the entire bounds of the dataset.

- **Interaction Style**  
  The `vtkInteractorStyleTrackballCamera` allows intuitive mouse interaction to rotate, zoom, and pan the view.

---

### ‚ö†Ô∏è Notes:
- This implementation assumes the server at `http://127.0.0.1:5000` serves the `.vtp` file with proper CORS headers.
- If the dataset contains only surface geometry (`PolyData`), true volume rendering might not be applicable. However, this approach visualizes the scalar field across the surface with volumetric-like shading.

Let me know if you need support for actual `ImageData` for real volume rendering (e.g., `.vti` files).