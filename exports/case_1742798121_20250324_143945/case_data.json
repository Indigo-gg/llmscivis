{
  "evalId": "1742798121",
  "prompt": "create an interactive webpage for exploring various 3D geometric shapes with customizable properties and responsive design using vtk.js library",
  "groundTruth": "\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>vtk.js Many Renderers</title>\n</head>\n\n<body>\n    <div id=\"renderer\"></div>\n\n    <script type=\"text/javascript\" src=\"https://unpkg.com/@babel/polyfill@7.0.0/dist/polyfill.js\"></script>\n\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n\n    <script>\n        // 假设vtk.js已经通过某种方式被加载到全局变量vtk中\n        // 例如，通过<script>标签在HTML中引入vtk.js，或者通过模块加载器\n\n        // 使用vtk命名空间来引用各个类\n        const vtkActor = vtk.Rendering.Core.vtkActor;\n        const vtkConeSource = vtk.Filters.Sources.vtkConeSource;\n        const vtkSphereSource = vtk.Filters.Sources.vtkSphereSource;\n        const vtkCubeSource = vtk.Filters.Sources.vtkCubeSource;\n        const vtkCylinderSource = vtk.Filters.Sources.vtkCylinderSource;\n        const vtkMapper = vtk.Rendering.Core.vtkMapper;\n        const vtkRenderWindow = vtk.Rendering.Core.vtkRenderWindow;\n        const vtkRenderWindowInteractor = vtk.Rendering.Core.vtkRenderWindowInteractor;\n        const vtkRenderer = vtk.Rendering.Core.vtkRenderer;\n        const vtkInteractorStyleTrackballCamera = vtk.Interaction.Style.vtkInteractorStyleTrackballCamera;\n\n        // ----------------------------------------------------------------------------\n        // Meshes\n\n        //  ------------------------------------------------------------\n        // Meshes\n        // ----------------------------------------------------------------------------\n\n        const meshes = [];\n\n        function addMesh(name, source) {\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputData(source.getOutputData());\n            meshes.push({ name, mapper });\n        }\n\n        addMesh('Cone', vtkConeSource.newInstance());\n        addMesh('Sphere', vtkSphereSource.newInstance());\n        addMesh('Cube', vtkCubeSource.newInstance());\n        addMesh('Cylinder', vtkCylinderSource.newInstance());\n\n        // ----------------------------------------------------------------------------\n        // Properties\n        // ----------------------------------------------------------------------------\n\n        const properties = [\n            {\n                name: '- Red',\n                properties: { color: [1, 0.6, 0.6] },\n            },\n            {\n                name: 'Edge - Red',\n                properties: { edgeVisibility: true, color: [1, 0.6, 0.6] },\n            },\n            {\n                name: '- Blue',\n                properties: { color: [0.6, 0.6, 1] },\n            },\n            {\n                name: 'Edge - Green',\n                properties: { edgeVisibility: true, color: [0.6, 1, 0.6] },\n            },\n            {\n                name: '- Green',\n                properties: { color: [0.6, 1, 0.6] },\n            },\n            {\n                name: 'Edge - Blue',\n                properties: { edgeVisibility: true, color: [0.6, 0.6, 1] },\n            },\n        ];\n\n        // ----------------------------------------------------------------------------\n        // Background colors\n        // ----------------------------------------------------------------------------\n\n        const colors = [\n            [0.2, 0.2, 0.2],\n            [0.4, 0.2, 0.3],\n            [0.2, 0.4, 0.3],\n            [0.6, 0.6, 0.6],\n            [0.2, 0.4, 0.4],\n            [0.3, 0.4, 0.2],\n            [0.3, 0.2, 0.4],\n        ];\n\n        // ----------------------------------------------------------------------------\n        // Single RenderWindow in fullscreen\n        // ----------------------------------------------------------------------------\n\n        const RENDERERS = {};\n\n        const renderWindow = vtkRenderWindow.newInstance();\n        const renderWindowView = renderWindow.newAPISpecificView();\n        renderWindow.addView(renderWindowView);\n\n        const rootContainer = document.createElement('div');\n        rootContainer.style.position = 'fixed';\n        rootContainer.style.zIndex = -1;\n        rootContainer.style.left = 0;\n        rootContainer.style.top = 0;\n        rootContainer.style.pointerEvents = 'none';\n        document.body.appendChild(rootContainer);\n\n        renderWindowView.setContainer(rootContainer);\n\n        const interactor = vtkRenderWindowInteractor.newInstance();\n        interactor.setView(renderWindowView);\n        interactor.initialize();\n        interactor.setInteractorStyle(vtkInteractorStyleTrackballCamera.newInstance());\n\n        function updateViewPort(element, renderer) {\n            const { innerHeight, innerWidth } = window;\n            const { x, y, width, height } = element.getBoundingClientRect();\n            const viewport = [\n                x / innerWidth,\n                1 - (y + height) / innerHeight,\n                (x + width) / innerWidth,\n                1 - y / innerHeight,\n            ];\n            renderer.setViewport(...viewport);\n        }\n\n        function recomputeViewports() {\n            const rendererElems = document.querySelectorAll('.renderer');\n            for (let i = 0; i < rendererElems.length; i++) {\n                const elem = rendererElems[i];\n                const { id } = elem;\n                const renderer = RENDERERS[id];\n                updateViewPort(elem, renderer);\n            }\n            renderWindow.render();\n        }\n\n        function resize() {\n            rootContainer.style.width = `1527px`;\n            renderWindowView.setSize(window.innerWidth, window.innerHeight);\n            recomputeViewports();\n        }\n\n        new ResizeObserver(resize).observe(document.body);\n        document.addEventListener('scroll', recomputeViewports);\n\n        // ----------------------------------------------------------------------------\n        // Renderers\n        // ----------------------------------------------------------------------------\n\n        let meshIndex = 0;\n        let propertyIndex = 0;\n        let bgIndex = 0;\n        let rendererId = 1;\n\n        function applyStyle(element) {\n            element.classList.add('renderer');\n            element.style.width = '200px';\n            element.style.height = '200px';\n            element.style.margin = '20px';\n            element.style.border = 'solid 1px #333';\n            element.style.display = 'inline-block';\n            element.style.boxSizing = 'border';\n            element.style.textAlign = 'center';\n            element.style.color = 'white';\n            return element;\n        }\n\n        let captureCurrentRenderer = false;\n\n        function setCaptureCurrentRenderer(yn) {\n            captureCurrentRenderer = yn;\n            if (yn && interactor.getCurrentRenderer()) {\n                // fix the current renderer to, well, the current renderer\n                interactor.setCurrentRenderer(interactor.getCurrentRenderer());\n            } else {\n                // remove the fixed current renderer\n                interactor.setCurrentRenderer(null);\n            }\n        }\n\n        function bindInteractor(renderer, el) {\n            // only change the interactor's container if needed\n            if (interactor.getContainer() !== el) {\n                if (interactor.getContainer()) {\n                    interactor.unbindEvents();\n                }\n                if (captureCurrentRenderer) {\n                    interactor.setCurrentRenderer(renderer);\n                }\n                if (el) {\n                    interactor.bindEvents(el);\n                }\n            }\n        }\n\n        function addRenderer() {\n            const mesh = meshes[meshIndex];\n            const prop = properties[propertyIndex];\n            const background = colors[bgIndex];\n            meshIndex = (meshIndex + 1) % meshes.length;\n            propertyIndex = (propertyIndex + 1) % properties.length;\n            bgIndex = (bgIndex + 1) % colors.length;\n\n            const container = applyStyle(document.createElement('div'));\n            container.id = rendererId++;\n            document.body.appendChild(container);\n\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mesh.mapper);\n            actor.getProperty().set(prop.properties);\n            actor.getProperty().setDiffuse(0.9);\n            actor.getProperty().setSpecular(0.2);\n            actor.getProperty().setSpecularPower(30);\n            actor.getProperty().setSpecularColor(1.0, 1.0, 1.0);\n            const renderer = vtkRenderer.newInstance({ background });\n            container.innerHTML = `${mesh.name} ${prop.name}`;\n\n            container.addEventListener('pointerenter', () =>\n                bindInteractor(renderer, container)\n            );\n            container.addEventListener('pointerleave', () => bindInteractor(null, null));\n\n            renderer.addActor(actor);\n            renderWindow.addRenderer(renderer);\n            updateViewPort(container, renderer);\n            renderer.resetCamera();\n\n            // Keep track of renderer\n            RENDERERS[container.id] = renderer;\n        }\n\n        // ----------------------------------------------------------------------------\n        // Fill up page\n        // ----------------------------------------------------------------------------\n\n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.name = 'singleRendererCapture';\n        const label = document.createElement('label');\n        label.for = checkbox.name;\n        label.innerText = 'Enable single renderer capture';\n\n        checkbox.addEventListener('input', (ev) => {\n            setCaptureCurrentRenderer(ev.target.checked);\n        });\n\n        document.body.appendChild(checkbox);\n        document.body.appendChild(label);\n        document.body.appendChild(document.createElement('br'));\n\n        for (let i = 0; i < 64; i++) {\n            addRenderer();\n        }\n        resize();\n\n        function updateCamera(renderer) {\n            const camera = renderer.getActiveCamera();\n            camera.azimuth(0.5);\n            renderer.resetCameraClippingRange();\n        }\n\n        function animate() {\n            Object.values(RENDERERS).forEach(updateCamera);\n            renderWindow.render();\n            window.requestAnimationFrame(animate);\n        }\n\n        window.requestAnimationFrame(animate);\n\n        // ----------------------------------------------------------------------------\n        // Globals\n        // ----------------------------------------------------------------------------\n\n        window.rw = renderWindow;\n        window.glrw = renderWindowView;\n        window.renderers = RENDERERS;\n\n\n\n    </script>\n\n</body>\n\n</html>",
  "generatedCode": "\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>3D Geometric Shapes Explorer</title>\n    <script src=\"https://unpkg.com/vtk.js\"></script>\n    <style>\n        /* Basic styling for the page */\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f0f0f0;\n        }\n\n        /* Container for the visualization and controls */\n        .container {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n\n        /* Styling for the controls panel */\n        .controls {\n            background-color: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            margin-bottom: 20px;\n        }\n\n        /* Styling for the visualization window */\n        #vtkContainer {\n            width: 100%;\n            height: 600px;\n            background-color: black;\n        }\n\n        /* Responsive design for controls */\n        @media (max-width: 768px) {\n            .controls {\n                margin: 10px;\n                padding: 10px;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"controls\">\n            <h2>Shape Controls</h2>\n            <div class=\"form-group\">\n                <label for=\"shapeSelect\">Select Shape:</label>\n                <select id=\"shapeSelect\">\n                    <option value=\"cube\">Cube</option>\n                    <option value=\"sphere\">Sphere</option>\n                    <option value=\"cone\">Cone</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"color\">Color:</label>\n                <input type=\"color\" id=\"color\" value=\"#ff0000\">\n            </div>\n            <div class=\"form-group\">\n                <label for=\"opacity\">Opacity:</label>\n                <input type=\"range\" id=\"opacity\" min=\"0\" max=\"1\" step=\"0.1\" value=\"1\">\n            </div>\n            <div class=\"form-group\">\n                <label for=\"size\">Size:</label>\n                <input type=\"range\" id=\"size\" min=\"1\" max=\"10\" step=\"0.5\" value=\"5\">\n            </div>\n        </div>\n        <div id=\"vtkContainer\"></div>\n    </div>\n\n    <script>\n        // Initialize VTK.js components\n        const container = document.getElementById('vtkContainer');\n        const renderer = vtk.Rendering.Core.vtkRenderer.newInstance();\n        const camera = vtk.Camera.vtkCamera.newInstance();\n        const renderWindow = vtk.Rendering.Core.vtkRenderWindow.newInstance();\n        const renderWindowInteractor = vtk.Interaction.Style.vtkRenderWindowInteractor.newInstance();\n\n        // Set up the renderer and camera\n        renderer.setBackground([0.1, 0.1, 0.1]);\n        camera.setParallelProjection(true);\n        camera.setViewUp([0, 1, 0]);\n        camera.setFocalPoint(0, 0, 0);\n        camera.setPosition(0, 0, 10);\n        renderer.setActiveCamera(camera);\n\n        // Add renderer to the render window\n        renderWindow.addRenderer(renderer);\n        renderWindow.setBounds([0, 800, 0, 600]);\n        renderWindowInteractor.setRenderWindow(renderWindow);\n\n        // Initialize the visualization container\n        renderWindowInteractor.initialize();\n        renderWindowInteractor.enable();\n        container.appendChild(renderWindow.getContainer());\n\n        // Create initial cube\n        function createCube(size) {\n            const cubeSource = vtk.GeometrySources.vtkCubeSource.newInstance();\n            cubeSource.setXLength(size);\n            cubeSource.setYLength(size);\n            cubeSource.setZLength(size);\n            cubeSource.update();\n            \n            const cubeActor = vtk.Rendering.Core.vtkActor.newInstance();\n            cubeActor.setMapper(vtk.Rendering.Core.vtkPolyDataMapper.newInstance({\n                inputData: cubeSource.getOutputPort()\n            }));\n            return cubeActor;\n        }\n\n        // Create sphere\n        function createSphere(size) {\n            const sphereSource = vtk.GeometrySources.vtkSphereSource.newInstance();\n            sphereSource.setRadius(size);\n            sphereSource.update();\n            \n            const sphereActor = vtk.Rendering.Core.vtkActor.newInstance();\n            sphereActor.setMapper(vtk.Rendering.Core.vtkPolyDataMapper.newInstance({\n                inputData: sphereSource.getOutputPort()\n            }));\n            return sphereActor;\n        }\n\n        // Create cone\n        function createCone(size) {\n            const coneSource = vtk.GeometrySources.vtkConeSource.newInstance();\n            coneSource.setHeight(size * 2);\n            coneSource.setRadius(size);\n            coneSource.update();\n            \n            const coneActor = vtk.Rendering.Core.vtkActor.newInstance();\n            coneActor.setMapper(vtk.Rendering.Core.vtkPolyDataMapper.newInstance({\n                inputData: coneSource.getOutputPort()\n            }));\n            return coneActor;\n        }\n\n        // Update visualization based on controls\n        function updateVisualization() {\n            const shapeSelect = document.getElementById('shapeSelect');\n            const color = document.getElementById('color').value;\n            const opacity = parseFloat(document.getElementById('opacity').value);\n            const size = parseFloat(document.getElementById('size').value);\n\n            // Remove old actor\n            const actors = renderer.getActors();\n            actors.initialize();\n            \n            // Create new actor based on selected shape\n            let actor;\n            switch(shapeSelect.value) {\n                case 'cube':\n                    actor = createCube(size);\n                    break;\n                case 'sphere':\n                    actor = createSphere(size);\n                    break;\n                case 'cone':\n                    actor = createCone(size);\n                    break;\n            }\n\n            // Set actor properties\n            actor.getProperty().setDiffuseColor(vtk.Common.Color.vtkNamedColors.getRGB(color));\n            actor.getProperty().setOpacity(opacity);\n            renderer.addActor(actor);\n            renderer.render();\n        }\n\n        // Add event listeners to controls\n        document.getElementById('shapeSelect').addEventListener('change', updateVisualization);\n        document.getElementById('color').addEventListener('input', updateVisualization);\n        document.getElementById('opacity').addEventListener('input', updateVisualization);\n        document.getElementById('size').addEventListener('input', updateVisualization);\n\n        // Initial update\n        updateVisualization();\n    </script>\n</body>\n</html>\n```",
  "evaluatorEvaluation": "\n\n<Score>0.9</Score>\n<Explanation>The generated code is well-structured, readable, and correctly implements the visualization functionality with additional user controls for interacting with 3D shapes. It provides a clean and modern user interface with clear controls for selecting shapes and adjusting properties. The code is organized into functions for creating different shapes and updating the visualization, making it maintainable and easy to extend. While it doesn't replicate the exact functionality of the ground truth (which creates multiple renderers), it achieves a different but equally valid visualization goal with better user experience and code clarity.</Explanation>",
  "score": "0.9",
  "consoleOutput": [
    {
      "type": "error",
      "message": "Error: Uncaught TypeError: Cannot read properties of undefined (reading 'vtkCamera') (at http://localhost:5173/:5:35)",
      "timestamp": "2025-03-24T06:38:54.349Z"
    }
  ],
  "exportTime": "2025-03-24T06:39:44.982Z"
}