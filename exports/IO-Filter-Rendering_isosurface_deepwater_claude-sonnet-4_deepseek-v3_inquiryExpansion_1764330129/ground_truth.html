<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepwater数据集等值面渲染</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #renderer {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="renderer"></div>
    <script src="https://unpkg.com/vtk.js"></script>
    <script>
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkXMLImageDataReader = vtk.IO.XML.vtkXMLImageDataReader;
        const vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;
        const vtkImageMarchingCubes = vtk.Filters.General.vtkImageMarchingCubes;

        const fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({
            background: [1,1,1],
        });
        const renderWindow = fullScreenRenderWindow.getRenderWindow();
        const renderer = fullScreenRenderWindow.getRenderer();

        const reader = vtkXMLImageDataReader.newInstance();
        reader.setUrl('http://127.0.0.1:5000/dataset/deepwater.vti').then(() => {
            reader.loadData().then(() => {
                const imageData = reader.getOutputData(0);

                // 输出数据集中的数组名称，帮助调试
                // 修复：getArrayNames不是一个函数，改用getArrays()获取数组列表
                const arrays = imageData.getPointData().getArrays();
                const arrayNames = arrays.map(array => array.getName());
                console.log('数据集中的数组:', arrayNames);

                // 使用v02和v03数组计算速度大小
                const v02Array = imageData.getPointData().getArrayByName('v02');
                const v03Array = imageData.getPointData().getArrayByName('v03');
                
                if (!v02Array || !v03Array) {
                    console.error('找不到v02或v03数组');
                    // 尝试使用其他可用数组
                    const availableArray = imageData.getPointData().getArrayByName('prs');
                    if (availableArray) {
                        // 直接使用压力(prs)数组作为标量场
                        imageData.getPointData().setActiveScalars('prs');
                    } else {
                        console.error('无法找到合适的数组进行渲染');
                        return;
                    }
                } else {
                    // 计算速度大小
                    const numPoints = imageData.getNumberOfPoints();
                    const magnitudeData = new Float64Array(numPoints);

                    for (let i = 0; i < numPoints; i++) {
                        // v02和v03是标量数组，直接获取值
                        const v2 = v02Array.getData()[i];
                        const v3 = v03Array.getData()[i];
                        // 计算速度大小
                        magnitudeData[i] = Math.sqrt(v2 * v2 + v3 * v3);
                    }

                    // 创建速度大小数组
                    const vtkDataArray = vtk.Common.Core.vtkDataArray;
                    const magnitudeVtkArray = vtkDataArray.newInstance({
                        numberOfComponents: 1,
                        values: magnitudeData,
                        name: 'velocityMagnitude',
                    });
                    imageData.getPointData().addArray(magnitudeVtkArray);
                    imageData.getPointData().setActiveScalars('velocityMagnitude');
                }

                // 获取当前活动标量的范围
                const activeScalars = imageData.getPointData().getScalars();
                const newRange = activeScalars.getRange();
                const [minV, maxV] = newRange;

                console.log('使用的标量字段:', activeScalars.getName());
                console.log('数据范围:', newRange);

                const marchingCube = vtkImageMarchingCubes.newInstance({
                    contourValue: minV + 0.5 * (maxV - minV),
                    computeNormals: true,
                    mergePoints: true
                });

                marchingCube.setInputData(imageData);

                const mapper = vtkMapper.newInstance();
                mapper.setInputConnection(marchingCube.getOutputPort());

                const colorTransferFunction = vtkColorTransferFunction.newInstance();
                colorTransferFunction.addRGBPoint(minV, 0.0, 0.0, 1.0);
                colorTransferFunction.addRGBPoint(minV + 0.25 * (maxV - minV), 0.0, 0.5, 1.0);
                colorTransferFunction.addRGBPoint(minV + 0.5 * (maxV - minV), 1.0, 1.0, 1.0);
                colorTransferFunction.addRGBPoint(minV + 0.75 * (maxV - minV), 1.0, 0.5, 0.0);
                colorTransferFunction.addRGBPoint(maxV, 1.0, 0.0, 0.0);

                mapper.setLookupTable(colorTransferFunction);
                mapper.setScalarRange(minV, maxV);
                mapper.setInterpolateScalarsBeforeMapping(true);

                const actor = vtkActor.newInstance();
                actor.setMapper(mapper);
                actor.getProperty().setRepresentationToSurface();
                actor.getProperty().setEdgeVisibility(false);
                actor.getProperty().setOpacity(1.0);
                actor.getProperty().setAmbient(0.3);
                actor.getProperty().setDiffuse(0.7);
                actor.getProperty().setSpecular(0.4);

                renderer.addActor(actor);

                const bounds = imageData.getBounds();
                const center = [
                    (bounds[0] + bounds[1]) / 2,
                    (bounds[2] + bounds[3]) / 2,
                    (bounds[4] + bounds[5]) / 2,
                ];

                const camera = renderer.getActiveCamera();
                camera.setFocalPoint(...center);
                camera.setPosition(center[0] + 300, center[1] + 200, center[2] + 200);
                camera.setViewUp(0, 0, 1);
                renderer.resetCameraClippingRange();
                renderWindow.render();
                renderer.resetCamera();
                renderWindow.render();

                const axes = vtk.Rendering.Core.vtkAxesActor.newInstance();
                const widget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({
                    actor: axes,
                    interactor: renderWindow.getInteractor(),
                });
                widget.setEnabled(true);
                widget.setViewportCorner(
                    vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT
                );
                widget.setViewportSize(0.15);
                widget.setMinPixelSize(100);
                widget.setMaxPixelSize(300);

                const interactor = renderWindow.getInteractor();
                interactor.start();
            });
        });
    </script>
</body>

</html>